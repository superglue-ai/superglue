{
  "square_list_payments": {
    "id": "square_list_payments",
    "steps": [
      {
        "id": "listPayments",
        "apiConfig": {
          "id": "listPayments",
          "method": "GET",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<square_apiKey>>",
            "Square-Version": "2024-10-17"
          },
          "urlHost": "https://connect.squareup.com",
          "urlPath": "/v2/payments",
          "pagination": {
            "type": "CURSOR_BASED",
            "pageSize": "<<limit>>",
            "cursorPath": "data.cursor"
          },
          "instruction": "List payments from Square API with optional query parameters and cursor-based pagination.",
          "queryParams": {
            "limit": "<<limit>>",
            "cursor": "<<cursor>>",
            "end_time": "<<end_time>>",
            "begin_time": "<<begin_time>>",
            "sort_order": "<<sort_order>>",
            "location_id": "<<location_id>>"
          }
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T22:59:41.246Z",
    "updatedAt": "2025-10-21T22:59:41.246Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "description": "Maximum number of payments to list"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "square_apiKey": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "List payments from Square API.\n\nStep 1: List payments\n- Make a GET request to https://connect.squareup.com/v2/payments\n- Use Bearer token authentication with the API key from square integration\n- Headers: \n  - Authorization: Bearer <<square_apiKey>>\n  - Content-Type: application/json\n  - Square-Version: 2024-10-17\n- Accept optional query parameters: location_id, begin_time, end_time, sort_order, cursor, limit\n- Implement cursor-based pagination if cursor is present in the response\n\nReturn the payments array and cursor for pagination.",
    "outputTransform": "(sourceData) => {\n  const payments =\n    sourceData.listPayments?.payments || sourceData.listPayments?.results || [];\n  const cursor =\n    sourceData.listPayments?.cursor ||\n    sourceData.listPayments?.next_cursor ||\n    null;\n  return {\n    payments,\n    cursor,\n  };\n};",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool retrieves a list of payments directly from Square, using their API to gather payment data based on specified criteria like time range and location. It returns an array of payment details along with a cursor for easy pagination of results."
  },
  "square_refund_payment": {
    "id": "square_refund_payment",
    "steps": [
      {
        "id": "createRefund",
        "apiConfig": {
          "id": "createRefund",
          "body": "{\n  \"idempotency_key\": \"<<idempotency_key>>\",\n  \"payment_id\": \"<<payment_id>>\",\n  \"amount_money\": <<amount_money>>,\n  \"reason\": \"<<reason>>\"\n}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<square_apiKey>>",
            "Square-Version": "2024-10-17"
          },
          "urlHost": "https://connect.squareup.com",
          "urlPath": "/v2/refunds",
          "instruction": "Create a refund for a Square payment with idempotency_key, payment_id, amount_money, and optional reason."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T22:59:47.848Z",
    "updatedAt": "2025-10-21T22:59:47.848Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "reason": {
              "type": "string",
              "description": "Reason for the refund"
            },
            "payment_id": {
              "type": "string",
              "description": "ID of the payment to refund"
            },
            "amount_money": {
              "type": "object",
              "description": "Amount and currency for the refund"
            },
            "idempotency_key": {
              "type": "string",
              "description": "Unique key to prevent duplicate refunds"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "square_apiKey": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Create a refund for a Square payment.\n\nStep 1: Create refund\n- Make a POST request to https://connect.squareup.com/v2/refunds\n- Use Bearer token authentication with the API key from square integration\n- Headers: \n  - Authorization: Bearer <<square_apiKey>>\n  - Content-Type: application/json\n  - Square-Version: 2024-10-17\n- Body: JSON with required fields:\n  - idempotency_key: unique string for idempotency\n  - payment_id: ID of the payment to refund\n  - amount_money: object with amount and currency (e.g., {\"amount\": 100, \"currency\": \"USD\"})\n  - Optional fields: reason, location_id\n\nReturn the refund details.",
    "outputTransform": "(sourceData) => {\n  if (!sourceData.createRefund) throw new Error('No response from Square');\n  return sourceData.createRefund;\n}",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool interfaces with Square to issue a payment refund by using details such as payment ID, refund amount, and reason. It will return the complete refund information, including the refund ID, amount, and status from your Square account."
  },
  "square_search_orders": {
    "id": "square_search_orders",
    "steps": [
      {
        "id": "searchOrders",
        "apiConfig": {
          "id": "searchOrders",
          "body": "{\"limit\": <<limit>>, \"location_ids\": [\"L3WPYVSAWAJ2N\"]}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<square_apiKey>>",
            "Square-Version": "2024-10-17"
          },
          "urlHost": "https://connect.squareup.com",
          "urlPath": "/v2/orders/search",
          "pagination": {
            "type": "CURSOR_BASED",
            "pageSize": "<<limit>>",
            "cursorPath": "data.cursor"
          },
          "instruction": "Search orders using the Square Orders API with optional location_ids, query, limit, and cursor. Implement cursor-based pagination if cursor is present in the response."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T22:59:56.218Z",
    "updatedAt": "2025-10-21T22:59:56.218Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "description": "Number of results per page"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "square_apiKey": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Search orders from Square API.\n\nStep 1: Search orders\n- Make a POST request to https://connect.squareup.com/v2/orders/search\n- Use Bearer token authentication with the API key from square integration\n- Headers: \n  - Authorization: Bearer <<square_apiKey>>\n  - Content-Type: application/json\n  - Square-Version: 2024-10-17\n- Body: JSON with optional fields:\n  - location_ids: array of location IDs to search\n  - query: object with filter and sort criteria\n  - limit: number of results per page\n  - cursor: for pagination\n- Implement cursor-based pagination if cursor is present in the response\n\nReturn the orders array and cursor for pagination.",
    "outputTransform": "(sourceData) => {\n  if (!sourceData.searchOrders)\n    throw new Error(\"Missing searchOrders in sourceData\");\n\n  const orders = Array.isArray(sourceData.searchOrders.results)\n    ? sourceData.searchOrders.results\n    : [];\n  const cursor = sourceData.searchOrders.next_cursor || null;\n\n  return {\n    orders,\n    cursor,\n  };\n};",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool connects to Square's API to search and retrieve a list of orders from specified locations. It returns an array of orders along with a pagination cursor to help navigate through large sets of order data."
  },
  "square_list_catalog_items": {
    "id": "square_list_catalog_items",
    "steps": [
      {
        "id": "listCatalogItems",
        "apiConfig": {
          "id": "listCatalogItems",
          "method": "GET",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<square_apiKey>>",
            "Square-Version": "2024-10-17"
          },
          "urlHost": "https://connect.squareup.com",
          "urlPath": "/v2/catalog/list",
          "pagination": {
            "type": "CURSOR_BASED",
            "pageSize": "<<limit>>",
            "cursorPath": "data.cursor"
          },
          "instruction": "List catalog items from Square Catalog API, supporting optional types and limit, and handle cursor-based pagination.",
          "queryParams": {
            "limit": "<<limit>>",
            "types": "<<types>>"
          }
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T23:00:02.901Z",
    "updatedAt": "2025-10-21T23:00:02.901Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "description": "Maximum number of items to retrieve"
            },
            "types": {
              "type": "string",
              "description": "Specific types of catalog items to list"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "square_apiKey": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "List catalog items from Square API.\n\nStep 1: List catalog items\n- Make a GET request to https://connect.squareup.com/v2/catalog/list\n- Use Bearer token authentication with the API key from square integration\n- Headers: \n  - Authorization: Bearer <<square_apiKey>>\n  - Content-Type: application/json\n  - Square-Version: 2024-10-17\n- Accept optional query parameters: cursor, types (e.g., \"ITEM\"), limit\n- Implement cursor-based pagination if cursor is present in the response\n\nReturn the catalog objects array and cursor for pagination.",
    "outputTransform": "(sourceData) => {\n  const catalogObjects =\n    sourceData.listCatalogItems?.objects ||\n    sourceData.listCatalogItems?.results ||\n    [];\n  const cursor =\n    sourceData.listCatalogItems?.cursor ||\n    sourceData.listCatalogItems?.next_cursor ||\n    null;\n  return {\n    catalogObjects,\n    cursor,\n  };\n};",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool connects to Square to retrieve a list of items from your catalog. It returns the catalog items along with a cursor for pagination, allowing you to manage large sets of data efficiently."
  },
  "square_adjust_inventory": {
    "id": "square_adjust_inventory",
    "steps": [
      {
        "id": "batchChangeInventory",
        "apiConfig": {
          "id": "batchChangeInventory",
          "body": "{\n  \"idempotency_key\": \"<<idempotency_key>>\",\n  \"changes\": <<changes>>\n}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<square_apiKey>>",
            "Square-Version": "2024-10-17"
          },
          "urlHost": "https://connect.squareup.com",
          "urlPath": "/v2/inventory/changes/batch-create",
          "instruction": "Create batch inventory changes in Square with idempotency_key and changes array."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T23:04:43.928Z",
    "updatedAt": "2025-10-21T23:04:43.928Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "changes": {
              "type": "array",
              "description": "List of inventory change details"
            },
            "idempotency_key": {
              "type": "string",
              "description": "Unique string to prevent duplicate requests"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "square_apiKey": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Adjust inventory counts in Square.\n\nStep 1: Batch change inventory\n- Make a POST request to https://connect.squareup.com/v2/inventory/changes/batch-create\n- Use Bearer token authentication with the API key from square integration\n- Headers: \n  - Authorization: Bearer <<square_apiKey>>\n  - Content-Type: application/json\n  - Square-Version: 2024-10-17\n- Body: JSON with required fields:\n  - idempotency_key: unique string for idempotency\n  - changes: array of inventory change objects with:\n    - type: \"PHYSICAL_COUNT\" or \"ADJUSTMENT\"\n    - physical_count or adjustment object with catalog_object_id, location_id, quantity, occurred_at\n\nReturn the inventory changes result.",
    "outputTransform": "(sourceData) => {\n  if (!sourceData.batchChangeInventory) throw new Error('No response from Square');\n  return sourceData.batchChangeInventory;\n}",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool connects to Square to adjust inventory levels, allowing you to make batch changes to your stock counts. It will return the results of these inventory adjustments, directly reflecting the new counts in your Square account."
  },
  "square_create_customer": {
    "id": "square_create_customer",
    "steps": [
      {
        "id": "createCustomer",
        "apiConfig": {
          "id": "createCustomer",
          "body": "{\n  \"idempotency_key\": \"<<idempotency_key>>\",\n  \"given_name\": \"<<given_name>>\",\n  \"family_name\": \"<<family_name>>\",\n  \"email_address\": \"<<email_address>>\"\n}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<square_apiKey>>",
            "Square-Version": "2024-10-17"
          },
          "urlHost": "https://connect.squareup.com",
          "urlPath": "/v2/customers",
          "instruction": "Create a new customer in Square with the provided details and return the created customer object."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T23:04:52.603Z",
    "updatedAt": "2025-10-21T23:04:52.603Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "given_name": {
              "type": "string",
              "description": "Customer's first name"
            },
            "family_name": {
              "type": "string",
              "description": "Customer's last name"
            },
            "email_address": {
              "type": "string",
              "description": "Customer's email address"
            },
            "idempotency_key": {
              "type": "string",
              "description": "Unique string for idempotency"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "square_apiKey": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Create a customer in Square.\n\nStep 1: Create customer\n- Make a POST request to https://connect.squareup.com/v2/customers\n- Use Bearer token authentication with the API key from square integration\n- Headers: \n  - Authorization: Bearer <<square_apiKey>>\n  - Content-Type: application/json\n  - Square-Version: 2024-10-17\n- Body: JSON with optional fields:\n  - idempotency_key: unique string for idempotency\n  - given_name: customer's first name\n  - family_name: customer's last name\n  - email_address: customer's email\n  - phone_number: customer's phone\n  - address: customer's address object\n  - company_name: customer's company\n  - reference_id: external reference ID\n  - note: notes about customer\n\nReturn the created customer details.",
    "outputTransform": "(sourceData) => {\n  if (!sourceData.createCustomer) throw new Error('No response from Square');\n  return sourceData.createCustomer;\n}",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool creates a new customer profile in Square by using the provided personal details and a unique identifier to ensure the request is processed only once. It returns the complete details of the newly created customer, straight from your Square account."
  },
  "slack_list_channels": {
    "id": "slack_list_channels",
    "steps": [
      {
        "id": "listSlackChannels",
        "apiConfig": {
          "id": "listSlackChannels",
          "method": "GET",
          "headers": {
            "Authorization": "Bearer <<slack_api_key_api_token>>"
          },
          "urlHost": "https://slack.com/api",
          "urlPath": "/conversations.list",
          "instruction": "List public Slack channels using conversations.list with types=public_channel and limit=100.",
          "queryParams": {
            "limit": "100",
            "types": "public_channel"
          }
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T05:00:25.333Z",
    "updatedAt": "2025-10-22T00:14:00.715Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object"
        },
        "credentials": {
          "type": "object",
          "properties": {
            "slack_api_key_api_token": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "List Slack channels. Make a GET request to /conversations.list with Authorization header: Bearer <<slack_api_key_api_token>>. Include query parameters: types=public_channel and limit=100.",
    "outputTransform": "(sourceData) => { return sourceData.listSlackChannels; }",
    "systemIds": [],
    "description": "This tool connects to Slack to retrieve a list of public channels within your workspace. It returns a detailed list of up to 100 public Slack channels, providing essential information such as channel names and IDs."
  },
  "coupa_list_suppliers": {
    "id": "coupa_list_suppliers",
    "steps": [
      {
        "id": "getSuppliers",
        "apiConfig": {
          "id": "listSuppliers",
          "method": "GET",
          "headers": {
            "Accept": "application/json",
            "X-COUPA-API-KEY": "<<coupa_sim_api_key>>"
          },
          "urlHost": "https://<<coupa_sim_coupa_instance>>.coupahost.com",
          "urlPath": "/api/suppliers",
          "pagination": {
            "type": "OFFSET_BASED",
            "pageSize": "50"
          },
          "instruction": "Get list of suppliers from Coupa with pagination and filtering",
          "queryParams": {
            "limit": "{{payload.limit || 50}}",
            "offset": "{{payload.offset || 0}}",
            "status": "{{payload.status}}",
            "exported": "{{payload.exported !== false}}"
          },
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T01:20:37.869Z",
    "updatedAt": "2025-10-22T01:02:47.931Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "coupa_sim_api_key": {
              "type": "string",
              "description": "API key"
            },
            "coupa_sim_coupa_instance": {
              "type": "string",
              "description": "Coupa instance"
            },
            "limit": {
              "type": "number",
              "default": 50,
              "description": "Number of results to return"
            },
            "offset": {
              "type": "number",
              "default": 0,
              "description": "Number of results to skip for pagination"
            },
            "status": {
              "type": "string",
              "description": "Filter by supplier status"
            },
            "exported": {
              "type": "boolean",
              "default": true,
              "description": "Include all fields in the response"
            }
          }
        }
      }
    },
    "instruction": "List suppliers from Coupa using API key authentication with pagination and filtering support",
    "outputTransform": "$",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "page": {
          "type": "integer",
          "description": "Current page number"
        },
        "per_page": {
          "type": "integer",
          "description": "Items per page"
        },
        "suppliers": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "integer",
                "description": "Supplier ID"
              },
              "name": {
                "type": "string",
                "description": "Supplier name"
              },
              "status": {
                "type": "string",
                "description": "Supplier status"
              },
              "created_at": {
                "type": "string",
                "description": "Creation timestamp"
              },
              "updated_at": {
                "type": "string",
                "description": "Last update timestamp"
              }
            }
          },
          "description": "Array of supplier objects"
        },
        "total_count": {
          "type": "integer",
          "description": "Total number of suppliers"
        }
      }
    },
    "description": "This tool retrieves a list of suppliers from Coupa, allowing you to apply pagination and filtering options to tailor your results. It returns detailed information about each supplier, including their ID, name, status, and timestamps of creation and last update."
  },
  "salesforce_sync_contacts": {
    "id": "salesforce_sync_contacts",
    "steps": [
      {
        "id": "getAllContacts",
        "apiConfig": {
          "id": "getAllContacts",
          "method": "GET",
          "headers": {
            "Authorization": "Bearer <<salesforce_demo_api_key>>"
          },
          "urlHost": "https://<<salesforce_instance>>.my.salesforce.com",
          "urlPath": "/services/data/v59.0/query",
          "instruction": "Retrieve all contacts from Salesforce",
          "queryParams": {
            "q": "SELECT Id, FirstName, LastName, Email, Phone, AccountId, Title, Department FROM Contact"
          },
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T04:34:34.936Z",
    "updatedAt": "2025-10-22T01:49:49.627Z",
    "inputSchema": {
      "type": "object",
      "required": ["operation"],
      "properties": {
        "salesforce_demo_api_key": {
          "type": "string",
          "description": "API key"
        },
        "salesforce_instance": {
          "type": "string",
          "description": "Domain prefix"
        },
        "Email": {
          "type": "string",
          "description": "Contact's email address"
        },
        "Phone": {
          "type": "string",
          "description": "Contact's phone number"
        },
        "Title": {
          "type": "string",
          "description": "Contact's job title"
        },
        "query": {
          "type": "string",
          "description": "SOQL query for pulling contacts"
        },
        "LastName": {
          "type": "string",
          "description": "Contact's last name"
        },
        "AccountId": {
          "type": "string",
          "description": "Associated Account ID"
        },
        "FirstName": {
          "type": "string",
          "description": "Contact's first name"
        },
        "contactId": {
          "type": "string",
          "description": "Contact ID for push operation"
        },
        "operation": {
          "enum": ["pull", "push"],
          "type": "string",
          "description": "Operation type: 'pull' to query contacts, 'push' to create/update a contact"
        },
        "Department": {
          "type": "string",
          "description": "Contact's department"
        }
      }
    },
    "instruction": "Sync all contacts from Salesforce",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool connects to Salesforce to either retrieve or update contact information. It will return detailed contact data, including names, emails, and phone numbers, from your Salesforce account."
  },
  "salesforce_bulk_import_leads": {
    "id": "salesforce_bulk_import_leads",
    "steps": [
      {
        "id": "createLeads",
        "apiConfig": {
          "id": "createLeads",
          "body": "{\"FirstName\": \"{{loopItem.firstName}}\", \"LastName\": \"{{loopItem.lastName}}\", \"Company\": \"{{loopItem.company}}\", \"Email\": \"{{loopItem.email}}\"}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<salesforce_demo_api_key>>"
          },
          "urlHost": "https://<<salesforce_instance>>.my.salesforce.com",
          "urlPath": "/services/data/v59.0/sobjects/Lead",
          "instruction": "Create a lead in Salesforce",
          "authentication": "HEADER"
        },
        "dataSelector": "(sourceData) => sourceData.payload.leads",
        "executionMode": "LOOP"
      }
    ],
    "createdAt": "2025-10-21T04:37:43.171Z",
    "updatedAt": "2025-10-22T01:50:06.304Z",
    "inputSchema": {
      "type": "object",
      "required": ["leads"],
      "properties": {
        "salesforce_demo_api_key": {
          "type": "string",
          "description": "API key"
        },
        "salesforce_instance": {
          "type": "string",
          "description": "Domain prefix"
        },
        "leads": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "email": {
                "type": "string"
              },
              "company": {
                "type": "string"
              },
              "lastName": {
                "type": "string"
              },
              "firstName": {
                "type": "string"
              }
            }
          },
          "description": "List of lead details to import"
        }
      }
    },
    "instruction": "Bulk import leads into Salesforce from an array of lead objects",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool automates the process of importing multiple leads into Salesforce by creating new lead entries for each lead in your data set. It will return a confirmation of each lead successfully added to your Salesforce account, including all relevant lead details."
  },
  "netsuite_inventory_snapshot": {
    "id": "netsuite_inventory_snapshot",
    "steps": [
      {
        "id": "getInventoryItems",
        "apiConfig": {
          "id": "getInventoryItemsEndpoint",
          "method": "GET",
          "headers": {
            "Content-Type": "application/json"
          },
          "urlHost": "https://1234567.suitetalk.api.netsuite.com",
          "urlPath": "/services/rest/record/v1/item",
          "instruction": "Get inventory items and current quantities from NetSuite. Accepts query parameters for filtering by item_id, location, etc.",
          "queryParams": {},
          "authentication": "OAUTH2"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T00:52:54.407Z",
    "updatedAt": "2025-10-22T04:22:53.723Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "limit": {
          "type": "number",
          "description": "Maximum number of results to return"
        },
        "offset": {
          "type": "number",
          "description": "Number of records to skip for pagination"
        },
        "item_id": {
          "type": "string",
          "description": "Filter by specific item ID"
        },
        "location_id": {
          "type": "string",
          "description": "Filter by location ID"
        }
      }
    },
    "instruction": "Get inventory snapshot from NetSuite using the REST API with TBA authentication",
    "outputTransform": "$",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "totalItems": {
          "type": "number"
        },
        "snapshotDate": {
          "type": "string"
        },
        "inventoryItems": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "sku": {
                "type": "string"
              },
              "itemId": {
                "type": "string"
              },
              "itemName": {
                "type": "string"
              },
              "itemType": {
                "type": "string"
              },
              "locationId": {
                "type": "string"
              },
              "lastModified": {
                "type": "string"
              },
              "locationName": {
                "type": "string"
              },
              "reorderPoint": {
                "type": "number"
              },
              "quantityOnHand": {
                "type": "number"
              },
              "quantityOnOrder": {
                "type": "number"
              },
              "quantityAvailable": {
                "type": "number"
              }
            }
          }
        }
      }
    },
    "description": "This tool retrieves a detailed snapshot of your current inventory from NetSuite. It returns comprehensive information about each item, including total items, item details, quantities, and snapshot date, helping you stay informed about your stock levels."
  },
  "confluence_page_update": {
    "id": "confluence_page_update",
    "steps": [
      {
        "id": "getCurrentPage",
        "apiConfig": {
          "id": "getCurrentPage",
          "method": "PUT",
          "headers": {
            "Accept": "application/json",
            "Authorization": "Basic <<auth_email>>:<<auth_token>>"
          },
          "urlHost": "https://<<instance_subdomain>>.atlassian.net",
          "urlPath": "/wiki/rest/api/content/{page_id}",
          "instruction": "Update an existing Confluence page using PUT /wiki/rest/api/content/{page_id} endpoint. Accept page_id (required), title (required), body (required), and version_number (required) as inputs. The version number must be incremented from the current version. Create a JSON body with type=\"page\", title=title, body.storage.value=body, body.storage.representation=\"storage\", and version.number=version_number. Return the updated page JSON including id, title, version, status, and _links."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T03:34:30.130Z",
    "updatedAt": "2025-10-21T03:34:30.130Z",
    "inputSchema": {
      "type": "object",
      "required": ["page_id", "title", "body", "version_number"],
      "properties": {
        "auth_email": {
          "type": "string",
          "description": "Email address for authentication"
        },
        "auth_token": {
          "type": "string",
          "description": "API key"
        },
        "instance_subdomain": {
          "type": "string",
          "description": "Domain prefix of your Confluence instance"
        },
        "body": {
          "type": "string",
          "description": "Updated content in storage format (HTML)"
        },
        "title": {
          "type": "string",
          "description": "Updated title of the page"
        },
        "page_id": {
          "type": "string",
          "description": "ID of the page to update"
        },
        "version_number": {
          "type": "number",
          "description": "Version number (must be current version + 1)"
        }
      }
    },
    "instruction": "Update an existing Confluence page using PUT /wiki/rest/api/content/{page_id} endpoint. Accept page_id (required), title (required), body (required), and version_number (required) as inputs. The version number must be incremented from the current version. Create a JSON body with type=\"page\", title=title, body.storage.value=body, body.storage.representation=\"storage\", and version.number=version_number. Return the updated page JSON including id, title, version, status, and _links.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool updates an existing Confluence page by using the provided page ID, new title, content, and version number. It will return the updated page details, including the page ID, title, version, status, and links."
  },
  "servicenow_ticket_create": {
    "id": "servicenow_ticket_create",
    "steps": [
      {
        "id": "createIncident",
        "apiConfig": {
          "id": "createIncidentApi",
          "body": "{\"short_description\": \"${payload.short_description}\", \"description\": \"${payload.description}\", \"priority\": \"${payload.priority}\", \"urgency\": \"${payload.urgency}\", \"impact\": \"${payload.impact}\", \"caller_id\": \"${payload.caller_id}\", \"assignment_group\": \"${payload.assignment_group}\", \"assigned_to\": \"${payload.assigned_to}\", \"category\": \"${payload.category}\", \"subcategory\": \"${payload.subcategory}\"}",
          "method": "POST",
          "headers": {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "Authorization": "Basic <<servicenow_sim_username>>:<<servicenow_sim_password>>"
          },
          "urlHost": "https://<<servicenow_sim_instance>>.service-now.com",
          "urlPath": "/api/now/table/incident",
          "instruction": "Create a new incident in ServiceNow using the Table API",
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T03:59:00.504Z",
    "updatedAt": "2025-10-21T03:59:00.504Z",
    "inputSchema": {
      "type": "object",
      "required": ["short_description"],
      "properties": {
        "servicenow_username": {
          "type": "string",
          "description": "Username for authentication"
        },
        "servicenow_password": {
          "type": "string",
          "description": "Password for authentication"
        },
        "servicenow_instance": {
          "type": "string",
          "description": "Domain prefix of your ServiceNow instance"
        },
        "impact": {
          "enum": ["1", "2", "3"],
          "type": "string",
          "description": "Business impact (1=High, 2=Medium, 3=Low)"
        },
        "urgency": {
          "enum": ["1", "2", "3"],
          "type": "string",
          "description": "Urgency level (1=High, 2=Medium, 3=Low)"
        },
        "category": {
          "type": "string",
          "description": "Classification category (e.g., software, hardware, network, inquiry)"
        },
        "priority": {
          "enum": ["1", "2", "3", "4", "5"],
          "type": "string",
          "description": "Priority level (1=Critical, 2=High, 3=Moderate, 4=Low, 5=Planning)"
        },
        "caller_id": {
          "type": "string",
          "description": "sys_id of the user who reported the incident"
        },
        "assigned_to": {
          "type": "string",
          "description": "sys_id of the user to assign the incident to"
        },
        "description": {
          "type": "string",
          "description": "Detailed description of the incident"
        },
        "subcategory": {
          "type": "string",
          "description": "Classification subcategory (e.g., email, antivirus, printer)"
        },
        "assignment_group": {
          "type": "string",
          "description": "sys_id of the group to assign the incident to"
        },
        "short_description": {
          "type": "string",
          "description": "Brief description of the incident (required)"
        }
      }
    },
    "instruction": "Create a new incident ticket in ServiceNow. Accept short_description (required), description (optional), priority (optional, 1-5), urgency (optional, 1-3), impact (optional, 1-3), caller_id (optional sys_id), assignment_group (optional sys_id), assigned_to (optional sys_id), category (optional), and subcategory (optional) as inputs. Use POST to /api/now/table/incident endpoint. Return the created incident with sys_id, number, short_description, state, and other fields.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool seamlessly integrates with ServiceNow to create a new incident ticket, capturing important details like a brief description, priority, and category. It will return the created incident's information, including its ID, number, and current state, directly from your ServiceNow account."
  },
  "salesforce_publish_platform_event": {
    "id": "salesforce_publish_platform_event",
    "steps": [
      {
        "id": "publishPlatformEvent",
        "apiConfig": {
          "id": "publishPlatformEvent",
          "body": "{{payload.eventData}}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<salesforce_demo_api_key>>"
          },
          "urlHost": "https://<<salesforce_instance>>.my.salesforce.com",
          "urlPath": "/services/data/v59.0/sobjects/{{payload.eventType}}",
          "instruction": "Publish a platform event to Salesforce",
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T04:37:05.172Z",
    "updatedAt": "2025-10-22T01:50:02.513Z",
    "inputSchema": {
      "type": "object",
      "required": ["eventType", "eventData"],
      "properties": {
        "salesforce_demo_api_key": {
          "type": "string",
          "description": "API key"
        },
        "salesforce_instance": {
          "type": "string",
          "description": "Domain prefix"
        },
        "eventData": {
          "type": "object",
          "description": "Details of the event you want to publish"
        },
        "eventType": {
          "type": "string",
          "description": "Type of the event you want to publish"
        }
      }
    },
    "instruction": "Publish a platform event in Salesforce with eventType and eventData",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool sends a platform event directly to Salesforce using the specified event type and data. It returns a confirmation of the event published, ensuring your Salesforce environment is updated with the new event information."
  },
  "netsuite_sync_invoices": {
    "id": "netsuite_sync_invoices",
    "steps": [
      {
        "id": "getInvoices",
        "apiConfig": {
          "id": "getInvoicesEndpoint",
          "method": "GET",
          "headers": {
            "Content-Type": "application/json"
          },
          "urlHost": "https://1234567.suitetalk.api.netsuite.com",
          "urlPath": "/services/rest/record/v1/invoice",
          "instruction": "Get invoices from NetSuite. Accepts query parameters for filtering by date, customer, status, etc.",
          "queryParams": {},
          "authentication": "OAUTH2"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T00:54:10.234Z",
    "updatedAt": "2025-10-22T04:22:56.573Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "limit": {
          "type": "number",
          "description": "Maximum number of results to return"
        },
        "offset": {
          "type": "number",
          "description": "Number of records to skip for pagination"
        },
        "status": {
          "type": "string",
          "description": "Invoice status filter"
        },
        "date_to": {
          "type": "string",
          "description": "End date for filtering invoices (ISO format)"
        },
        "date_from": {
          "type": "string",
          "description": "Start date for filtering invoices (ISO format)"
        },
        "customer_id": {
          "type": "string",
          "description": "Filter by customer ID"
        }
      }
    },
    "instruction": "Sync invoices from NetSuite using the REST API with TBA authentication",
    "outputTransform": "$",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "invoices": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string"
              },
              "terms": {
                "type": "string"
              },
              "total": {
                "type": "number"
              },
              "status": {
                "type": "string"
              },
              "tranId": {
                "type": "string"
              },
              "dueDate": {
                "type": "string"
              },
              "currency": {
                "type": "string"
              },
              "tranDate": {
                "type": "string"
              },
              "amountDue": {
                "type": "number"
              },
              "amountPaid": {
                "type": "number"
              },
              "customerId": {
                "type": "string"
              },
              "daysPastDue": {
                "type": "number"
              },
              "customerName": {
                "type": "string"
              }
            }
          }
        },
        "totalCount": {
          "type": "number"
        },
        "totalAmountDue": {
          "type": "number"
        }
      }
    },
    "description": "This tool connects to NetSuite to retrieve a list of invoices based on specified filters such as date, customer, and status. It returns detailed information about each invoice, including the invoice ID, total amount, status, due date, and customer details."
  },
  "netsuite_search_transactions": {
    "id": "netsuite_search_transactions",
    "steps": [
      {
        "id": "searchTransactionsSuiteQL",
        "apiConfig": {
          "id": "searchTransactionsSuiteQLEndpoint",
          "body": "{\"q\": \"{{q}}\"}",
          "method": "POST",
          "headers": {
            "Prefer": "transient",
            "Content-Type": "application/json"
          },
          "urlHost": "https://1234567.suitetalk.api.netsuite.com",
          "urlPath": "/services/rest/query/v1/suiteql",
          "instruction": "Search transactions using SuiteQL query. Accepts a SuiteQL query string to search across transaction types.",
          "authentication": "OAUTH2"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T00:56:35.851Z",
    "updatedAt": "2025-10-22T04:23:04.207Z",
    "inputSchema": {
      "type": "object",
      "required": ["q"],
      "properties": {
        "q": {
          "type": "string",
          "description": "SuiteQL query string to search transactions"
        },
        "limit": {
          "type": "number",
          "description": "Maximum number of results to return"
        },
        "offset": {
          "type": "number",
          "description": "Number of records to skip for pagination"
        }
      }
    },
    "instruction": "Search transactions in NetSuite using SuiteQL with TBA authentication",
    "outputTransform": "$",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "totalCount": {
          "type": "number"
        },
        "transactions": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string"
              },
              "memo": {
                "type": "string"
              },
              "type": {
                "type": "string"
              },
              "total": {
                "type": "number"
              },
              "status": {
                "type": "string"
              },
              "tranId": {
                "type": "string"
              },
              "currency": {
                "type": "string"
              },
              "entityId": {
                "type": "string"
              },
              "tranDate": {
                "type": "string"
              },
              "entityName": {
                "type": "string"
              }
            }
          }
        }
      }
    },
    "description": "This tool allows you to search for transactions in NetSuite using a SuiteQL query. It will return detailed information on each transaction found, including the transaction ID, type, amount, and status."
  },
  "airtable_list_bases": {
    "id": "airtable_list_bases",
    "steps": [
      {
        "id": "listAirtableBases",
        "apiConfig": {
          "id": "listAirtableBases",
          "method": "GET",
          "headers": {
            "Authorization": "Bearer {{airtable_access_token}}"
          },
          "urlHost": "https://api.airtable.com",
          "urlPath": "/v0/meta/bases",
          "instruction": "List all accessible Airtable bases using the Metadata API, returning base id, name, and permission level",
          "queryParams": {},
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T05:53:05.910Z",
    "updatedAt": "2025-10-20T05:53:05.910Z",
    "inputSchema": {
      "type": "object",
      "properties": {}
    },
    "instruction": "List all accessible Airtable bases using the Metadata API.\n\nAPI Configuration:\n- Method: GET\n- Base URL: https://api.airtable.com\n- Path: /v0/meta/bases\n- Authentication: Bearer token in Authorization header using the access_token credential\n- Note: The access token must include the metadata scope (schema.bases:read)\n\nInput parameters:\n- None required (lists all bases accessible to the authenticated user)\n\nOutput format:\n{\n  \"bases\": [\n    {\n      \"id\": \"...\",\n      \"name\": \"...\",\n      \"permissionLevel\": \"...\"\n    }\n  ]\n}\n\nThe endpoint returns metadata about all bases the user has access to, including base IDs, names, and permission levels.",
    "outputTransform": "$",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "airtable_access_token": {
          "type": "string",
          "description": "Airtable API key"
        },
        "bases": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string"
              },
              "name": {
                "type": "string"
              },
              "permissionLevel": {
                "type": "string"
              }
            }
          }
        }
      }
    },
    "description": "This tool connects to Airtable to list all the bases you have access to. It will return detailed information including the base ID, name, and your permission level for each base."
  },
  "monday_archive_item": {
    "id": "monday_archive_item",
    "steps": [
      {
        "id": "archiveItem",
        "apiConfig": {
          "id": "archiveItem",
          "body": "{\"query\": \"mutation { archive_item (item_id: 18219753151) { id } }\"}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<monday_apiKey>>"
          },
          "urlHost": "https://api.monday.com/v2/",
          "urlPath": "",
          "version": null,
          "dataPath": null,
          "createdAt": null,
          "updatedAt": null,
          "pagination": null,
          "instruction": "Archive (soft delete) a Monday.com item using the GraphQL API, returning the id of the archived item.",
          "queryParams": null,
          "authentication": null,
          "outputSchema": null,
          "responseMapping": null,
          "documentationUrl": null
        },
        "inputMapping": null,
        "loopMaxIters": null,
        "dataSelector": null,
        "executionMode": "DIRECT",
        "responseMapping": null
      }
    ],
    "createdAt": "2025-10-20T04:39:00.114Z",
    "updatedAt": "2025-10-20T04:39:00.114Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "item_id": {
              "type": "integer",
              "description": "The unique identifier of the item to be archived"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "monday_apiKey": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Create a Monday.com workflow to archive (soft delete) an item using the GraphQL API.\n\nPOST request:\n- Authorization header: Bearer token using the apiKey credential\n- Content-Type: application/json\n- Request body must be JSON with this exact structure:\n{\n  \"query\": \"mutation { archive_item (item_id: ITEM_ID_NUMBER) { id } }\"\n}\n\nReplace ITEM_ID_NUMBER with the item_id value from the input payload (as a number without quotes).\n\nReturn the id from the response data.archive_item object, confirming the item was archived.",
    "outputTransform": "(sourceData) => { if (!sourceData.archiveItem?.data?.archive_item?.id) throw new Error('No id returned from archive_item'); return { id: sourceData.archiveItem.data.archive_item.id }; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool connects to Monday.com to archive a specified item, effectively marking it as inactive without permanently deleting it. It will return the ID of the archived item as confirmation that the action was successfully completed."
  },
  "monday_get_column_values": {
    "id": "monday_get_column_values",
    "steps": [
      {
        "id": "getBoardColumns",
        "apiConfig": {
          "id": "getBoardColumns",
          "body": "{\"query\": \"query { boards { id name columns { id title type settings_str } } }\"}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<monday_apiKey>>"
          },
          "urlHost": "https://api.monday.com/v2/",
          "urlPath": "",
          "version": null,
          "dataPath": null,
          "createdAt": null,
          "updatedAt": null,
          "pagination": null,
          "instruction": "Retrieve the columns (id, title, type, settings_str) for a specific board using the GraphQL API. The board ID is provided in the input payload.",
          "queryParams": null,
          "authentication": null,
          "outputSchema": null,
          "responseMapping": null,
          "documentationUrl": null
        },
        "inputMapping": null,
        "loopMaxIters": null,
        "dataSelector": null,
        "executionMode": "DIRECT",
        "responseMapping": null
      }
    ],
    "createdAt": "2025-10-20T04:40:09.026Z",
    "updatedAt": "2025-10-20T04:40:09.026Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "board_id": {
              "type": "integer",
              "description": "The unique number identifying the board"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "monday_apiKey": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Create a Monday.com workflow to retrieve a board's column definitions and metadata using the GraphQL API.\n\nPOST request:\n- Authorization header: Bearer token using the apiKey credential\n- Content-Type: application/json\n- Request body must be JSON with this exact structure:\n{\n  \"query\": \"query { boards(ids: [BOARD_ID_NUMBER]) { columns { id title type settings_str } } }\"\n}\n\nReplace BOARD_ID_NUMBER with the board_id value from the input payload (as a number without quotes).\n\nReturn the columns array from the response data.boards[0].columns object, containing id, title, type, and settings_str fields for each column.",
    "outputTransform": "(sourceData) => {\n  // Defensive: check for expected structure\n  const boards = sourceData.getBoardColumns?.data?.boards;\n  if (!Array.isArray(boards) || !Array.isArray(boards[0]?.columns)) {\n    throw new Error(\"No columns found for the specified board\");\n  }\n  // Only return the columns array, preserving id, title, type, settings_str for each column\n  return boards[0].columns.map((col) => ({\n    id: col.id,\n    title: col.title,\n    type: col.type,\n    settings_str: col.settings_str,\n  }));\n};\n",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool connects to Monday.com to retrieve information about the columns within a specified board. It will return details such as the column ID, title, type, and settings, providing a comprehensive overview of the board's structure."
  },
  "monday_list_groups": {
    "id": "monday_list_groups",
    "steps": [
      {
        "id": "getBoardGroups",
        "apiConfig": {
          "id": "getBoardGroups",
          "body": "{\"query\": \"query { boards { id groups { id title archived } } }\"}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<monday_apiKey>>"
          },
          "urlHost": "https://api.monday.com/v2/",
          "urlPath": "",
          "version": null,
          "dataPath": null,
          "createdAt": null,
          "updatedAt": null,
          "pagination": null,
          "instruction": "Get all groups (id, title, archived) for a specific board using the GraphQL API. The board ID is provided as a number in the input payload.",
          "queryParams": null,
          "authentication": null,
          "outputSchema": null,
          "responseMapping": null,
          "documentationUrl": null
        },
        "inputMapping": null,
        "loopMaxIters": null,
        "dataSelector": null,
        "executionMode": "DIRECT",
        "responseMapping": null
      }
    ],
    "createdAt": "2025-10-20T04:40:50.397Z",
    "updatedAt": "2025-10-20T04:40:50.397Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "board_id": {
              "type": "integer",
              "description": "The unique number identifying the board"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "monday_apiKey": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Create a Monday.com workflow to list all groups on a board using the GraphQL API.\n\nPOST request:\n- Authorization header: Bearer token using the apiKey credential\n- Content-Type: application/json\n- Request body must be JSON with this exact structure:\n{\n  \"query\": \"query { boards(ids: [BOARD_ID_NUMBER]) { groups { id title archived } } }\"\n}\n\nReplace BOARD_ID_NUMBER with the board_id value from the input payload (as a number without quotes).\n\nReturn the groups array from the response data.boards[0].groups object, containing id, title, and archived fields for each group.",
    "outputTransform": "(sourceData) => { if (!sourceData.getBoardGroups?.data?.boards?.[0]?.groups) throw new Error('No groups found in response'); return sourceData.getBoardGroups.data.boards[0].groups; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool connects to Monday.com to retrieve all groups associated with a specific board. It will return detailed information for each group, including their ID, title, and archived status."
  },
  "asana_create_task": {
    "id": "asana_create_task",
    "steps": [
      {
        "id": "createTask",
        "apiConfig": {
          "id": "createTask",
          "body": "{\"data\": {\"name\": \"<<(sourceData) => sourceData.name>>\",\"notes\": \"<<(sourceData) => sourceData.notes || ''>>\",\"assignee\": <<(sourceData) => sourceData.assignee_gid ? '\"' + sourceData.assignee_gid + '\"' : 'null'>>,\"due_on\": <<(sourceData) => sourceData.due_on ? '\"' + sourceData.due_on + '\"' : 'null'>>,\"projects\": <<(sourceData) => sourceData.project_gid ? '[\"' + sourceData.project_gid + '\"]' : '[]'>>,\"workspace\": \"1211689729234704\"}}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<asana_access_token>>"
          },
          "urlHost": "https://app.asana.com",
          "urlPath": "/api/1.0/tasks",
          "instruction": "Create a new task in Asana with the provided fields using the POST /api/1.0/tasks endpoint. Include name, notes, assignee, due date, projects, and workspace as available."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-19T19:10:32.893Z",
    "updatedAt": "2025-10-19T19:10:32.893Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Task name/title"
            },
            "notes": {
              "type": "string",
              "description": "Task description/notes"
            },
            "due_on": {
              "type": "string",
              "description": "Due date in YYYY-MM-DD format"
            },
            "project_gid": {
              "type": "null",
              "description": "The GID of the project to add the task to"
            },
            "assignee_gid": {
              "type": "null",
              "description": "The GID of the user to assign the task to"
            },
            "workspace_gid": {
              "type": "string",
              "description": "The GID of the workspace"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "asana_access_token": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Create a task in Asana using the POST /api/1.0/tasks endpoint. \n\nAPI Configuration:\n- Method: POST\n- URL: https://app.asana.com/api/1.0/tasks\n- Authentication: OAuth2 Bearer token\n- Headers: Authorization: Bearer {{asana_access_token}}\n\nRequest Body (JSON):\n{\n  \"data\": {\n    \"name\": \"{{workspace_gid.name}}\",\n    \"notes\": \"{{workspace_gid.notes}}\",\n    \"assignee\": \"{{workspace_gid.assignee_gid}}\",\n    \"due_on\": \"{{workspace_gid.due_on}}\",\n    \"projects\": [\"{{workspace_gid.project_gid}}\"],\n    \"workspace\": \"{{workspace_gid.workspace_gid}}\"\n  }\n}\n\nInput parameters:\n- workspace_gid (required): The GID of the workspace\n- name (required): Task name/title\n- notes (optional): Task description/notes\n- assignee_gid (optional): The GID of the user to assign the task to\n- due_on (optional): Due date in YYYY-MM-DD format\n- project_gid (optional): The GID of the project to add the task to\n\nReturn the complete task object from the Asana API response.",
    "outputTransform": "(sourceData) => { if (!sourceData.createTask?.data) throw new Error('No task data returned from Asana'); return sourceData.createTask.data; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool creates a new task in Asana with details such as task name, notes, assignee, due date, and project. It returns the complete task information directly from Asana, ensuring all specified fields are captured."
  },
  "asana_list_projects": {
    "id": "asana_list_projects",
    "steps": [
      {
        "id": "getAllProjectsInWorkspace",
        "apiConfig": {
          "id": "getAllProjectsInWorkspace",
          "method": "GET",
          "headers": {
            "Authorization": "Bearer <<asana_access_token>>"
          },
          "urlHost": "https://app.asana.com/api",
          "urlPath": "/1.0/workspaces/1211689729234704/projects",
          "pagination": {
            "type": "CURSOR_BASED",
            "pageSize": "100",
            "cursorPath": "data.next_page.uri"
          },
          "instruction": "Get all projects in the Asana workspace 1211689729234704, including gid, name, and workspace details. Use limit=100, archived=false, opt_fields=gid,name,workspace.gid,workspace.name. Implement cursor-based pagination by following next_page.uri until null.",
          "queryParams": {
            "limit": "100",
            "archived": "false",
            "opt_fields": "gid,name,workspace.gid,workspace.name"
          }
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-19T19:20:44.695Z",
    "updatedAt": "2025-10-19T19:20:44.695Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object"
        },
        "credentials": {
          "type": "object",
          "properties": {
            "asana_access_token": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "List all projects in Asana workspace.\n\nStep 1: Get projects from workspace\n- Make a GET request to https://app.asana.com/api/1.0/workspaces/1211689729234704/projects\n- Query parameters: limit=100, archived=false, opt_fields=gid,name,workspace.gid,workspace.name\n- Use Bearer token authentication with asana access token\n- Implement cursor-based pagination by following next_page.uri until it's null\n\nReturn the result as:\n{\n  \"projects\": [array of all projects with gid, name, and workspace details]\n}",
    "outputTransform": "(sourceData) => {\n  // Validate the structure\n  const results = sourceData.getAllProjectsInWorkspace?.results;\n  if (!Array.isArray(results))\n    throw new Error(\"Expected results array in getAllProjectsInWorkspace\");\n\n  // Flatten all project arrays from paginated results\n  const projects = results.flatMap((page) =>\n    Array.isArray(page?.data)\n      ? page.data.map((p) => ({\n          gid: p.gid,\n          name: p.name,\n          workspace: p.workspace\n            ? { gid: p.workspace.gid, name: p.workspace.name }\n            : undefined,\n        }))\n      : [],\n  );\n\n  return { projects };\n};\n",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "projects": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "gid": {
                "type": "string"
              },
              "name": {
                "type": "string"
              },
              "workspace": {
                "type": "object",
                "properties": {
                  "gid": {
                    "type": "string"
                  },
                  "name": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      }
    },
    "description": "This tool connects to your Asana account to retrieve a complete list of projects from a specified workspace. It will provide detailed information for each project, including its unique ID, name, and associated workspace details."
  },
  "asana_get_task": {
    "id": "asana_get_task",
    "steps": [
      {
        "id": "getTaskByGid",
        "apiConfig": {
          "id": "getTaskByGid",
          "method": "GET",
          "headers": {
            "Authorization": "Bearer <<asana_access_token>>"
          },
          "urlHost": "https://app.asana.com/api",
          "urlPath": "/1.0/tasks/<<task_gid>>",
          "instruction": "Fetch a specific Asana task by its GID, including fields: name, notes, assignee, status, completed, due_on, projects.name, workspace.name.",
          "queryParams": {
            "opt_fields": "name,notes,assignee,status,completed,due_on,projects.name,workspace.name"
          }
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-19T19:23:52.179Z",
    "updatedAt": "2025-10-19T19:23:52.179Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "task_gid": {
              "type": "string",
              "description": "The GID of the task you want to retrieve"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "asana_access_token": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Get a specific task from Asana by its GID.\n\nAPI Configuration:\n- Method: GET\n- URL: https://app.asana.com/api/1.0/tasks/{{task_gid}}\n- Authentication: OAuth2 Bearer token\n- Headers: Authorization: Bearer {{asana_access_token}}\n- Query Parameters: opt_fields=name,notes,assignee,status,completed,due_on,projects.name,workspace.name\n\nInput parameters:\n- task_gid (required): The GID of the task to fetch\n\nReturn the complete task object with all requested fields from the Asana API response data field.",
    "outputTransform": "(sourceData) => { if (!sourceData.getTaskByGid?.data) throw new Error('No task found for the provided GID'); return sourceData.getTaskByGid.data; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool retrieves detailed information about a specific task from Asana using its unique GID. It will return the task's name, notes, assignee, status, completion status, due date, associated projects, and workspace information."
  },
  "asana_update_task": {
    "id": "asana_update_task",
    "steps": [
      {
        "id": "updateTaskByGid",
        "apiConfig": {
          "id": "updateTaskByGid",
          "body": "<<(sourceData) => { const data = {}; if (sourceData.name != null) data.name = sourceData.name; if (sourceData.notes != null) data.notes = sourceData.notes; if (sourceData.assignee_gid != null) data.assignee = sourceData.assignee_gid; if (sourceData.due_on != null) data.due_on = sourceData.due_on; return JSON.stringify({ data }); }>>",
          "method": "PUT",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<asana_access_token>>"
          },
          "urlHost": "https://app.asana.com/api",
          "urlPath": "/1.0/tasks/<<task_gid>>",
          "instruction": "Update a specific Asana task by its GID, including only provided fields (name, notes, assignee, due_on) in the data object."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-19T19:32:18.096Z",
    "updatedAt": "2025-10-19T19:32:18.096Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "New task name or title"
            },
            "notes": {
              "type": "string",
              "description": "New task description or notes"
            },
            "task_gid": {
              "type": "string",
              "description": "The GID of the task to update"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "asana_access_token": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Update a task in Asana by its GID.\n\nAPI Configuration:\n- Method: PUT\n- URL: https://app.asana.com/api/1.0/tasks/{{task_gid}}\n- Authentication: OAuth2 Bearer token\n- Headers: Authorization: Bearer {{asana_access_token}}, Content-Type: application/json\n\nRequest Body (JSON):\nBuild a data object that only includes fields that are provided (not null/undefined). The structure should be:\n{\n  \"data\": {\n    // only include these fields if they are provided in the input:\n    \"name\": \"value if provided\",\n    \"notes\": \"value if provided\",\n    \"assignee\": \"value if provided\",\n    \"due_on\": \"value if provided\"\n  }\n}\n\nInput parameters:\n- task_gid (required): The GID of the task to update\n- name (optional): New task name/title\n- notes (optional): New task description/notes\n- assignee_gid (optional): The GID of the user to assign the task to\n- due_on (optional): New due date in YYYY-MM-DD format\n\nReturn the complete updated task object from the Asana API response.",
    "outputTransform": "(sourceData) => { if (!sourceData.updateTaskByGid || !sourceData.updateTaskByGid.data) throw new Error('No task data returned from Asana'); return sourceData.updateTaskByGid.data; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool updates a specific task in Asana using its unique ID, allowing you to modify fields like the task's name, notes, assignee, and due date. It will return the complete details of the updated task directly from Asana."
  },
  "asana_delete_task": {
    "id": "asana_delete_task",
    "steps": [
      {
        "id": "deleteTaskByGid",
        "apiConfig": {
          "id": "deleteTaskByGid",
          "method": "DELETE",
          "headers": {
            "Authorization": "Bearer <<asana_access_token>>"
          },
          "urlHost": "https://app.asana.com/api",
          "urlPath": "/1.0/tasks/<<task_gid>>",
          "instruction": "Delete a specific task in Asana by its GID."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-19T19:33:46.543Z",
    "updatedAt": "2025-10-19T19:33:46.543Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "task_gid": {
              "type": "string",
              "description": "The GID of the task to delete"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "asana_access_token": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Delete a task from Asana by its GID.\n\nAPI Configuration:\n- Method: DELETE\n- URL: https://app.asana.com/api/1.0/tasks/{{task_gid}}\n- Authentication: OAuth2 Bearer token\n- Headers: Authorization: Bearer {{asana_access_token}}\n\nInput parameters:\n- task_gid (required): The GID of the task to delete\n\nOutput:\nIf the deletion is successful (HTTP 200), return { \"success\": true }\nIf there's an error, forward the error message from Asana.",
    "outputTransform": "(sourceData) => {\n  const res = sourceData.deleteTaskByGid;\n  if (res && res.data !== undefined) {\n    // Asana returns { data: {} } on success\n    return { success: true };\n  }\n  // If error, try to forward the error message\n  if (res && res.data && res.data.error) {\n    return { success: false, error: res.data.error };\n  }\n  // If error is in a different structure\n  if (res && res.error) {\n    return { success: false, error: res.error };\n  }\n  throw new Error('Unexpected response from Asana');\n}",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool seamlessly connects to Asana to delete a specific task using its unique identifier. If successful, it confirms the deletion with a success message, or provides an error message if the task cannot be deleted."
  },
  "asana-add-comment-to-task": {
    "id": "asana-add-comment-to-task",
    "steps": [
      {
        "id": "addCommentToTask",
        "apiConfig": {
          "id": "addCommentToTask",
          "body": "{\"data\": {\"text\": \"<<text>>\"}}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<asana_access_token>>"
          },
          "urlHost": "https://app.asana.com/api",
          "urlPath": "/1.0/tasks/<<task_gid>>/stories",
          "instruction": "Add a comment to a specific Asana task using the stories endpoint. Return the created story (comment) object."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-19T20:29:50.762Z",
    "updatedAt": "2025-10-19T20:29:50.762Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "The comment text you want to add"
            },
            "task_gid": {
              "type": "string",
              "description": "The unique identifier for the task"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "asana_access_token": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Build an Asana tool to add a comment to a task. Use POST request to https://app.asana.com/api/1.0/tasks/{task_gid}/stories endpoint. The request body should be JSON with structure: {\"data\": {\"text\": \"{text}\"}}. Use OAuth2 authentication with Bearer token in header. Accept task_gid and text as required inputs. Return the created story data (comment object).",
    "outputTransform": "(sourceData) => { if (!sourceData.addCommentToTask?.data) throw new Error('No story data returned'); return sourceData.addCommentToTask.data; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool seamlessly integrates with Asana to add a comment to a specific task. It will return the newly created comment details, allowing you to keep track of conversations directly within your Asana project."
  },
  "stripe_create_payment_intent": {
    "id": "stripe_create_payment_intent",
    "steps": [
      {
        "id": "createPaymentIntent",
        "apiConfig": {
          "id": "createPaymentIntent",
          "body": "<<(sourceData) => { const encode = obj => Object.entries(obj).map(([k,v]) => encodeURIComponent(k) + '=' + encodeURIComponent(v)).join('&'); const body = {}; if (typeof sourceData.amount === 'number') body.amount = sourceData.amount; if (typeof sourceData.currency === 'string') body.currency = sourceData.currency; if (typeof sourceData.capture_method === 'string') body.capture_method = sourceData.capture_method; if (typeof sourceData.payment_method === 'string') body.payment_method = sourceData.payment_method; if (typeof sourceData.customer === 'string') body.customer = sourceData.customer; if (sourceData.metadata && typeof sourceData.metadata === 'object') { Object.entries(sourceData.metadata).forEach(([k,v]) => { if (v != null) body[`metadata[${k}]`] = v; }); } return encode(body); }>>",
          "method": "POST",
          "headers": {
            "Content-Type": "application/x-www-form-urlencoded",
            "Authorization": "Bearer <<stripe_api_key>>",
            "Idempotency-Key": "<<(sourceData) => sourceData.idempotency_key || ''>>"
          },
          "urlHost": "https://api.stripe.com",
          "urlPath": "/v1/payment_intents",
          "instruction": "Create a Stripe PaymentIntent with only the provided fields in the request body. Use Bearer token authentication. If idempotency_key is provided, send it as Idempotency-Key header."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T04:57:35.479Z",
    "updatedAt": "2025-10-20T04:57:35.479Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "required": ["stripe_api_key", "amount", "currency"],
          "properties": {
            "stripe_api_key": {
              "type": "string",
              "description": "Your personal API key"
            },
            "amount": {
              "type": "integer",
              "description": "The total amount to be charged, in cents"
            },
            "currency": {
              "type": "string",
              "description": "The currency for the transaction, e.g., 'usd'"
            },
            "metadata": {
              "type": "object",
              "properties": {
                "order_id": {
                  "type": "string",
                  "description": "An optional identifier for the order"
                },
                "customer_name": {
                  "type": "string",
                  "description": "The name of the customer, if available"
                }
              }
            },
            "capture_method": {
              "type": "string",
              "description": "How the payment will be captured, either 'automatic' or 'manual'"
            }
          }
        }
      }
    },
    "instruction": "Create a Stripe PaymentIntent using POST /v1/payment_intents endpoint. \n\nRequired inputs:\n- amount: integer in cents (required)\n- currency: string (required, e.g., \"usd\")\n\nOptional inputs:\n- capture_method: string (\"automatic\" or \"manual\", defaults to \"automatic\")\n- payment_method: string (optional)\n- customer: string (optional)\n- metadata: object (optional, flat key-value pairs)\n- idempotency_key: string (optional, send as Idempotency-Key header if provided)\n\nAuthentication: Use Bearer token with the api_key credential in Authorization header.\n\nBuild the request body dynamically to only include fields that are provided in the input payload. Do not send null or undefined fields.\n\nReturn the complete PaymentIntent object from Stripe's response.",
    "outputTransform": "(sourceData) => { return sourceData.createPaymentIntent.data; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool initiates a PaymentIntent on Stripe, allowing you to specify details like the amount, currency, and payment method. It returns the complete PaymentIntent information from Stripe, providing you with essential transaction details."
  },
  "asana-list-sections-in-project": {
    "id": "asana-list-sections-in-project",
    "steps": [
      {
        "id": "getSectionsForProject",
        "apiConfig": {
          "id": "getSectionsForProject",
          "method": "GET",
          "headers": {
            "Authorization": "Bearer <<asana_access_token>>"
          },
          "urlHost": "https://app.asana.com/api",
          "urlPath": "/1.0/projects/<<project_gid>>/sections",
          "instruction": "Get all sections in the specified Asana project using the project_gid. Use limit=100. OAuth2 Bearer token authentication.",
          "queryParams": {
            "limit": "100"
          }
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-19T20:38:01.142Z",
    "updatedAt": "2025-10-19T20:38:01.142Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "project_gid": {
              "type": "string",
              "description": "The unique identifier for the Asana project"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "asana_scopes": {
              "type": "string",
              "description": "Permissions required for Asana access"
            },
            "asana_auth_url": {
              "type": "string",
              "description": "URL for Asana authentication"
            },
            "asana_client_id": {
              "type": "string",
              "description": "Your Asana client ID"
            },
            "asana_token_url": {
              "type": "string",
              "description": "URL for obtaining Asana tokens"
            },
            "asana_expires_at": {
              "type": "string",
              "description": "Expiration time for the Asana token"
            },
            "asana_grant_type": {
              "type": "string",
              "description": "Type of grant for Asana authentication"
            },
            "asana_token_type": {
              "type": "string",
              "description": "Type of token used in Asana"
            },
            "asana_access_token": {
              "type": "string",
              "description": "Your personal API key"
            },
            "asana_client_secret": {
              "type": "string",
              "description": "Your Asana client secret"
            },
            "asana_refresh_token": {
              "type": "string",
              "description": "Token for refreshing Asana access"
            }
          }
        }
      }
    },
    "instruction": "List sections in an Asana project. Use GET to https://app.asana.com/api/1.0/projects/{project_gid}/sections with limit=100 query param. OAuth2 Bearer token auth. Input: project_gid. Return {\"sections\": data array} where data is the sections array from response.",
    "outputTransform": "(sourceData) => { return { sections: sourceData.getSectionsForProject?.data || [] }; }",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "sections": {
          "type": "array"
        }
      }
    },
    "description": "This tool connects to Asana to retrieve a list of all sections within a specified project. It will return an array containing details of each section, allowing you to easily view and manage the organizational structure of your Asana project."
  },
  "clickup-get-task-details": {
    "id": "clickup-get-task-details",
    "steps": [
      {
        "id": "getTaskDetails",
        "apiConfig": {
          "id": "getTaskDetails",
          "method": "GET",
          "headers": {
            "Authorization": "<<clickup_access_token>>"
          },
          "urlHost": "https://api.clickup.com/api/v2",
          "urlPath": "/task/<<task_id>>",
          "instruction": "Retrieve the complete details for a specific ClickUp task by its ID, including all fields such as name, status, due date, assignees, list, description, priority, tags, custom fields, etc."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-19T21:13:41.114Z",
    "updatedAt": "2025-10-19T21:13:41.114Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "task_id": {
              "type": "string",
              "description": "The unique identifier for the task"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "clickup_access_token": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Retrieve details for a specific ClickUp task by its ID. Use GET request to /task/{task_id} endpoint. Return the complete task object with all details including name, status, due date, assignees, list, description, priority, tags, custom fields, etc.",
    "outputTransform": "(sourceData) => { return sourceData.getTaskDetails; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool retrieves detailed information about a specific task from ClickUp using the task's ID. It will provide comprehensive task details, including its name, status, due date, assignees, and other associated information."
  },
  "clickup-list-folder-lists": {
    "id": "clickup-list-folder-lists",
    "steps": [
      {
        "id": "getListsInFolder",
        "apiConfig": {
          "id": "getListsInFolder",
          "method": "GET",
          "headers": {
            "accept": "application/json",
            "Authorization": "<<clickup_access_token>>"
          },
          "urlHost": "https://api.clickup.com/api/v2",
          "urlPath": "/folder/<<folder_id>>/list",
          "instruction": "Get all lists within the specified ClickUp folder."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-19T21:22:10.130Z",
    "updatedAt": "2025-10-19T21:22:10.130Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "folder_id": {
              "type": "string",
              "description": "The unique identifier for the folder"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "clickup_access_token": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "List all lists within a specified ClickUp folder. Use GET request to /folder/{folder_id}/list endpoint. Return an object with a 'lists' array where each list contains its id, name, status, and orderindex.",
    "outputTransform": "(sourceData) => {\n  // Defensive: ensure lists is an array\n  const lists = Array.isArray(sourceData.getListsInFolder?.lists) ? sourceData.getListsInFolder.lists : [];\n  return {\n    lists: lists.map(list => ({\n      id: list.id,\n      name: list.name,\n      status: list.status,\n      orderindex: list.orderindex\n    }))\n  };\n}",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "lists": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string"
              },
              "name": {
                "type": "string"
              },
              "status": {
                "type": "object"
              },
              "orderindex": {
                "type": "integer"
              }
            }
          }
        }
      }
    },
    "description": "This tool retrieves all the lists contained within a specified folder in your ClickUp workspace. It returns detailed information for each list, including its ID, name, status, and order position."
  },
  "stripe_list_customers": {
    "id": "stripe_list_customers",
    "steps": [
      {
        "id": "listAllCustomers",
        "apiConfig": {
          "id": "listAllCustomers",
          "method": "GET",
          "headers": {
            "Authorization": "Bearer <<stripe_api_key>>"
          },
          "urlHost": "https://api.stripe.com",
          "urlPath": "/v1/customers",
          "pagination": {
            "type": "CURSOR_BASED",
            "pageSize": "<<(sourceData) => sourceData.limit || 100>>",
            "cursorPath": "data[data.length-1].id"
          },
          "instruction": "List all Stripe customers using GET /v1/customers with support for limit and starting_after, and auto-pagination using has_more and last customer id.",
          "queryParams": {
            "limit": "<<(sourceData) => sourceData.limit || 100>>"
          }
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T04:58:54.085Z",
    "updatedAt": "2025-10-20T04:58:54.085Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "description": "Number of customers to return per page"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "stripe_api_key": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "List Stripe customers using GET /v1/customers endpoint with pagination support.\n\nInputs (all optional):\n- limit: integer (default 100, max 100) - number of customers to return per page\n- starting_after: string (cursor for pagination) - customer ID to start after\n\nThe endpoint should:\n1. Make a GET request to /v1/customers with query parameters for limit and starting_after\n2. Use Bearer token authentication with the api_key credential\n3. Support cursor-based pagination using the 'has_more' field and last customer's 'id' as starting_after\n4. Keep fetching pages automatically if has_more is true, using the last item's id as the next starting_after cursor\n5. Return all customers collected across all pages in the format: { \"data\": [...], \"has_more\": false }\n\nAuthentication: Use Bearer token with the api_key credential in Authorization header.",
    "outputTransform": "(sourceData) => {\n  // Collect all customers from all pages\n  let allCustomers = [];\n  if (Array.isArray(sourceData.listAllCustomers)) {\n    // If pagination returns an array of responses, flatten all data arrays\n    for (const page of sourceData.listAllCustomers) {\n      if (Array.isArray(page.data)) {\n        allCustomers = allCustomers.concat(page.data);\n      }\n    }\n    // has_more is false if the last page's has_more is false\n    const lastPage = sourceData.listAllCustomers[sourceData.listAllCustomers.length - 1];\n    return { data: allCustomers, has_more: lastPage?.has_more === true };\n  } else if (sourceData.listAllCustomers && Array.isArray(sourceData.listAllCustomers.data)) {\n    // Single page response\n    return { data: sourceData.listAllCustomers.data, has_more: sourceData.listAllCustomers.has_more === true };\n  } else {\n    return { data: [], has_more: false };\n  }\n}",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool connects to Stripe to retrieve a list of all customers associated with your account. It will return a comprehensive list of customers, including any necessary pagination to ensure all entries are collected."
  },
  "stripe_refund_payment": {
    "id": "stripe_refund_payment",
    "steps": [
      {
        "id": "createRefund",
        "apiConfig": {
          "id": "createRefund",
          "body": "<<(sourceData) => { const encode = obj => Object.entries(obj).map(([k,v]) => encodeURIComponent(k) + '=' + encodeURIComponent(v)).join('&'); const body = {}; if (typeof sourceData.payment_intent === 'string') body.payment_intent = sourceData.payment_intent; if (typeof sourceData.charge === 'string') body.charge = sourceData.charge; if (typeof sourceData.amount === 'number') body.amount = sourceData.amount; if (typeof sourceData.reason === 'string') body.reason = sourceData.reason; return encode(body); }>>",
          "method": "POST",
          "headers": {
            "Content-Type": "application/x-www-form-urlencoded",
            "Authorization": "Bearer <<stripe_api_key>>",
            "Idempotency-Key": "<<(sourceData) => sourceData.idempotency_key || ''>>"
          },
          "urlHost": "https://api.stripe.com",
          "urlPath": "/v1/refunds",
          "instruction": "Create a Stripe refund with only the provided fields in the request body. Use Bearer token authentication. If idempotency_key is provided, send it as Idempotency-Key header."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T05:05:40.909Z",
    "updatedAt": "2025-10-20T05:05:40.909Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "amount": {
              "type": "integer",
              "description": "Amount to refund in cents"
            },
            "charge": {
              "type": "string",
              "description": "Charge identifier for the transaction"
            },
            "reason": {
              "type": "string",
              "description": "Reason for the refund"
            },
            "payment_intent": {
              "type": "string",
              "description": "Payment intent identifier"
            },
            "idempotency_key": {
              "type": "string",
              "description": "Unique key to prevent duplicate refunds"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "stripe_api_key": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Create a Stripe refund using POST /v1/refunds endpoint.\n\nInputs:\n- payment_intent: string (recommended, one of payment_intent or charge is required)\n- charge: string (alternative to payment_intent, one is required)\n- amount: integer in cents (optional, omit for full refund)\n- reason: string (optional, e.g., \"duplicate\", \"fraudulent\", \"requested_by_customer\")\n- idempotency_key: string (optional, send as Idempotency-Key header if provided)\n\nRequest rules:\n1. Build the request body dynamically to only include fields that are provided in the input payload\n2. Do not send null or undefined fields\n3. At least one of payment_intent or charge must be provided\n4. If amount is not provided, Stripe will process a full refund\n5. If idempotency_key is provided, send it as Idempotency-Key header\n6. Use application/x-www-form-urlencoded for the request body\n\nAuthentication: Use Bearer token with the api_key credential in Authorization header.\n\nOutput: Return the complete Refund object from Stripe including id, status, amount, currency, and all other refund details.",
    "outputTransform": "(sourceData) => { return sourceData.createRefund; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool facilitates issuing a refund by connecting directly to Stripe, using either a payment intent or charge identifier. It returns comprehensive details of the refund, such as the refund ID, status, and amount, directly from your Stripe account."
  },
  "clickup-delete-task": {
    "id": "clickup-delete-task",
    "steps": [
      {
        "id": "deleteTaskById",
        "apiConfig": {
          "id": "deleteTaskById",
          "method": "DELETE",
          "headers": {
            "Authorization": "<<clickup_access_token>>"
          },
          "urlHost": "https://api.clickup.com/api/v2",
          "urlPath": "/task/<<task_id>>",
          "instruction": "Permanently delete a ClickUp task by its ID using the DELETE /task/{task_id} endpoint. No request body required."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-19T21:32:45.787Z",
    "updatedAt": "2025-10-19T21:32:45.787Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "task_id": {
              "type": "string",
              "description": "The unique identifier for the task you want to delete"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "clickup_access_token": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Permanently delete a ClickUp task by its ID. Use DELETE request to /task/{task_id} endpoint. No request body required. Return {\"success\": true} on successful deletion (HTTP 200). Forward any ClickUp error message if deletion fails.",
    "outputTransform": "(sourceData) => {\n  // ClickUp returns 204 No Content on success, error object on failure\n  const step = sourceData.deleteTaskById;\n  if (step === undefined) throw new Error('No response from ClickUp');\n  // If the API call succeeded (204), step will be an empty object or undefined\n  if (step === null || (typeof step === 'object' && Object.keys(step).length === 0)) {\n    return { success: true };\n  }\n  // If the API returned an error, forward the error message\n  if (step?.err || step?.error || step?.message) {\n    return { success: false, error: step.err || step.error || step.message };\n  }\n  // If the API returned a non-empty object, treat as error\n  return { success: false, error: step };\n}",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "success": {
          "type": "boolean"
        }
      }
    },
    "description": "This tool allows you to permanently delete a task in ClickUp using its unique ID. It will confirm the successful deletion by returning a message indicating success or forward any error details if the task cannot be deleted."
  },
  "clickup-create-task": {
    "id": "clickup-create-task",
    "steps": [
      {
        "id": "createTaskInList",
        "apiConfig": {
          "id": "createTaskInList",
          "body": "{\n  \"name\": \"<<name>>\",\n  \"description\": <<(sourceData) => sourceData.description ? JSON.stringify(sourceData.description) : undefined>>,\n  \"assignees\": <<(sourceData) => Array.isArray(sourceData.assignees) && sourceData.assignees.length > 0 ? JSON.stringify(sourceData.assignees) : undefined>>,\n  \"due_date\": <<(sourceData) => sourceData.due_date ? sourceData.due_date : undefined>>\n}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "<<clickup_access_token>>"
          },
          "urlHost": "https://api.clickup.com/api/v2",
          "urlPath": "/list/<<list_id>>/task",
          "instruction": "Create a new task in the specified ClickUp list with name (required), description (optional), assignees (optional array of user IDs), and due_date (optional timestamp in milliseconds). Return the complete task object. Handle 400 errors if list ID is invalid."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-19T21:35:38.827Z",
    "updatedAt": "2025-10-19T21:35:38.827Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "clickup_access_token": {
              "type": "string",
              "description": "ClickUp access token"
            },
            "name": {
              "type": "string",
              "description": "Task name"
            },
            "list_id": {
              "type": "string",
              "description": "List ID"
            },
            "due_date": {
              "type": "null",
              "description": "Due date"
            },
            "assignees": {
              "type": "array",
              "description": "Assignees"
            },
            "description": {
              "type": "string",
              "description": "Task description"
            }
          }
        }
      }
    },
    "instruction": "Create a new task in a specified ClickUp list. Use POST request to /list/{list_id}/task endpoint. Send JSON body with name (required), description (optional), assignees (optional array of user IDs), and due_date (optional timestamp in milliseconds). Return the complete task object from ClickUp's response. Handle 400 errors if list ID is invalid.",
    "outputTransform": "(sourceData) => {\n  if (sourceData.createTaskInList?.err && sourceData.createTaskInList.err.response?.status === 400) {\n    return { error: 'Invalid list_id', details: sourceData.createTaskInList.err.response.data };\n  }\n  if (sourceData.createTaskInList?.task) {\n    return sourceData.createTaskInList.task.data;\n  }\n  // If the response is the full task object at root\n  if (sourceData.createTaskInList && typeof sourceData.createTaskInList === 'object' && sourceData.createTaskInList.id) {\n    return sourceData.createTaskInList;\n  }\n  throw new Error('Unexpected ClickUp response');\n}",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool integrates with ClickUp to create a new task in a specified list using the provided details such as task name, description, assignees, and due date. It returns the complete task information from ClickUp, ensuring the list ID is valid to prevent errors."
  },
  "clickup-list-tasks": {
    "id": "clickup-list-tasks",
    "steps": [
      {
        "id": "getTasksInList",
        "apiConfig": {
          "id": "getTasksInList",
          "method": "GET",
          "headers": {
            "Authorization": "<<clickup_access_token>>"
          },
          "urlHost": "https://api.clickup.com/api/v2",
          "urlPath": "/list/<<list_id>>/task",
          "pagination": {
            "type": "PAGE_BASED",
            "pageSize": "100",
            "cursorPath": ""
          },
          "instruction": "Get all tasks in the specified ClickUp list with archived=false, supporting page-based pagination (100 per page).",
          "queryParams": {
            "page": "<<(sourceData) => typeof sourceData.page === 'number' ? sourceData.page : 0>>",
            "archived": "false"
          }
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-19T21:39:16.244Z",
    "updatedAt": "2025-10-19T21:39:16.244Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "page": {
              "type": "integer",
              "description": "Page number for task retrieval"
            },
            "list_id": {
              "type": "string",
              "description": "ID of the ClickUp list"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "clickup_access_token": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "List all tasks in a given ClickUp list. Use GET request to /list/{list_id}/task endpoint with archived=false parameter. Support pagination with page parameter (default 0). Return {\"tasks\": [...]} where each task contains id, name, status, assignees, and due_date. Use page-based pagination with 100 tasks per page limit until no further results are returned.",
    "outputTransform": "(sourceData) => {\n  // Collect all tasks from all pages\n  let allTasks = [];\n  if (Array.isArray(sourceData.getTasksInList)) {\n    // If paginated, array of responses\n    for (const page of sourceData.getTasksInList) {\n      if (Array.isArray(page?.tasks)) {\n        allTasks = allTasks.concat(page.tasks);\n      }\n    }\n  } else if (Array.isArray(sourceData.getTasksInList?.tasks)) {\n    // Single page\n    allTasks = sourceData.getTasksInList.tasks;\n  }\n  // Map to required fields\n  const tasks = allTasks.map(task => ({\n    id: task.id,\n    name: task.name,\n    status: task.status,\n    assignees: task.assignees,\n    due_date: task.due_date\n  }));\n  return { tasks };\n}",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "tasks": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string"
              },
              "name": {
                "type": "string"
              },
              "status": {
                "type": "object"
              },
              "due_date": {
                "type": ["number", "null"]
              },
              "assignees": {
                "type": "array"
              }
            }
          }
        }
      }
    },
    "description": "This tool retrieves all tasks from a specific ClickUp list, ensuring that only active tasks are included. It provides a comprehensive overview of each task, including details such as the task ID, name, status, assignees, and due date, with results organized in pages of up to 100 tasks each."
  },
  "clickup-update-task": {
    "id": "clickup-update-task",
    "steps": [
      {
        "id": "updateTask",
        "apiConfig": {
          "id": "updateTask",
          "body": "<<(sourceData) => { const body = {}; if (sourceData.name) body.name = sourceData.name; if (sourceData.description) body.description = sourceData.description; if (sourceData.status) body.status = sourceData.status; if (typeof sourceData.priority === 'number') body.priority = sourceData.priority; if (typeof sourceData.due_date === 'number') body.due_date = sourceData.due_date; return JSON.stringify(body); }>>",
          "method": "PUT",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<clickup_access_token>>"
          },
          "urlHost": "https://api.clickup.com/api/v2",
          "urlPath": "/task/<<task_id>>",
          "instruction": "Update an existing ClickUp task by its ID, supporting partial updates for name, description, status, priority, and due_date. Only include fields provided by the user."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-19T21:41:03.465Z",
    "updatedAt": "2025-10-19T21:41:03.465Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Updated task title"
            },
            "task_id": {
              "type": "string",
              "description": "Unique identifier for the task"
            },
            "priority": {
              "type": "integer",
              "description": "Task priority level (1-4)"
            },
            "description": {
              "type": "string",
              "description": "Updated task notes"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "clickup_access_token": {
              "type": "string",
              "description": "Access token for ClickUp"
            }
          }
        }
      }
    },
    "instruction": "Update an existing ClickUp task by its ID. Use PUT request to /task/{task_id} endpoint. Support partial updates with optional fields: name (updated title), description (updated notes), status (new status), priority (integer 1-4), due_date (timestamp in milliseconds). Only include fields that are provided by the user - omit null or empty values. Return the updated task object from the API response.",
    "outputTransform": "(sourceData) => { return sourceData.updateTask; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool updates an existing task in ClickUp by allowing changes to its title, notes, status, priority, and due date based on the information you provide. It will return the updated task details directly from ClickUp, reflecting any modifications made."
  },
  "clickup-add-task-comment": {
    "id": "clickup-add-task-comment",
    "steps": [
      {
        "id": "validateTaskExists",
        "apiConfig": {
          "id": "validateTaskExists",
          "method": "GET",
          "headers": {
            "Authorization": "<<clickup_access_token>>"
          },
          "urlHost": "https://api.clickup.com/api/v2",
          "urlPath": "/task/<<task_id>>",
          "instruction": "Fetch the task details to validate that the provided task_id exists."
        },
        "executionMode": "DIRECT"
      },
      {
        "id": "addTaskComment",
        "apiConfig": {
          "id": "addTaskComment",
          "body": "{ \"comment_text\": \"<<comment_text>>\", \"notify_all\": false }",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "<<clickup_access_token>>"
          },
          "urlHost": "https://api.clickup.com/api/v2",
          "urlPath": "/task/<<task_id>>/comment",
          "instruction": "Add a comment to the specified ClickUp task using the /task/{task_id}/comment endpoint. Send JSON body with comment_text (required) and optional assignee if provided."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-19T21:42:44.161Z",
    "updatedAt": "2025-10-19T21:42:44.161Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "task_id": {
              "type": "string",
              "description": "The unique identifier for the task"
            },
            "comment_text": {
              "type": "string",
              "description": "The text of the comment you want to add"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "clickup_access_token": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Add a comment to a ClickUp task. Use POST request to /task/{task_id}/comment endpoint. Send JSON body with comment_text (required text body) and assignee (optional user ID for tagging). Return the created comment object from ClickUp's response. Validate that task_id exists and return descriptive error if not found.",
    "outputTransform": "(sourceData) => {\n  // If the task does not exist, ClickUp returns 404 or error in validateTaskExists\n  if (sourceData.validateTaskExists?.err || sourceData.validateTaskExists?.status === 404) {\n    return { error: `Task with id '${sourceData.task_id}' not found in ClickUp. Please check the task_id and try again.` };\n  }\n  // If comment creation failed, return error\n  if (sourceData.addTaskComment?.err) {\n    return { error: `Failed to add comment: ${sourceData.addTaskComment.err.message || 'Unknown error'}` };\n  }\n  // Return the created comment object from ClickUp's response\n  return sourceData.addTaskComment;\n}",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool interfaces with ClickUp to add a comment to a specified task. It will confirm the task exists and return the details of the newly added comment, or an error if the task cannot be found or the comment addition fails."
  },
  "procore_list_projects": {
    "id": "procore_list_projects",
    "steps": [
      {
        "id": "getProjects",
        "apiConfig": {
          "id": "getProjects",
          "method": "GET",
          "headers": {
            "Procore-Company-Id": "{{company_id}}"
          },
          "urlHost": "https://api.procore.com",
          "urlPath": "/rest/v1.1/projects",
          "instruction": "Get list of Procore projects for a company",
          "queryParams": {
            "page": "{{page}}",
            "per_page": "{{per_page}}",
            "company_id": "{{company_id}}",
            "include_inactive": "{{include_inactive}}"
          },
          "authentication": "OAUTH2"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T21:38:21.557Z",
    "updatedAt": "2025-10-20T21:38:21.557Z",
    "inputSchema": {
      "type": "object",
      "required": ["company_id"],
      "properties": {
        "page": {
          "type": "integer",
          "description": "Page number for pagination"
        },
        "per_page": {
          "type": "integer",
          "description": "Number of results per page"
        },
        "company_id": {
          "type": "string",
          "description": "The Procore company ID"
        },
        "include_inactive": {
          "type": "boolean",
          "description": "Include inactive projects in the results"
        }
      }
    },
    "instruction": "Call Procore projects endpoint. GET request to /rest/v1.1/projects. Add Procore-Company-Id header with company_id value. Query params: company_id, include_inactive, page, per_page (all from input). Return full response.",
    "outputTransform": "$",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "projects": {
          "type": "array",
          "description": "List of Procore projects"
        }
      }
    },
    "description": "This tool connects to Procore to retrieve a comprehensive list of projects associated with a specific company. It returns detailed information about each project, including the option to include inactive projects if desired."
  },
  "stripe_retrieve_payment_intent": {
    "id": "stripe_retrieve_payment_intent",
    "steps": [
      {
        "id": "getPaymentIntentById",
        "apiConfig": {
          "id": "getPaymentIntentById",
          "method": "GET",
          "headers": {
            "Authorization": "Bearer <<stripe_api_key>>"
          },
          "urlHost": "https://api.stripe.com",
          "urlPath": "/v1/payment_intents/<<payment_intent_id>>",
          "instruction": "Retrieve a Stripe PaymentIntent by ID, returning all details including status, amount, customer, charges, next_action, and more."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T05:06:58.222Z",
    "updatedAt": "2025-10-20T05:06:58.222Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "payment_intent_id": {
              "type": "string",
              "description": "The ID of the PaymentIntent you want to retrieve"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "stripe_api_key": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Retrieve a Stripe PaymentIntent by ID using GET /v1/payment_intents/{payment_intent_id} endpoint.\n\nInputs:\n- payment_intent_id: string (required) - The ID of the PaymentIntent to retrieve\n\nRequest rules:\n1. Make a GET request to /v1/payment_intents/{payment_intent_id}\n2. The payment_intent_id should be inserted into the URL path\n3. Use Bearer token authentication with the api_key credential in Authorization header\n4. No request body needed for GET requests\n\nAuthentication: Use Bearer token with the api_key credential in Authorization header.\n\nOutput: Return the complete PaymentIntent object from Stripe including status, amount, customer, charges, next_action, and all other payment intent details.",
    "outputTransform": "(sourceData) => { return sourceData.getPaymentIntentById; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool retrieves detailed information about a specific payment intent directly from Stripe using its unique ID. It will provide comprehensive payment details, including the status, amount, customer information, and any associated charges."
  },
  "stripe_confirm_payment_intent": {
    "id": "stripe_confirm_payment_intent",
    "steps": [
      {
        "id": "confirmPaymentIntent",
        "apiConfig": {
          "id": "confirmPaymentIntent",
          "body": "<<(sourceData) => { const encode = obj => Object.entries(obj).map(([k,v]) => encodeURIComponent(k) + '=' + encodeURIComponent(v)).join('&'); const body = {}; if (typeof sourceData.payment_method === 'string') body.payment_method = sourceData.payment_method; if (typeof sourceData.return_url === 'string') body.return_url = sourceData.return_url; if (sourceData.shipping && typeof sourceData.shipping === 'object') { const flattenShipping = (obj, prefix) => { Object.entries(obj).forEach(([k, v]) => { const key = prefix ? `${prefix}[${k}]` : k; if (v && typeof v === 'object' && !Array.isArray(v)) { flattenShipping(v, key); } else if (v != null) { body[key] = v; } }); }; flattenShipping(sourceData.shipping, 'shipping'); } return encode(body); }>>",
          "method": "POST",
          "headers": {
            "Content-Type": "application/x-www-form-urlencoded",
            "Authorization": "Bearer <<stripe_api_key>>",
            "Idempotency-Key": "<<(sourceData) => sourceData.idempotency_key || ''>>"
          },
          "urlHost": "https://api.stripe.com",
          "urlPath": "/v1/payment_intents/<<payment_intent_id>>/confirm",
          "instruction": "Confirm a Stripe PaymentIntent by ID with optional payment_method, return_url, and shipping details. Handle shipping as a nested object flattened into form-encoded format."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T05:08:23.062Z",
    "updatedAt": "2025-10-20T05:08:23.062Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "shipping": {
              "type": "object",
              "description": "Shipping details as a JSON object"
            },
            "return_url": {
              "type": "string",
              "description": "URL to redirect for payment methods"
            },
            "payment_method": {
              "type": "string",
              "description": "Payment method ID to attach"
            },
            "idempotency_key": {
              "type": "string",
              "description": "Unique key to prevent duplicate charges"
            },
            "payment_intent_id": {
              "type": "string",
              "description": "ID of the PaymentIntent to confirm"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "stripe_api_key": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Confirm a Stripe PaymentIntent using POST /v1/payment_intents/{payment_intent_id}/confirm endpoint.\n\nInputs:\n- payment_intent_id: string (required) - The ID of the PaymentIntent to confirm\n- payment_method: string (optional) - Payment method ID to attach if not already attached\n- return_url: string (optional) - URL to redirect to for redirect-based payment methods\n- shipping: object (optional) - Shipping details as a JSON object\n- idempotency_key: string (optional) - Send as Idempotency-Key header if provided\n\nRequest rules:\n1. Make a POST request to /v1/payment_intents/{payment_intent_id}/confirm\n2. The payment_intent_id should be inserted into the URL path\n3. Build the request body dynamically to only include fields that are provided in the input payload\n4. Do not send null or undefined fields\n5. Use application/x-www-form-urlencoded for the request body\n6. If idempotency_key is provided, send it as Idempotency-Key header\n7. Handle shipping object by flattening it into form-encoded format (e.g., shipping[name], shipping[address][line1])\n\nAuthentication: Use Bearer token with the api_key credential in Authorization header.\n\nOutput: Return the updated PaymentIntent object from Stripe. The status may be requires_action (for 3D Secure), succeeded (payment complete), requires_payment_method (if failed), or other statuses.",
    "outputTransform": "(sourceData) => { return sourceData.confirmPaymentIntent; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool connects to Stripe to confirm a PaymentIntent by processing the provided payment method, return URL, and shipping details. It will return the updated PaymentIntent object, including its status, which indicates whether the payment requires further action, has succeeded, or needs a new payment method."
  },
  "stripe_capture_payment_intent": {
    "id": "stripe_capture_payment_intent",
    "steps": [
      {
        "id": "capturePaymentIntent",
        "apiConfig": {
          "id": "capturePaymentIntent",
          "body": "<<(sourceData) => { const encode = obj => Object.entries(obj).map(([k,v]) => encodeURIComponent(k) + '=' + encodeURIComponent(v)).join('&'); const body = {}; if (typeof sourceData.amount_to_capture === 'number') body.amount_to_capture = sourceData.amount_to_capture; return encode(body); }>>",
          "method": "POST",
          "headers": {
            "Content-Type": "application/x-www-form-urlencoded",
            "Authorization": "Bearer <<stripe_api_key>>",
            "Idempotency-Key": "<<(sourceData) => sourceData.idempotency_key || ''>>"
          },
          "urlHost": "https://api.stripe.com",
          "urlPath": "/v1/payment_intents/<<payment_intent_id>>/capture",
          "instruction": "Capture a Stripe PaymentIntent by ID with optional amount_to_capture for partial captures. Use Bearer token authentication. If idempotency_key is provided, send it as Idempotency-Key header."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T05:09:48.829Z",
    "updatedAt": "2025-10-20T05:09:48.829Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "idempotency_key": {
              "type": "string",
              "description": "Unique key to prevent duplicate captures"
            },
            "amount_to_capture": {
              "type": "integer",
              "description": "Amount in cents to capture"
            },
            "payment_intent_id": {
              "type": "string",
              "description": "ID of the PaymentIntent to capture"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "stripe_api_key": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Capture a Stripe PaymentIntent using POST /v1/payment_intents/{payment_intent_id}/capture endpoint.\n\nInputs:\n- payment_intent_id: string (required) - The ID of the PaymentIntent to capture (must be in requires_capture status)\n- amount_to_capture: integer in cents (optional) - Amount to capture for partial captures; omit for full capture\n- idempotency_key: string (optional) - Send as Idempotency-Key header if provided\n\nRequest rules:\n1. Make a POST request to /v1/payment_intents/{payment_intent_id}/capture\n2. The payment_intent_id should be inserted into the URL path\n3. Build the request body dynamically to only include fields that are provided in the input payload\n4. Do not send null or undefined fields\n5. Use application/x-www-form-urlencoded for the request body\n6. If idempotency_key is provided, send it as Idempotency-Key header\n7. If amount_to_capture is not provided, Stripe will capture the full authorized amount\n\nAuthentication: Use Bearer token with the api_key credential in Authorization header.\n\nOutput: Return the updated PaymentIntent object from Stripe after capture. The response will include:\n- status (should be succeeded after successful capture)\n- charges (updated with captured charge details)\n- amount_capturable (updated, should be 0 after full capture)\n- amount_received (updated with captured amount)\n- All other PaymentIntent details",
    "outputTransform": "(sourceData) => { return sourceData.capturePaymentIntent; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool captures a Stripe PaymentIntent, allowing you to optionally specify an amount for partial captures. It returns the updated PaymentIntent details, including the status, captured charge information, and the captured amount."
  },
  "stripe_create_checkout_session": {
    "id": "stripe_create_checkout_session",
    "steps": [
      {
        "id": "createCheckoutSession",
        "apiConfig": {
          "id": "createCheckoutSession",
          "body": "<<(sourceData) => { function flatten(obj, prefix = '') { let pairs = []; for (const key in obj) { if (obj[key] === undefined || obj[key] === null) continue; const val = obj[key]; const k = prefix ? `${prefix}[${key}]` : key; if (Array.isArray(val)) { val.forEach((item, i) => { pairs = pairs.concat(flatten(item, `${k}[${i}]`)); }); } else if (typeof val === 'object' && !(val instanceof Date)) { pairs = pairs.concat(flatten(val, k)); } else { pairs.push(`${encodeURIComponent(k)}=${encodeURIComponent(val)}`); } } return pairs; } let params = { mode: sourceData.mode, success_url: sourceData.success_url, cancel_url: sourceData.cancel_url, line_items: sourceData.line_items }; if (sourceData.customer) params.customer = sourceData.customer; if (sourceData.customer_email) params.customer_email = sourceData.customer_email; if (sourceData.metadata) params.metadata = sourceData.metadata; if (typeof sourceData.allow_promotion_codes !== 'undefined') params.allow_promotion_codes = sourceData.allow_promotion_codes; return flatten(params).join('&'); } >>",
          "method": "POST",
          "headers": {
            "Content-Type": "application/x-www-form-urlencoded",
            "Authorization": "Bearer <<stripe_api_key>>",
            "Idempotency-Key": "<<idempotency_key>>"
          },
          "urlHost": "https://api.stripe.com",
          "urlPath": "/v1/checkout/sessions",
          "instruction": "Create a Stripe Checkout Session with required and optional parameters, using proper form-urlencoded flattening for nested objects and arrays. Include Idempotency-Key header if provided. Return the full Checkout Session object."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T05:11:22.535Z",
    "updatedAt": "2025-10-20T05:11:22.535Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "mode": {
              "type": "string",
              "description": "Payment or subscription mode"
            },
            "metadata": {
              "type": "object",
              "properties": {
                "order_id": {
                  "type": "string",
                  "description": "Order ID for tracking"
                }
              }
            },
            "cancel_url": {
              "type": "string",
              "description": "URL for cancellation redirection"
            },
            "line_items": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "quantity": {
                    "type": "integer"
                  },
                  "price_data": {
                    "type": "object",
                    "properties": {
                      "currency": {
                        "type": "string"
                      },
                      "unit_amount": {
                        "type": "integer"
                      },
                      "product_data": {
                        "type": "object",
                        "properties": {
                          "name": {
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                }
              },
              "description": "List of items to purchase"
            },
            "success_url": {
              "type": "string",
              "description": "URL for successful payment redirection"
            },
            "customer_email": {
              "type": "string",
              "description": "Email for the customer"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "stripe_api_key": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Create a Stripe Checkout Session using POST /v1/checkout/sessions endpoint.\n\nRequired Inputs:\n- mode: string (required) - Either \"payment\" or \"subscription\"\n- success_url: string (required) - URL to redirect to after successful payment\n- cancel_url: string (required) - URL to redirect to if user cancels\n- line_items: array (required) - Array of line item objects\n\nOptional Inputs:\n- customer: string (optional) - Existing customer ID\n- customer_email: string (optional) - Email address for new customer\n- metadata: object (optional) - Key-value pairs for metadata\n- allow_promotion_codes: boolean (optional) - Whether to allow promotion codes\n- idempotency_key: string (optional) - Send as Idempotency-Key header if provided\n\nCRITICAL: Use proper form-urlencoded flattening. For nested objects and arrays, use bracket notation:\n- line_items[0][price] for simple values\n- line_items[0][price_data][currency] for nested objects\n- line_items[0][price_data][product_data][name] for deeply nested objects\n- metadata[order_id] for metadata keys\n\nAuthentication: Use Bearer token with the api_key credential in Authorization header.\n\nOutput: Return the complete Checkout Session object including id and url for client redirect.",
    "outputTransform": "(sourceData) => { if (!sourceData.createCheckoutSession) throw new Error('No session returned'); return sourceData.createCheckoutSession; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool creates a seamless Stripe Checkout experience by generating a session for your payment or subscription process. It will return a comprehensive Checkout Session object, including the session ID and a URL for customers to complete their purchase."
  },
  "stripe_create_customer": {
    "id": "stripe_create_customer",
    "steps": [
      {
        "id": "createStripeCustomer",
        "apiConfig": {
          "id": "createStripeCustomer",
          "body": "<<(sourceData) => { const params = []; if(sourceData.email) params.push(`email=${encodeURIComponent(sourceData.email)}`); if(sourceData.name) params.push(`name=${encodeURIComponent(sourceData.name)}`); if(sourceData.phone) params.push(`phone=${encodeURIComponent(sourceData.phone)}`); if(sourceData.description) params.push(`description=${encodeURIComponent(sourceData.description)}`); if(sourceData.payment_method) params.push(`payment_method=${encodeURIComponent(sourceData.payment_method)}`); if(sourceData.address) { if(sourceData.address.line1) params.push(`address[line1]=${encodeURIComponent(sourceData.address.line1)}`); if(sourceData.address.line2) params.push(`address[line2]=${encodeURIComponent(sourceData.address.line2)}`); if(sourceData.address.city) params.push(`address[city]=${encodeURIComponent(sourceData.address.city)}`); if(sourceData.address.state) params.push(`address[state]=${encodeURIComponent(sourceData.address.state)}`); if(sourceData.address.postal_code) params.push(`address[postal_code]=${encodeURIComponent(sourceData.address.postal_code)}`); if(sourceData.address.country) params.push(`address[country]=${encodeURIComponent(sourceData.address.country)}`); } if(sourceData.metadata && typeof sourceData.metadata === 'object') { Object.entries(sourceData.metadata).forEach(([k,v]) => { if(v !== null && v !== undefined) params.push(`metadata[${encodeURIComponent(k)}]=${encodeURIComponent(v)}`); }); } if(sourceData.invoice_settings && typeof sourceData.invoice_settings === 'object') { Object.entries(sourceData.invoice_settings).forEach(([k,v]) => { if(v !== null && v !== undefined) params.push(`invoice_settings[${encodeURIComponent(k)}]=${encodeURIComponent(v)}`); }); } return params.join('&'); } >>",
          "method": "POST",
          "headers": {
            "Content-Type": "application/x-www-form-urlencoded",
            "Authorization": "Bearer <<stripe_api_key>>",
            "Idempotency-Key": "<<idempotency_key>>"
          },
          "urlHost": "https://api.stripe.com",
          "urlPath": "/v1/customers",
          "instruction": "Create a Stripe Customer using only provided fields, flattening nested objects, and using application/x-www-form-urlencoded. If idempotency_key is provided, send as Idempotency-Key header."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T05:23:29.424Z",
    "updatedAt": "2025-10-20T05:23:29.424Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "required": ["stripe_api_key"],
          "properties": {
            "stripe_api_key": {
              "type": "string",
              "description": "Your personal API key"
            },
            "name": {
              "type": "string",
              "description": "Customer's full name"
            },
            "email": {
              "type": "string",
              "description": "Customer's email address"
            },
            "phone": {
              "type": "string",
              "description": "Customer's phone number"
            },
            "address": {
              "type": "object",
              "properties": {
                "city": {
                  "type": "string",
                  "description": "Customer's city"
                },
                "line1": {
                  "type": "string",
                  "description": "Customer's street address"
                },
                "state": {
                  "type": "string",
                  "description": "Customer's state"
                },
                "country": {
                  "type": "string",
                  "description": "Customer's country"
                },
                "postal_code": {
                  "type": "string",
                  "description": "Customer's postal code"
                }
              }
            },
            "metadata": {
              "type": "object",
              "properties": {
                "customer_type": {
                  "type": "string",
                  "description": "Type of customer"
                },
                "referral_source": {
                  "type": "string",
                  "description": "Source of referral"
                }
              }
            }
          }
        }
      }
    },
    "instruction": "Create a Stripe Customer using POST /v1/customers endpoint.\n\nInputs (all optional, but at least one recommended):\n- email: string (optional) - Customer's email address\n- name: string (optional) - Customer's full name\n- phone: string (optional) - Customer's phone number\n- address: object (optional) - Customer's address with fields:\n  * line1: string\n  * line2: string (optional)\n  * city: string\n  * state: string\n  * postal_code: string\n  * country: string\n- metadata: object (optional) - Key-value pairs for custom metadata\n- description: string (optional) - Description of the customer\n- payment_method: string (optional) - Payment method to attach to customer\n- invoice_settings: object (optional) - Invoice settings\n- idempotency_key: string (optional) - Send as Idempotency-Key header if provided\n\nRequest rules:\n1. Make a POST request to /v1/customers\n2. Build the request body dynamically to only include fields that are provided\n3. Do not send null or undefined fields\n4. Use application/x-www-form-urlencoded for the request body\n5. Handle nested objects (address, metadata, invoice_settings) by flattening:\n   - address[line1], address[city], etc.\n   - metadata[key], metadata[another_key], etc.\n6. If idempotency_key is provided, send it as Idempotency-Key header\n\nAuthentication: Use Bearer token with the api_key credential in Authorization header.\n\nOutput: Return the complete Customer object from Stripe including:\n- id (customer ID)\n- email\n- name\n- phone\n- address\n- default_payment_method\n- metadata\n- All other customer details",
    "outputTransform": "(sourceData) => { if (!sourceData.createStripeCustomer) throw new Error('No customer object returned'); return sourceData.createStripeCustomer.data; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool directly connects to Stripe to create a new customer profile using any provided details such as name, email, and address. It will return the complete customer information from Stripe, including customer ID and any additional details you provided."
  },
  "sumup-sales-pull": {
    "id": "sumup-sales-pull",
    "steps": [
      {
        "id": "fetchAllTransactions",
        "apiConfig": {
          "id": "fetchAllTransactions",
          "method": "GET",
          "headers": {
            "Authorization": "Bearer <<sumup_api_key_api_key>>"
          },
          "urlHost": "https://api.sumup.com",
          "urlPath": "/v0.1/me/transactions/history",
          "pagination": {
            "type": "CURSOR_BASED",
            "pageSize": "100",
            "cursorPath": "links.next"
          },
          "instruction": "Fetch all transactions from the merchant account with limit=100 and order=descending, handling pagination using has_more in the response.",
          "queryParams": {
            "limit": "100",
            "order": "descending"
          }
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-19T23:20:27.118Z",
    "updatedAt": "2025-10-19T23:20:27.118Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object"
        },
        "credentials": {
          "type": "object",
          "properties": {
            "sumup_api_key_api_key": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Build a SumUp sales pull workflow that retrieves all transactions from the merchant account with pagination support. Fetch transactions from GET https://api.sumup.com/v0.1/me/transactions with limit=100 and order=descending. Handle pagination by checking if has_more is true in the response. For each transaction, extract transaction_id, timestamp, amount, currency, and payment_type (tender type). Group and aggregate the results by date to show: total sales amount per day, count of transactions per day, and breakdown by tender/payment types (card, cash, etc.) for each day.",
    "outputTransform": "(sourceData) => {\n  // Helper to flatten all transactions from paginated responses\n  let transactions = [];\n  const paged = sourceData.fetchAllTransactions;\n  if (Array.isArray(paged?.results)) {\n    for (const page of paged.results) {\n      if (Array.isArray(page.items)) {\n        transactions = transactions.concat(page.items);\n      }\n    }\n  } else if (Array.isArray(paged?.items)) {\n    transactions = paged.items;\n  }\n\n  // Extract required fields and group by date\n  const grouped = {};\n  let globalTotalAmount = 0;\n  let minDate = null;\n  let maxDate = null;\n\n  for (const tx of transactions) {\n    const date = tx.timestamp ? tx.timestamp.slice(0, 10) : null;\n    if (!date) continue;\n    if (!grouped[date]) {\n      grouped[date] = {\n        date,\n        total_amount: 0,\n        transaction_count: 0,\n        tender_breakdown: {},\n      };\n    }\n    const amount = Number(tx.amount) || 0;\n    grouped[date].total_amount += amount;\n    grouped[date].transaction_count += 1;\n    const paymentType = tx.payment_type || tx.tender_type || \"unknown\";\n    if (!grouped[date].tender_breakdown[paymentType]) {\n      grouped[date].tender_breakdown[paymentType] = { count: 0, amount: 0 };\n    }\n    grouped[date].tender_breakdown[paymentType].count += 1;\n    grouped[date].tender_breakdown[paymentType].amount += amount;\n    globalTotalAmount += amount;\n    if (!minDate || date < minDate) minDate = date;\n    if (!maxDate || date > maxDate) maxDate = date;\n  }\n\n  // Format result as array sorted by date descending\n  const daily_sales = Object.values(grouped).sort((a, b) =>\n    b.date.localeCompare(a.date),\n  );\n\n  return {\n    daily_sales,\n    summary: {\n      total_transactions: transactions.length,\n      total_amount: globalTotalAmount,\n      date_range: {\n        from: minDate || null,\n        to: maxDate || null,\n      },\n    },\n  };\n};\n",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "summary": {
          "type": "object",
          "properties": {
            "date_range": {
              "type": "object",
              "properties": {
                "to": {
                  "type": "string"
                },
                "from": {
                  "type": "string"
                }
              }
            },
            "total_amount": {
              "type": "number"
            },
            "total_transactions": {
              "type": "number"
            }
          }
        },
        "daily_sales": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "date": {
                "type": "string"
              },
              "total_amount": {
                "type": "number"
              },
              "tender_breakdown": {
                "type": "object",
                "additionalProperties": {
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "number"
                    },
                    "amount": {
                      "type": "number"
                    }
                  }
                }
              },
              "transaction_count": {
                "type": "number"
              }
            }
          }
        }
      }
    },
    "description": "This tool retrieves all transactions from your SumUp merchant account and organizes them by date. It provides a summary of daily sales, showing the total amount and number of transactions, along with a breakdown by payment type for each day."
  },
  "sumup-create-refund": {
    "id": "sumup-create-refund",
    "steps": [
      {
        "id": "createRefund",
        "apiConfig": {
          "id": "createRefund",
          "body": "{{payload.amount ? JSON.stringify({amount: payload.amount}) : '{}'}}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<sumup_api_key_api_key>>"
          },
          "urlHost": "https://api.sumup.com",
          "urlPath": "/v0.1/me/refund/{{payload.transaction_id}}",
          "instruction": "Create a refund for a SumUp transaction. Use transaction_id from payload in URL path. If amount is provided in payload, include it in body for partial refund. Otherwise send empty body for full refund."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-19T23:28:53.039Z",
    "updatedAt": "2025-10-19T23:28:53.039Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "required": ["transaction_id"],
          "properties": {
            "amount": {
              "type": "number",
              "description": "Amount to refund (optional - omit for full refund)"
            },
            "transaction_id": {
              "type": "string",
              "description": "ID of the transaction to refund (required)"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "sumup_api_key_api_key": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Build a SumUp create refund workflow. Accept transaction_id (required, string) and amount (optional, number) in the payload. Make a POST request to https://api.sumup.com/v0.1/me/refund/{transaction_id} where {transaction_id} is dynamically inserted from payload.transaction_id into the URL path. For the request body: if payload.amount exists, send JSON body with {\"amount\": payload.amount} for partial refund. If payload.amount is not provided or null, send empty body {} for full refund. Use Authorization header with Bearer token. The response will contain refund details. Transform the response to return: refund_id (from response.id), transaction_id (echo from payload), status (from response.status or 'PENDING'), amount (from response.amount), currency (from response.currency), refund_type (if payload.amount was provided return 'partial', else 'full'), created_at (from response.timestamp or response.date), message ('Refund processed successfully'). Handle errors gracefully and return clear error messages if transaction not found.",
    "outputTransform": "(sourceData) => {\n  const response = sourceData.createRefund || {};\n  const payload = sourceData.payload || {};\n  \n  return {\n    refund_id: response.id || response.refund_id || null,\n    transaction_id: payload.transaction_id || response.transaction_id || null,\n    status: response.status || 'PENDING',\n    amount: response.amount || payload.amount || null,\n    currency: response.currency || null,\n    refund_type: payload.amount ? 'partial' : 'full',\n    created_at: response.timestamp || response.date || response.created_at || new Date().toISOString(),\n    message: 'Refund processed successfully'\n  };\n}",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "amount": {
          "type": "number",
          "description": "Amount refunded"
        },
        "status": {
          "type": "string",
          "description": "Refund status (PENDING, SUCCESSFUL, FAILED)"
        },
        "message": {
          "type": "string",
          "description": "Success or error message"
        },
        "currency": {
          "type": "string",
          "description": "Currency code (e.g., EUR, USD)"
        },
        "refund_id": {
          "type": "string",
          "description": "Unique ID of the refund"
        },
        "created_at": {
          "type": "string",
          "description": "Timestamp when refund was created"
        },
        "refund_type": {
          "type": "string",
          "description": "Type of refund: full or partial"
        },
        "transaction_id": {
          "type": "string",
          "description": "Original transaction ID that was refunded"
        }
      }
    },
    "description": "This tool processes refunds for transactions through SumUp, allowing you to issue either a full or partial refund based on your input. It provides comprehensive details of the refund, including the refund ID, amount, status, and type, ensuring a smooth and clear refund process."
  },
  "sumup-get-transaction": {
    "id": "sumup-get-transaction",
    "steps": [
      {
        "id": "getTransactionDetails",
        "apiConfig": {
          "id": "getTransactionDetails",
          "method": "GET",
          "headers": {
            "Authorization": "Bearer <<sumup_api_key_api_key>>"
          },
          "urlHost": "https://api.sumup.com",
          "urlPath": "/v0.1/me/transactions/{{payload.transaction_id}}",
          "instruction": "Retrieve detailed information about a specific SumUp transaction by transaction ID. Returns full transaction details including amount, status, timestamp, payment type, card details, and line items."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-19T23:30:03.407Z",
    "updatedAt": "2025-10-19T23:30:03.407Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "required": ["transaction_id"],
          "properties": {
            "transaction_id": {
              "type": "string",
              "description": "ID of the transaction to retrieve"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "sumup_api_key_api_key": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Build a SumUp get transaction workflow that retrieves detailed information about a specific transaction. Accept transaction_id (required, string) in the payload. Make a GET request to https://api.sumup.com/v0.1/me/transactions/{transaction_id} where {transaction_id} is dynamically inserted from payload.transaction_id into the URL path. Use Authorization header with Bearer token. The response will contain full transaction details. Return the complete transaction information including: transaction_id (id), amount, currency, status, timestamp (date/created_at), payment_type (card, cash, etc.), card details if available, merchant info, customer info if present, product line items if available, tax information, and any other relevant transaction metadata. This is useful for reconciliation, reporting, refund verification, and analytics workflows.",
    "outputTransform": "(sourceData) => {\n  const txn = sourceData.getTransactionDetails || {};\n  \n  return {\n    transaction_id: txn.id || txn.transaction_id || null,\n    amount: txn.amount || null,\n    currency: txn.currency || null,\n    status: txn.status || null,\n    timestamp: txn.timestamp || txn.date || txn.created_at || null,\n    payment_type: txn.payment_type || txn.type || txn.tender_type || null,\n    card: txn.card ? {\n      type: txn.card.type || txn.card.card_type || null,\n      last_4_digits: txn.card.last_4_digits || txn.card.last4 || null\n    } : null,\n    merchant_code: txn.merchant_code || txn.merchant_id || null,\n    description: txn.description || txn.entry_mode || null,\n    products: txn.products || txn.items || txn.line_items || [],\n    tax: txn.tax || txn.tax_amount || null,\n    metadata: {\n      entry_mode: txn.entry_mode || null,\n      verification_method: txn.verification_method || null,\n      installments_count: txn.installments_count || null,\n      location: txn.location || null,\n      horizontal_accuracy: txn.horizontal_accuracy || null,\n      simple_payment_type: txn.simple_payment_type || null,\n      simple_status: txn.simple_status || null\n    }\n  };\n}",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "tax": {
          "type": "object",
          "description": "Tax information"
        },
        "card": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string"
            },
            "last_4_digits": {
              "type": "string"
            }
          },
          "description": "Card details if payment was by card"
        },
        "amount": {
          "type": "number",
          "description": "Transaction amount"
        },
        "status": {
          "type": "string",
          "description": "Transaction status (SUCCESSFUL, PENDING, FAILED, CANCELLED)"
        },
        "currency": {
          "type": "string",
          "description": "Currency code (EUR, USD, etc.)"
        },
        "metadata": {
          "type": "object",
          "description": "Additional transaction metadata"
        },
        "products": {
          "type": "array",
          "items": {
            "type": "object"
          },
          "description": "Line items/products in the transaction"
        },
        "timestamp": {
          "type": "string",
          "description": "Transaction date and time"
        },
        "description": {
          "type": "string",
          "description": "Transaction description"
        },
        "payment_type": {
          "type": "string",
          "description": "Payment method (card, cash, etc.)"
        },
        "merchant_code": {
          "type": "string",
          "description": "Merchant identifier"
        },
        "transaction_id": {
          "type": "string",
          "description": "Unique transaction ID"
        }
      }
    },
    "description": "This tool retrieves comprehensive information about a specific transaction directly from SumUp using the transaction ID you provide. It will return detailed transaction data including the amount, currency, status, payment type, card details, merchant info, and more, which is ideal for tasks like reconciliation and reporting."
  },
  "sumup-list-transactions": {
    "id": "sumup-list-transactions",
    "steps": [
      {
        "id": "fetchAllTransactions",
        "apiConfig": {
          "id": "fetchAllTransactions",
          "method": "GET",
          "headers": {
            "Authorization": "Bearer <<sumup_api_key_api_key>>"
          },
          "urlHost": "https://api.sumup.com",
          "urlPath": "/v0.1/me/transactions/history",
          "pagination": {
            "type": "CURSOR_BASED",
            "pageSize": "100",
            "cursorPath": "next_cursor"
          },
          "instruction": "Fetch all transactions for the given date range (if provided) from SumUp, handling pagination using has_more or next_cursor. Use order=descending, limit=100, and from/to if start_date/end_date are provided.",
          "queryParams": {
            "limit": "100",
            "order": "descending"
          }
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-19T23:32:59.168Z",
    "updatedAt": "2025-10-19T23:32:59.168Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "end_date": {
              "type": "string",
              "description": "End date for transaction range (ISO format, optional)"
            },
            "start_date": {
              "type": "string",
              "description": "Start date for transaction range (ISO format, optional)"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "sumup_api_key_api_key": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Build a SumUp list transactions workflow that retrieves transactions for a given date range. Accept start_date (optional, ISO date string) and end_date (optional, ISO date string) in the payload. Make a GET request to https://api.sumup.com/v0.1/me/transactions with query parameters: order=descending, limit=100, and if provided: from=start_date and to=end_date. Handle pagination automatically - check for has_more or next_cursor in response and fetch all pages. Use Authorization header with Bearer token. Return a list of transactions with: transaction_id (id), timestamp (date/created_at), amount, currency, status, and payment_type. This is ideal for building dashboards, reports, and analytics. If no date range is provided, fetch recent transactions.",
    "outputTransform": "(sourceData) => {\n  // Helper to flatten all transactions from paginated responses\n  let allTransactions = [];\n  const paged = sourceData.fetchAllTransactions;\n\n  if (Array.isArray(paged)) {\n    for (const page of paged) {\n      if (Array.isArray(page?.data?.transactions)) {\n        allTransactions = allTransactions.concat(page.data.transactions);\n      } else if (Array.isArray(page?.items)) {\n        allTransactions = allTransactions.concat(page.items);\n      }\n    }\n  } else if (Array.isArray(paged?.data?.transactions)) {\n    allTransactions = paged.data.transactions;\n  } else if (Array.isArray(paged?.results)) {\n    for (const page of paged.results) {\n      if (Array.isArray(page?.items)) {\n        allTransactions = allTransactions.concat(page.items);\n      }\n    }\n  }\n\n  // Map to required fields\n  const transactions = allTransactions.map((tx) => ({\n    transaction_id: tx.id,\n    timestamp: tx.date || tx.created_at,\n    amount: tx.amount,\n    currency: tx.currency,\n    status: tx.status,\n    payment_type: tx.payment_type,\n  }));\n\n  // Calculate summary\n  const total_count = transactions.length;\n  const total_amount = transactions.reduce(\n    (sum, tx) => sum + (typeof tx.amount === 'number' ? tx.amount : 0),\n    0,\n  );\n\n  // Extract date range from payload if present\n  const from = sourceData.payload?.start_date || null;\n  const to = sourceData.payload?.end_date || null;\n\n  return {\n    transactions,\n    summary: {\n      total_count,\n      date_range: { from, to },\n      total_amount,\n    },\n  };\n}",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "summary": {
          "type": "object",
          "properties": {
            "date_range": {
              "type": "object",
              "properties": {
                "to": {
                  "type": "string"
                },
                "from": {
                  "type": "string"
                }
              },
              "description": "Date range filter applied"
            },
            "total_count": {
              "type": "number",
              "description": "Total number of transactions"
            },
            "total_amount": {
              "type": "number",
              "description": "Sum of all transaction amounts"
            }
          }
        },
        "transactions": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "amount": {
                "type": "number",
                "description": "Transaction amount"
              },
              "status": {
                "type": "string",
                "description": "Transaction status"
              },
              "currency": {
                "type": "string",
                "description": "Currency code"
              },
              "timestamp": {
                "type": "string",
                "description": "Transaction date and time"
              },
              "payment_type": {
                "type": "string",
                "description": "Payment method"
              },
              "transaction_id": {
                "type": "string",
                "description": "Unique transaction ID"
              }
            }
          }
        }
      }
    },
    "description": "This tool retrieves a list of all your SumUp transactions within a specified date range or the most recent ones if no dates are provided. It provides detailed information about each transaction, including the transaction ID, date, amount, currency, status, and payment method, along with a summary of the total transaction count and amount."
  },
  "square-list-payments": {
    "id": "square-list-payments",
    "steps": [
      {
        "id": "listAllPayments",
        "apiConfig": {
          "id": "listAllPayments",
          "method": "GET",
          "headers": {
            "Authorization": "Bearer <<square-1_access_token>>",
            "Square-Version": "2025-09-24"
          },
          "urlHost": "https://connect.squareup.com",
          "urlPath": "/v2/payments",
          "pagination": {
            "type": "CURSOR_BASED",
            "pageSize": "100",
            "cursorPath": "cursor"
          },
          "instruction": "List all payments for a given time window, optionally filtered by location_id, with pagination handled via cursor.",
          "queryParams": {
            "limit": "100",
            "cursor": "<<cursor>>",
            "end_time": "<<end_time>>",
            "begin_time": "<<begin_time>>",
            "location_id": "<<location_id>>"
          },
          "authentication": "OAUTH2"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-19T23:50:01.844Z",
    "updatedAt": "2025-10-19T23:50:01.844Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "end_time": {
              "type": "string",
              "description": "End time for the payment search"
            },
            "begin_time": {
              "type": "string",
              "description": "Start time for the payment search"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "square-1_access_token": {
              "type": "string",
              "description": "Personal API access token"
            }
          }
        }
      }
    },
    "instruction": "Build a Square tool that lists all payments for a given time window, optionally filtered by location_id.\n\n1. Call the Square Payments API endpoint: GET https://api.squareup.com/v2/payments\n2. Use Bearer token authentication with the access_token from the integration credentials in the Authorization header\n3. Include query parameters:\n   - begin_time: ISO-8601 formatted start time (required, from payload)\n   - end_time: ISO-8601 formatted end time (required, from payload)\n   - location_id: optional location filter (from payload if provided)\n   - limit: 100 (default pagination limit)\n   - cursor: for pagination (handled automatically)\n4. Handle pagination by following the cursor until all payments are retrieved\n5. Extract the payments array from each response\n6. Return all payments with their id, amount_money, created_at, status, location_id, and order_id fields",
    "outputTransform": "(sourceData) => {\n  // Square returns an array of responses (pages), each with a 'payments' array\n  // Flatten all payments and map to required fields, wrap in { payments: [...] }\n  let allPayments = [];\n  if (Array.isArray(sourceData.listAllPayments)) {\n    allPayments = sourceData.listAllPayments.flatMap(\n      (page) => page.payments || [],\n    );\n  } else if (Array.isArray(sourceData.listAllPayments?.results)) {\n    // Some integrations may use 'results' as the array of pages\n    allPayments = sourceData.listAllPayments.results.flatMap(\n      (page) => page.payments || [],\n    );\n  } else if (sourceData.listAllPayments?.payments) {\n    allPayments = sourceData.listAllPayments.payments || [];\n  } else {\n    allPayments = [];\n  }\n  return {\n    payments: allPayments.map((p) => ({\n      id: p.id,\n      amount_money: p.amount_money,\n      created_at: p.created_at,\n      status: p.status,\n      location_id: p.location_id,\n      order_id: p.order_id,\n    })),\n  };\n};\n",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "payments": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string"
              },
              "status": {
                "type": "string"
              },
              "order_id": {
                "type": "string"
              },
              "created_at": {
                "type": "string"
              },
              "location_id": {
                "type": "string"
              },
              "amount_money": {
                "type": "object"
              }
            }
          }
        }
      }
    },
    "description": "This tool gathers a list of all payments made within a specified time frame from Square, optionally filtered by location. It will provide detailed information for each payment, including its ID, amount, creation time, status, and associated order and location IDs."
  },
  "square-refund-payment": {
    "id": "square-refund-payment",
    "steps": [
      {
        "id": "createRefund",
        "apiConfig": {
          "id": "createRefund",
          "body": "{\"payment_id\": \"<<payment_id>>\", \"amount_money\": {\"amount\": <<amount>>, \"currency\": \"<<currency>>\"}, \"idempotency_key\": \"<<$uuid>>\", \"reason\": \"<<reason>>\"}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<square-1_access_token>>",
            "Square-Version": "2025-09-24"
          },
          "urlHost": "https://connect.squareup.com",
          "urlPath": "/v2/refunds",
          "instruction": "Create a refund for a completed Square payment. Requires payment_id, amount_money (amount and currency), idempotency_key (UUID), and optional reason.",
          "authentication": "OAUTH2"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-19T23:58:54.266Z",
    "updatedAt": "2025-10-19T23:58:54.266Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "required": ["payment_id", "amount", "currency"],
          "properties": {
            "square-1_access_token": {
              "type": "string",
              "description": "Your API key"
            },
            "amount": {
              "type": "integer",
              "description": "Amount to be refunded in smallest currency unit"
            },
            "reason": {
              "type": "string",
              "description": "Optional reason for the refund"
            },
            "currency": {
              "type": "string",
              "description": "Currency code for the refund"
            },
            "payment_id": {
              "type": "string",
              "description": "ID of the payment to be refunded"
            }
          }
        }
      }
    },
    "instruction": "Build a Square tool that creates a refund for a completed payment. Requires payment_id, amount (in smallest currency unit), currency code, and optional reason. Returns refund object with id, status, location_id, amount_money, payment_id, created_at, updated_at, and reason.",
    "outputTransform": "(sourceData) => { return sourceData.createRefund || {}; }",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "refund": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string"
            },
            "reason": {
              "type": "string"
            },
            "status": {
              "type": "string"
            },
            "created_at": {
              "type": "string"
            },
            "payment_id": {
              "type": "string"
            },
            "updated_at": {
              "type": "string"
            },
            "location_id": {
              "type": "string"
            },
            "amount_money": {
              "type": "object"
            }
          }
        }
      }
    },
    "description": "This tool processes a refund for a completed Square payment directly through their system. It will provide detailed information about the refund, including its ID, status, amount, and associated payment details."
  },
  "slack_get_user_info": {
    "id": "slack_get_user_info",
    "steps": [
      {
        "id": "getSlackUserInfo",
        "apiConfig": {
          "id": "getSlackUserInfo",
          "method": "GET",
          "headers": {
            "Authorization": "Bearer <<slack_api_key_api_token>>"
          },
          "urlHost": "https://slack.com/api",
          "urlPath": "/users.info",
          "instruction": "Get Slack user information for the specified user ID using /users.info.",
          "queryParams": {
            "user": "<<user>>"
          }
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T05:09:12.637Z",
    "updatedAt": "2025-10-22T00:14:58.883Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "The user ID for which you want to retrieve information"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "slack_api_key_api_token": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Get Slack user information. Make a GET request to /users.info with Authorization header: Bearer <<slack_api_key_api_token>>. Include query parameter: user (required, the user ID).",
    "outputTransform": "(sourceData) => { return sourceData.getSlackUserInfo; }",
    "systemIds": [],
    "description": "This tool retrieves detailed information about a specific Slack user directly from Slack by using their user ID. It will return the user's profile details, including their name and contact information, as provided in Slack."
  },
  "airtable_list_records": {
    "id": "airtable_list_records",
    "steps": [
      {
        "id": "listAirtableRecords",
        "apiConfig": {
          "id": "listAirtableRecords",
          "method": "GET",
          "headers": {
            "Authorization": "Bearer <<airtable_access_token>>"
          },
          "urlHost": "https://api.airtable.com",
          "urlPath": "/v0/<<base_id>>/<<table_name>>",
          "pagination": {
            "type": "CURSOR_BASED",
            "pageSize": "100",
            "cursorPath": "offset"
          },
          "instruction": "List records from an Airtable table with optional filtering and pagination support",
          "queryParams": {},
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T05:42:39.519Z",
    "updatedAt": "2025-10-20T05:42:39.519Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "required": ["base_id", "table_name", "airtable_access_token"],
          "properties": {
            "airtable_access_token": {
              "type": "string",
              "description": "Airtable API key"
            },
            "base_id": {
              "type": "string",
              "description": "The Airtable base ID"
            },
            "table_name": {
              "type": "string",
              "description": "The name or ID of the table"
            }
          }
        }
      }
    },
    "instruction": "List records from an Airtable table with pagination and optional filters.\n\nAPI Configuration:\n- Method: GET\n- Base URL: https://api.airtable.com\n- Path: /v0/{base_id}/{table_name}\n- Authentication: Bearer token in Authorization header using the access_token credential\n\nInput parameters:\n- base_id (required): The Airtable base ID\n- table_name (required): The name or ID of the table\n- view (optional): The name or ID of a view in the table\n- filterByFormula (optional): An Airtable formula to filter records\n- pageSize (optional): Number of records per page (default 100, max 100)\n- offset (optional): Pagination offset token\n\nQuery parameters: Only include parameters that are provided (not null/empty)\n- view, filterByFormula, pageSize, offset\n\nPagination handling:\n- The API returns an \"offset\" field when there are more records\n- Keep fetching pages with the returned offset until no offset is returned\n- Aggregate all records from all pages into a single array\n\nOutput format:\n{\n  \"records\": [\n    {\n      \"id\": \"rec...\",\n      \"fields\": { ... },\n      \"createdTime\": \"...\"\n    }\n  ]\n}",
    "outputTransform": "(sourceData) => { return sourceData.listAirtableRecords.data; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool retrieves data from a specified table in your Airtable database, allowing for optional filtering and pagination. It will return a complete list of records from the table, including each record's ID, fields, and creation time."
  },
  "square-search-orders": {
    "id": "square-search-orders",
    "steps": [
      {
        "id": "searchOrdersWithPagination",
        "apiConfig": {
          "id": "searchOrdersWithPagination",
          "body": "{\"location_ids\": <<location_ids>>, \"query\": {\"filter\": {\"date_time_filter\": {\"created_at\": {\"start_at\": \"<<start_time>>\", \"end_at\": \"<<end_time>>\"}}, \"state_filter\": {\"states\": <<state_filter>>}}}, \"limit\": 100, \"cursor\": \"<<cursor>>\"}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<square-1_access_token>>",
            "Square-Version": "2025-09-24"
          },
          "urlHost": "https://connect.squareup.com",
          "urlPath": "/v2/orders/search",
          "pagination": {
            "type": "CURSOR_BASED",
            "pageSize": "100",
            "cursorPath": "cursor"
          },
          "instruction": "Search Square orders for one or more location_ids within a time range with optional state filter and cursor-based pagination.",
          "authentication": "OAUTH2"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T00:00:27.931Z",
    "updatedAt": "2025-10-20T00:00:27.931Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "required": ["location_ids"],
          "properties": {
            "square-1_access_token": {
              "type": "string",
              "description": "Your API key"
            },
            "end_time": {
              "type": "string",
              "description": "End time for the order search"
            },
            "start_time": {
              "type": "string",
              "description": "Start time for the order search"
            },
            "location_ids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of location IDs to search orders from"
            },
            "state_filter": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Filter orders by their state"
            }
          }
        }
      }
    },
    "instruction": "Build a Square tool that searches orders for one or more location_ids within a time range. Supports optional date filtering (start_time/end_time) and state filtering. Uses cursor-based pagination to retrieve all orders. Requires ORDERS_READ scope. Returns orders with id, location_id, line_items, total_money, state, and created_at.",
    "outputTransform": "(sourceData) => {\n  // Square returns an array of responses (pages), each with an 'orders' array\n  // Flatten all orders and map to required fields\n  let allOrders = [];\n  if (Array.isArray(sourceData.searchOrdersWithPagination)) {\n    allOrders = sourceData.searchOrdersWithPagination.flatMap(\n      (page) => page.orders || [],\n    );\n  } else if (sourceData.searchOrdersWithPagination?.orders) {\n    allOrders = sourceData.searchOrdersWithPagination.orders || [];\n  } else {\n    allOrders = [];\n  }\n  return {\n    orders: allOrders.map((order) => ({\n      id: order.id,\n      location_id: order.location_id,\n      line_items: order.line_items,\n      total_money: order.total_money,\n      state: order.state,\n      created_at: order.created_at,\n    })),\n  };\n}",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "orders": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string"
              },
              "state": {
                "type": "string"
              },
              "created_at": {
                "type": "string"
              },
              "line_items": {
                "type": "array"
              },
              "location_id": {
                "type": "string"
              },
              "total_money": {
                "type": "object"
              }
            }
          }
        }
      }
    },
    "description": "This tool connects to Square to search for orders across specified locations within a given time frame, with options to filter by order state. It will return detailed information about each order, including the order ID, location, line items, total money, state, and creation date."
  },
  "square-list-catalog-items": {
    "id": "square-list-catalog-items",
    "steps": [
      {
        "id": "searchCatalogItems",
        "apiConfig": {
          "id": "searchCatalogItems",
          "body": "{\"product_types\": [\"REGULAR\"], \"enabled_location_ids\": <<enabled_location_ids>>, \"text_filter\": \"<<text_filter>>\", \"limit\": 100, \"cursor\": \"<<cursor>>\"}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<square-1_access_token>>",
            "Square-Version": "2025-09-24"
          },
          "urlHost": "https://connect.squareup.com",
          "urlPath": "/v2/catalog/search-catalog-items",
          "pagination": {
            "type": "CURSOR_BASED",
            "pageSize": "100",
            "cursorPath": "cursor"
          },
          "instruction": "Search Square catalog for sellable items and variations with prices. Supports optional filtering by location and text search. Uses cursor-based pagination.",
          "authentication": "OAUTH2"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T00:04:06.474Z",
    "updatedAt": "2025-10-20T00:04:06.474Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "square-1_access_token": {
              "type": "string",
              "description": "Your API key"
            },
            "text_filter": {
              "type": "string",
              "description": "Search term to filter catalog items"
            },
            "enabled_location_ids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of location IDs to filter items by"
            }
          }
        }
      }
    },
    "instruction": "Build a Square tool that lists sellable catalog items and their variations with prices. Supports optional filtering by enabled_location_ids and text_filter. Uses cursor-based pagination. Requires ITEMS_READ scope. Returns items with id, name, description, and variations (with id, name, price_money, sku).",
    "outputTransform": "(sourceData) => {\n  // Square returns an array of responses (pages), each with an 'items' array\n  // Flatten all items and extract relevant catalog data\n  let allItems = [];\n  if (Array.isArray(sourceData.searchCatalogItems)) {\n    allItems = sourceData.searchCatalogItems.flatMap(\n      (page) => page.items || [],\n    );\n  } else if (sourceData.searchCatalogItems?.items) {\n    allItems = sourceData.searchCatalogItems.items || [];\n  } else {\n    allItems = [];\n  }\n  return {\n    items: allItems.map((item) => ({\n      id: item.id,\n      name: item.item_data?.name,\n      description: item.item_data?.description,\n      variations: (item.item_data?.variations || []).map((v) => ({\n        id: v.id,\n        name: v.item_variation_data?.name,\n        price_money: v.item_variation_data?.price_money,\n        sku: v.item_variation_data?.sku,\n      })),\n    })),\n  };\n}",
    "systemIds": [],
    "description": "This tool connects to Square to retrieve a list of sellable catalog items and their variations, including prices. It returns detailed information such as item IDs, names, descriptions, and variation specifics like price and SKU, allowing for optional filtering by location and text search."
  },
  "square-adjust-inventory": {
    "id": "square-adjust-inventory",
    "steps": [
      {
        "id": "batchInventoryAdjustments",
        "apiConfig": {
          "id": "batchInventoryAdjustments",
          "body": "{\"idempotency_key\": \"<<$uuid>>\", \"changes\": <<adjustments_transformed>>}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<square-1_access_token>>",
            "Square-Version": "2025-09-24"
          },
          "urlHost": "https://api.squareup.com",
          "urlPath": "/v2/inventory/changes/batch",
          "instruction": "Apply inventory adjustments for specified catalog object IDs at a location using Square's batch change inventory endpoint.",
          "authentication": "OAUTH2"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T00:10:27.301Z",
    "updatedAt": "2025-10-20T00:10:27.301Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "required": ["location_id", "adjustments", "square-1_access_token"],
          "properties": {
            "square-1_access_token": {
              "type": "string",
              "description": "Your API key"
            },
            "adjustments": {
              "type": "array",
              "items": {
                "type": "object",
                "required": ["catalog_object_id", "quantity"],
                "properties": {
                  "quantity": {
                    "type": "string"
                  },
                  "to_state": {
                    "type": "string"
                  },
                  "from_state": {
                    "type": "string"
                  },
                  "catalog_object_id": {
                    "type": "string"
                  }
                }
              },
              "description": "List of inventory changes to apply"
            },
            "location_id": {
              "type": "string",
              "description": "The unique identifier for the location"
            },
            "occurred_at": {
              "type": "string",
              "description": "The date and time when the adjustment occurred"
            }
          }
        }
      }
    },
    "instruction": "Build a Square tool that applies inventory adjustments for specified catalog object IDs at a location. Accepts location_id and array of adjustments with catalog_object_id, quantity, from_state, to_state. Generates idempotency_key automatically. Requires INVENTORY_WRITE scope. Returns counts array with current calculated inventory counts after changes.",
    "outputTransform": "(sourceData) => { return { counts: sourceData.batchInventoryAdjustments?.counts || [] }; }",
    "systemIds": [],
    "description": "This tool interacts with Square to adjust inventory levels for specific items at a given location. It will return an updated list of inventory counts, reflecting the changes made."
  },
  "square-create-customer": {
    "id": "square-create-customer",
    "steps": [
      {
        "id": "createCustomerProfile",
        "apiConfig": {
          "id": "createCustomerProfile",
          "body": "<<(sourceData) => { const b = { idempotency_key: (typeof crypto !== 'undefined' && crypto.randomUUID ? crypto.randomUUID() : (Math.random().toString(36).substring(2) + Date.now().toString(36))) }; if (sourceData.given_name) b.given_name = sourceData.given_name; if (sourceData.family_name) b.family_name = sourceData.family_name; if (sourceData.company_name) b.company_name = sourceData.company_name; if (sourceData.email_address) b.email_address = sourceData.email_address; if (sourceData.phone_number && /^\\+\\d{1,15}$/.test(sourceData.phone_number)) b.phone_number = sourceData.phone_number; if (sourceData.address) b.address = sourceData.address; if (sourceData.note) b.note = sourceData.note; if (sourceData.reference_id) b.reference_id = sourceData.reference_id; return JSON.stringify(b); }>>",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<square-1_access_token>>",
            "Square-Version": "2025-09-24"
          },
          "urlHost": "https://connect.squareup.com",
          "urlPath": "/v2/customers",
          "instruction": "Create a new customer profile in Square using the Customers API. Include idempotency_key (UUID), and all provided optional fields from the payload. Use Bearer token authentication and set Square-Version header.",
          "authentication": "OAUTH2"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T00:12:34.325Z",
    "updatedAt": "2025-10-20T00:12:34.325Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "square-1_access_token": {
              "type": "string",
              "description": "Your API key"
            },
            "note": {
              "type": "string",
              "description": "A personal note about the customer"
            },
            "address": {
              "type": "object",
              "description": "The customer's address details"
            },
            "given_name": {
              "type": "string",
              "description": "The customer's first name"
            },
            "family_name": {
              "type": "string",
              "description": "The customer's last name"
            },
            "company_name": {
              "type": "string",
              "description": "The name of the customer's company"
            },
            "phone_number": {
              "type": "string",
              "description": "The customer's phone number"
            },
            "reference_id": {
              "type": "string",
              "description": "A unique reference ID for the customer"
            },
            "email_address": {
              "type": "string",
              "description": "The customer's email address"
            }
          }
        }
      }
    },
    "instruction": "Build a Square tool that creates a customer profile. Accepts optional fields: given_name, family_name, company_name, email_address, phone_number, address, note, reference_id. At least one of given_name, family_name, company_name, email_address, or phone_number must be provided. Auto-generates idempotency_key. Requires CUSTOMERS_WRITE scope. Returns customer object with id, created_at, updated_at, and provided fields.",
    "outputTransform": "(sourceData) => {\n  const customer = sourceData.createCustomerProfile?.customer;\n  if (!customer) throw new Error(\"No customer object returned from Square\");\n  // Only include fields required by the target schema and provided in the payload\n  const schemaFields = [\n    \"id\",\n    \"created_at\",\n    \"updated_at\",\n    \"given_name\",\n    \"family_name\",\n    \"email_address\",\n    \"phone_number\",\n    \"company_name\",\n  ];\n  const result = {};\n  for (const field of schemaFields) {\n    if (\n      typeof customer[field] !== \"undefined\" &&\n      typeof sourceData[field] !== \"undefined\"\n    ) {\n      result[field] = customer[field];\n    }\n  }\n  // Always include id, created_at, updated_at\n  result.id = customer.id;\n  result.created_at = customer.created_at;\n  result.updated_at = customer.updated_at;\n  return { customer: result };\n};\n",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "customer": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string"
            },
            "created_at": {
              "type": "string"
            },
            "given_name": {
              "type": "string"
            },
            "updated_at": {
              "type": "string"
            },
            "family_name": {
              "type": "string"
            },
            "company_name": {
              "type": "string"
            },
            "phone_number": {
              "type": "string"
            },
            "email_address": {
              "type": "string"
            }
          }
        }
      }
    },
    "description": "This tool creates a new customer profile in Square by using the information you provide, such as name, email, or phone number. It returns a detailed customer object that includes an ID and timestamps of when the profile was created and last updated."
  },
  "netsuite_search_customers": {
    "id": "netsuite_search_customers",
    "steps": [
      {
        "id": "searchCustomers",
        "apiConfig": {
          "id": "searchCustomersEndpoint",
          "method": "GET",
          "headers": {
            "Content-Type": "application/json"
          },
          "urlHost": "https://<<subdomain>>.suitetalk.api.netsuite.com",
          "urlPath": "/services/rest/record/v1/customer",
          "instruction": "Search for customers in NetSuite. Accepts query parameters like q for search filters, limit for pagination, offset for pagination.",
          "queryParams": {},
          "authentication": "OAUTH2"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T00:45:14.283Z",
    "updatedAt": "2025-10-22T04:06:02.690Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "subdomain": {
              "type": "string",
              "description": "Subdomain of your NetSuite instance"
            },
            "q": {
              "type": "string",
              "description": "SuiteQL query string for filtering customers"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of results to return"
            },
            "offset": {
              "type": "number",
              "description": "Number of records to skip for pagination"
            }
          }
        }
      }
    },
    "instruction": "Search for customers in NetSuite using the REST API with TBA authentication",
    "outputTransform": "$",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool connects to NetSuite to search for customer information based on specified criteria. It will return a list of customers, including details such as their ID, email, phone number, and company name, along with the total number of results found."
  },
  "netsuite_sync_sales_orders": {
    "id": "netsuite_sync_sales_orders",
    "steps": [
      {
        "id": "getSalesOrders",
        "apiConfig": {
          "id": "getSalesOrdersEndpoint",
          "method": "GET",
          "headers": {
            "Content-Type": "application/json"
          },
          "urlHost": "https://1234567.suitetalk.api.netsuite.com",
          "urlPath": "/services/rest/record/v1/salesorder",
          "instruction": "Get sales orders from NetSuite. Accepts query parameters for filtering by date, status, customer, etc.",
          "queryParams": {},
          "authentication": "OAUTH2"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T00:51:30.247Z",
    "updatedAt": "2025-10-22T04:22:51.080Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "limit": {
          "type": "number",
          "description": "Maximum number of results to return"
        },
        "offset": {
          "type": "number",
          "description": "Number of records to skip for pagination"
        },
        "status": {
          "type": "string",
          "description": "Sales order status filter"
        },
        "date_to": {
          "type": "string",
          "description": "End date for filtering sales orders (ISO format)"
        },
        "date_from": {
          "type": "string",
          "description": "Start date for filtering sales orders (ISO format)"
        },
        "customer_id": {
          "type": "string",
          "description": "Filter by customer ID"
        }
      }
    },
    "instruction": "Sync sales orders from NetSuite using the REST API with TBA authentication",
    "outputTransform": "$",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "totalCount": {
          "type": "number"
        },
        "salesOrders": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string"
              },
              "total": {
                "type": "number"
              },
              "status": {
                "type": "string"
              },
              "tranId": {
                "type": "string"
              },
              "tranDate": {
                "type": "string"
              },
              "lineItems": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "rate": {
                      "type": "number"
                    },
                    "amount": {
                      "type": "number"
                    },
                    "itemId": {
                      "type": "string"
                    },
                    "itemName": {
                      "type": "string"
                    },
                    "quantity": {
                      "type": "number"
                    },
                    "lineNumber": {
                      "type": "number"
                    }
                  }
                }
              },
              "customerId": {
                "type": "string"
              },
              "customerName": {
                "type": "string"
              }
            }
          }
        }
      }
    },
    "description": "This tool retrieves sales orders from NetSuite, allowing you to filter by various criteria such as date, status, and customer. It returns detailed information about each order, including the total amount, status, transaction ID, and associated customer details."
  },
  "netsuite_update_inventory_levels": {
    "id": "netsuite_update_inventory_levels",
    "steps": [
      {
        "id": "createInventoryAdjustment",
        "apiConfig": {
          "id": "createInventoryAdjustmentEndpoint",
          "body": "{\"item\": {\"id\": \"{{item_id}}\"}, \"location\": {\"id\": \"{{location_id}}\"}, \"quantity\": {{quantity}}, \"adjustmentType\": \"{{adjustment_type}}\"}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json"
          },
          "urlHost": "https://1234567.suitetalk.api.netsuite.com",
          "urlPath": "/services/rest/record/v1/inventoryadjustment",
          "instruction": "Create inventory adjustment record in NetSuite to update inventory levels. Requires item_id, location_id, quantity, and adjustment details.",
          "authentication": "OAUTH2"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T00:55:09.912Z",
    "updatedAt": "2025-10-22T04:23:00.734Z",
    "inputSchema": {
      "type": "object",
      "required": ["item_id", "location_id", "quantity"],
      "properties": {
        "item_id": {
          "type": "string",
          "description": "NetSuite item ID to adjust"
        },
        "quantity": {
          "type": "number",
          "description": "New quantity or adjustment amount"
        },
        "location_id": {
          "type": "string",
          "description": "NetSuite location ID"
        },
        "adjustment_type": {
          "type": "string",
          "description": "Type of adjustment (e.g., PHYSICAL_COUNT, ADJUSTMENT)"
        }
      }
    },
    "instruction": "Update inventory levels in NetSuite using the REST API with TBA authentication",
    "outputTransform": "$",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "results": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "error": {
                "type": "string"
              },
              "itemId": {
                "type": "string"
              },
              "status": {
                "type": "string"
              },
              "locationId": {
                "type": "string"
              },
              "newQuantity": {
                "type": "number"
              },
              "adjustmentId": {
                "type": "string"
              },
              "adjustmentAmount": {
                "type": "number"
              },
              "previousQuantity": {
                "type": "number"
              }
            }
          }
        },
        "errorCount": {
          "type": "number"
        },
        "successCount": {
          "type": "number"
        }
      }
    },
    "description": "This tool updates inventory levels in NetSuite by creating an inventory adjustment based on specified item, location, and quantity details. It returns the updated inventory details, including the item ID, location ID, new quantity, and adjustment status."
  },
  "procore_daily_logs": {
    "id": "procore_daily_logs",
    "steps": [
      {
        "id": "fetchManpowerLogs",
        "apiConfig": {
          "id": "fetchManpowerLogs",
          "method": "GET",
          "headers": {
            "Content-Type": "application/json"
          },
          "urlHost": "https://api.procore.com",
          "urlPath": "/rest/v1.0/projects/{{project_id}}/manpower_logs",
          "instruction": "Fetch manpower logs from Procore project",
          "queryParams": {
            "page": "{{page}}",
            "end_date": "{{end_date}}",
            "log_date": "{{log_date}}",
            "per_page": "{{per_page}}",
            "company_id": "{{company_id}}",
            "start_date": "{{start_date}}"
          },
          "authentication": "OAUTH2"
        },
        "executionMode": "DIRECT"
      },
      {
        "id": "fetchDCRLogs",
        "apiConfig": {
          "id": "fetchDCRLogs",
          "method": "GET",
          "headers": {
            "Content-Type": "application/json"
          },
          "urlHost": "https://api.procore.com",
          "urlPath": "/rest/v1.0/projects/{{project_id}}/daily_construction_report_logs",
          "instruction": "Fetch daily construction report logs from Procore project if include_dcr is true",
          "queryParams": {
            "page": "{{page}}",
            "end_date": "{{end_date}}",
            "log_date": "{{log_date}}",
            "per_page": "{{per_page}}",
            "company_id": "{{company_id}}",
            "start_date": "{{start_date}}"
          },
          "authentication": "OAUTH2"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T22:14:32.020Z",
    "updatedAt": "2025-10-20T22:14:32.020Z",
    "inputSchema": {
      "type": "object",
      "required": ["project_id", "company_id"],
      "properties": {
        "page": {
          "type": "integer",
          "description": "Page number for pagination"
        },
        "end_date": {
          "type": "string",
          "description": "End date for date range (YYYY-MM-DD format)"
        },
        "log_date": {
          "type": "string",
          "description": "Specific log date (YYYY-MM-DD format)"
        },
        "per_page": {
          "type": "integer",
          "description": "Number of items per page"
        },
        "company_id": {
          "type": "string",
          "description": "Procore company ID"
        },
        "project_id": {
          "type": "string",
          "description": "Procore project ID"
        },
        "start_date": {
          "type": "string",
          "description": "Start date for date range (YYYY-MM-DD format)"
        },
        "include_dcr": {
          "type": "boolean",
          "description": "Whether to include daily construction report logs"
        }
      }
    },
    "instruction": "Build a Procore daily logs tool.\n\nStep 1: Fetch manpower logs\n- GET /rest/v1.0/projects/{project_id}/manpower_logs\n- Path param: project_id from inputs\n- Query params: company_id (required), log_date, start_date, end_date, page, per_page (optional)\n- Auth: Bearer token from OAuth\n- Return response\n\nStep 2: Fetch DCR logs (conditional on include_dcr flag)\n- Only execute if inputs.include_dcr is true\n- GET /rest/v1.0/projects/{project_id}/daily_construction_report_logs\n- Path param: project_id from inputs\n- Query params: company_id (required), log_date, start_date, end_date, page, per_page (optional)\n- Auth: Bearer token from OAuth\n- Return response\n\nCombine results as: {\"manpower\": step1_response, \"dcr\": step2_response}",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool retrieves detailed manpower and, if specified, daily construction report logs directly from your Procore project. It will provide comprehensive information on workforce activities and construction reports, organized by the specified project and date range."
  },
  "airtable_get_record": {
    "id": "airtable_get_record",
    "steps": [
      {
        "id": "fetchAirtableRecordById",
        "apiConfig": {
          "id": "fetchAirtableRecordById",
          "method": "GET",
          "headers": {
            "Authorization": "Bearer {{airtable_access_token}}"
          },
          "urlHost": "https://api.airtable.com",
          "urlPath": "/v0/{{payload.base_id}}/{{payload.table_name}}/{{payload.record_id}}",
          "instruction": "Fetch a single record by ID from an Airtable table with proper error handling for not found cases",
          "queryParams": {},
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T05:44:26.752Z",
    "updatedAt": "2025-10-20T05:44:26.752Z",
    "inputSchema": {
      "type": "object",
      "required": ["base_id", "table_name", "record_id"],
      "properties": {
        "airtable_access_token": {
          "type": "string",
          "description": "Airtable API key"
        },
        "base_id": {
          "type": "string",
          "description": "The Airtable base ID"
        },
        "record_id": {
          "type": "string",
          "description": "The ID of the record to fetch"
        },
        "table_name": {
          "type": "string",
          "description": "The name or ID of the table"
        }
      }
    },
    "instruction": "Fetch a single record by ID from an Airtable table.\n\nAPI Configuration:\n- Method: GET\n- Base URL: https://api.airtable.com\n- Path: /v0/{base_id}/{table_name}/{record_id}\n- Authentication: Bearer token in Authorization header using the access_token credential\n\nInput parameters:\n- base_id (required): The Airtable base ID\n- table_name (required): The name or ID of the table\n- record_id (required): The ID of the record to fetch (e.g., rec...)\n\nError handling:\n- If the record is not found (404), return a message indicating the record was not found\n- Handle permission errors gracefully\n\nOutput format:\n{\n  \"id\": \"rec...\",\n  \"fields\": { ... },\n  \"createdTime\": \"...\"\n}",
    "outputTransform": "$",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "fields": {
          "type": "object"
        },
        "createdTime": {
          "type": "string"
        }
      }
    },
    "description": "This tool retrieves a specific record from an Airtable database by using its unique ID. It will provide you with detailed information about the record, including its fields and creation time."
  },
  "airtable_create_record": {
    "id": "airtable_create_record",
    "steps": [
      {
        "id": "createAirtableRecords",
        "apiConfig": {
          "id": "createAirtableRecords",
          "body": "{\"records\": {{payload.records}}, \"typecast\": {{payload.typecast ? payload.typecast : false}}}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer {{airtable_access_token}}"
          },
          "urlHost": "https://api.airtable.com",
          "urlPath": "/v0/{{payload.base_id}}/{{payload.table_name}}",
          "instruction": "Create one or more records in an Airtable table with optional typecast support",
          "queryParams": {},
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T05:46:02.458Z",
    "updatedAt": "2025-10-20T05:46:02.458Z",
    "inputSchema": {
      "type": "object",
      "required": ["base_id", "table_name", "records"],
      "properties": {
        "airtable_access_token": {
          "type": "string",
          "description": "Airtable API key"
        },
        "base_id": {
          "type": "string",
          "description": "The Airtable base ID"
        },
        "records": {
          "type": "array",
          "items": {
            "type": "object",
            "required": ["fields"],
            "properties": {
              "fields": {
                "type": "object"
              }
            }
          },
          "description": "Array of record objects with fields"
        },
        "typecast": {
          "type": "boolean",
          "description": "Automatically convert data types (default: false)"
        },
        "table_name": {
          "type": "string",
          "description": "The name or ID of the table"
        }
      }
    },
    "instruction": "Create one or more records in an Airtable table.\n\nAPI Configuration:\n- Method: POST\n- Base URL: https://api.airtable.com\n- Path: /v0/{base_id}/{table_name}\n- Authentication: Bearer token in Authorization header using the access_token credential\n- Headers: Content-Type: application/json\n\nInput parameters:\n- base_id (required): The Airtable base ID\n- table_name (required): The name or ID of the table\n- records (required): Array of record objects, each with a \"fields\" property containing the field data\n  Example: [{\"fields\": {\"Name\": \"John\", \"Email\": \"john@example.com\"}}]\n- typecast (optional, boolean): Automatically convert data types. Default: false\n\nRequest body structure:\n{\n  \"records\": [array of record objects from input],\n  \"typecast\": [boolean value from input, default false if not provided]\n}\n\nOutput format:\n{\n  \"records\": [\n    {\n      \"id\": \"rec...\",\n      \"fields\": { ... },\n      \"createdTime\": \"...\"\n    }\n  ]\n}",
    "outputTransform": "$",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "records": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string"
              },
              "fields": {
                "type": "object"
              },
              "createdTime": {
                "type": "string"
              }
            }
          }
        }
      }
    },
    "description": "This tool enables you to seamlessly add one or more records to an Airtable table, automatically handling data type conversions if needed. It will return the details of the newly created records, including their unique IDs and the time they were created."
  },
  "coupa_list_purchase_orders": {
    "id": "coupa_list_purchase_orders",
    "steps": [
      {
        "id": "getPurchaseOrders",
        "apiConfig": {
          "id": "listPurchaseOrders",
          "method": "GET",
          "headers": {
            "Accept": "application/json",
            "X-COUPA-API-KEY": "<<coupa_sim_api_key>>"
          },
          "urlHost": "https://<<coupa_sim_coupa_instance>>.coupahost.com",
          "urlPath": "/api/purchase_orders",
          "pagination": {
            "type": "OFFSET_BASED",
            "pageSize": "50"
          },
          "instruction": "Get list of purchase orders from Coupa with pagination and filtering",
          "queryParams": {
            "limit": "{{payload.limit || 50}}",
            "offset": "{{payload.offset || 0}}",
            "status": "{{payload.status}}",
            "exported": "{{payload.exported !== false}}",
            "created_at[gt]": "{{payload.created_at_gt}}",
            "updated_at[gt]": "{{payload.updated_at_gt}}"
          },
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T01:23:15.677Z",
    "updatedAt": "2025-10-22T01:03:04.193Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "coupa_sim_api_key": {
          "type": "string",
          "description": "API key"
        },
        "coupa_sim_coupa_instance": {
          "type": "string",
          "description": "Coupa instance"
        },
        "limit": {
          "type": "number",
          "default": 50,
          "description": "Number of results to return"
        },
        "offset": {
          "type": "number",
          "default": 0,
          "description": "Number of results to skip for pagination"
        },
        "status": {
          "type": "string",
          "description": "Filter by purchase order status"
        },
        "exported": {
          "type": "boolean",
          "default": true,
          "description": "Include all fields in the response"
        },
        "created_at_gt": {
          "type": "string",
          "description": "Filter by created date greater than"
        },
        "updated_at_gt": {
          "type": "string",
          "description": "Filter by updated date greater than"
        }
      }
    },
    "instruction": "List purchase orders from Coupa using API key authentication with pagination and filtering support",
    "outputTransform": "$",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "page": {
          "type": "integer",
          "description": "Current page number"
        },
        "per_page": {
          "type": "integer",
          "description": "Items per page"
        },
        "total_count": {
          "type": "integer",
          "description": "Total number of purchase orders"
        },
        "purchase_orders": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "integer",
                "description": "Purchase order ID"
              },
              "total": {
                "type": "number",
                "description": "Total amount of the purchase order"
              },
              "status": {
                "type": "string",
                "description": "Purchase order status"
              },
              "supplier": {
                "type": "object",
                "properties": {
                  "id": {
                    "type": "integer"
                  },
                  "name": {
                    "type": "string"
                  }
                },
                "description": "Supplier information"
              },
              "created_at": {
                "type": "string",
                "description": "Creation timestamp"
              },
              "updated_at": {
                "type": "string",
                "description": "Last update timestamp"
              }
            }
          },
          "description": "Array of purchase order objects"
        }
      }
    },
    "description": "This tool connects to your Coupa account to retrieve a list of purchase orders, allowing you to apply filters like status and creation date. It will return detailed information for each purchase order, including ID, total amount, status, and supplier details."
  },
  "coupa_list_invoices": {
    "id": "coupa_list_invoices",
    "steps": [
      {
        "id": "getInvoices",
        "apiConfig": {
          "id": "listInvoices",
          "method": "GET",
          "headers": {
            "Accept": "application/json",
            "X-COUPA-API-KEY": "<<coupa_sim_api_key>>"
          },
          "urlHost": "https://<<coupa_sim_coupa_instance>>.coupahost.com",
          "urlPath": "/api/invoices",
          "pagination": {
            "type": "OFFSET_BASED",
            "pageSize": "50"
          },
          "instruction": "Get list of invoices from Coupa with pagination and filtering",
          "queryParams": {
            "limit": "{{payload.limit || 50}}",
            "offset": "{{payload.offset || 0}}",
            "status": "{{payload.status}}",
            "exported": "{{payload.exported !== false}}",
            "supplier_id": "{{payload.supplier_id}}",
            "created_at[gt]": "{{payload.created_at_gt}}",
            "updated_at[gt]": "{{payload.updated_at_gt}}"
          },
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T01:24:19.983Z",
    "updatedAt": "2025-10-22T01:08:38.469Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "coupa_sim_api_key": {
          "type": "string",
          "description": "API key"
        },
        "coupa_sim_coupa_instance": {
          "type": "string",
          "description": "Coupa instance"
        },
        "limit": {
          "type": "number",
          "default": 50,
          "description": "Number of results to return"
        },
        "offset": {
          "type": "number",
          "default": 0,
          "description": "Number of results to skip for pagination"
        },
        "status": {
          "type": "string",
          "description": "Filter by invoice status"
        },
        "exported": {
          "type": "boolean",
          "default": true,
          "description": "Include all fields in the response"
        },
        "supplier_id": {
          "type": "number",
          "description": "Filter by supplier ID"
        },
        "created_at_gt": {
          "type": "string",
          "description": "Filter by created date greater than"
        },
        "updated_at_gt": {
          "type": "string",
          "description": "Filter by updated date greater than"
        }
      }
    },
    "instruction": "List invoices from Coupa using API key authentication with pagination and filtering support",
    "outputTransform": "$",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "page": {
          "type": "integer",
          "description": "Current page number"
        },
        "invoices": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "integer",
                "description": "Invoice ID"
              },
              "total": {
                "type": "number",
                "description": "Total invoice amount"
              },
              "status": {
                "type": "string",
                "description": "Invoice status (e.g., approved, paid, pending_approval)"
              },
              "currency": {
                "type": "object",
                "properties": {
                  "code": {
                    "type": "string"
                  }
                },
                "description": "Currency information"
              },
              "supplier": {
                "type": "object",
                "properties": {
                  "id": {
                    "type": "integer"
                  },
                  "name": {
                    "type": "string"
                  }
                },
                "description": "Supplier information"
              },
              "created_at": {
                "type": "string",
                "description": "Creation timestamp"
              },
              "updated_at": {
                "type": "string",
                "description": "Last update timestamp"
              },
              "invoice_date": {
                "type": "string",
                "description": "Invoice date"
              },
              "payment_date": {
                "type": "string",
                "description": "Payment date"
              },
              "invoice_number": {
                "type": "string",
                "description": "Invoice number"
              }
            }
          },
          "description": "Array of invoice objects"
        },
        "per_page": {
          "type": "integer",
          "description": "Items per page"
        },
        "total_count": {
          "type": "integer",
          "description": "Total number of invoices"
        }
      }
    },
    "description": "This tool retrieves a list of invoices from Coupa, utilizing API key authentication to ensure secure access. It provides detailed invoice information, including invoice ID, total amount, status, and supplier details, with options for pagination and filtering based on criteria like status and creation date."
  },
  "confluence_page_create": {
    "id": "confluence_page_create",
    "steps": [
      {
        "id": "createConfluencePage",
        "apiConfig": {
          "id": "createConfluencePage",
          "method": "POST",
          "headers": {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "Authorization": "Basic <<auth_email>>:<<auth_token>>"
          },
          "urlHost": "https://<<subdomain>>.atlassian.net",
          "urlPath": "/wiki/rest/api/content",
          "body": "{\"type\":\"page\",\"space\":{\"key\":\"<<space_id>>\"},\"title\":\"<<title>>\",\"body\":{\"storage\":{\"value\":\"<<body>>\",\"representation\":\"storage\"}}}",
          "instruction": "Create a new Confluence page using POST /wiki/rest/api/content endpoint. Accept space_id (required), title (required), body (required), and parent_id (optional) as inputs. Create a JSON body with type=\"page\", space.key=space_id, title=title, body.storage.value=body, body.storage.representation=\"storage\". If parent_id is provided, include ancestors array with id. Return the full page JSON including id, title, status, and _links."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T00:59:07.020Z",
    "updatedAt": "2025-10-21T00:59:07.020Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "required": ["auth_email", "auth_token", "subdomain", "body", "title", "space_id"],
          "properties": {
            "auth_email": {
              "type": "string",
              "description": "Email address for authentication"
            },
            "auth_token": {
              "type": "string",
              "description": "API key"
            },
            "subdomain": {
              "type": "string",
              "description": "Domain prefix of your Confluence instance"
            },
            "body": {
              "type": "string",
              "description": "Content of the page in storage format"
            },
            "title": {
              "type": "string",
              "description": "Title of the page"
            },
            "space_id": {
              "type": "string",
              "description": "ID or key of the space where the page will be created"
            },
            "parent_id": {
              "type": "string",
              "description": "Parent page ID if nesting the page under another page"
            }
          }
        }
      }
    },
    "instruction": "Create a new Confluence page using POST /wiki/rest/api/content endpoint. Accept space_id (required), title (required), body (required), and parent_id (optional) as inputs. Create a JSON body with type=\"page\", space.key=space_id, title=title, body.storage.value=body, body.storage.representation=\"storage\". If parent_id is provided, include ancestors array with id. Return the full page JSON including id, title, status, and _links.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool allows you to create a new page in Confluence by specifying the space, title, and content of the page, with the option to nest it under an existing page. It will return detailed information about the newly created page, including its ID, title, status, and links."
  },
  "coupa_send_supplier_invites": {
    "id": "coupa_send_supplier_invites",
    "steps": [
      {
        "id": "sendInvites",
        "apiConfig": {
          "id": "sendSupplierInvites",
          "body": "{\"supplier_ids\": {{JSON.stringify(payload.supplier_ids)}}, \"message\": \"{{payload.message}}\"}",
          "method": "POST",
          "headers": {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "X-COUPA-API-KEY": "<<coupa_sim_api_key>>"
          },
          "urlHost": "https://<<coupa_sim_coupa_instance>>.coupahost.com",
          "urlPath": "/api/suppliers/send_invitations",
          "instruction": "Send invitations to suppliers in Coupa",
          "queryParams": {
            "return_object": "{{payload.return_object || 'limited'}}"
          },
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T01:25:38.486Z",
    "updatedAt": "2025-10-22T01:08:56.583Z",
    "inputSchema": {
      "type": "object",
      "required": ["supplier_ids"],
      "properties": {
        "coupa_sim_api_key": {
          "type": "string",
          "description": "API key"
        },
        "coupa_sim_coupa_instance": {
          "type": "string",
          "description": "Coupa instance"
        },
        "message": {
          "type": "string",
          "description": "Custom message to include in the invitation"
        },
        "supplier_ids": {
          "type": "array",
          "items": {
            "type": "number"
          },
          "description": "Array of supplier IDs to send invitations to"
        },
        "return_object": {
          "type": "string",
          "default": "limited",
          "description": "Response format (limited or full)"
        }
      }
    },
    "instruction": "Send supplier invitations in Coupa using API key authentication",
    "outputTransform": "$",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "results": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "reason": {
                "type": "string",
                "description": "Failure reason if status is failed"
              },
              "status": {
                "type": "string",
                "description": "Invite status (queued, sent, failed)"
              },
              "sent_at": {
                "type": "string",
                "description": "Timestamp when invite was sent"
              },
              "invite_id": {
                "type": "integer",
                "description": "Invite ID if successful"
              },
              "company_name": {
                "type": "string",
                "description": "Supplier company name"
              },
              "contact_email": {
                "type": "string",
                "description": "Contact email"
              }
            }
          },
          "description": "Array of invite results per supplier"
        },
        "failed_count": {
          "type": "integer",
          "description": "Number of failed invites"
        },
        "success_count": {
          "type": "integer",
          "description": "Number of successfully sent invites"
        }
      }
    },
    "description": "This tool sends personalized invitations to suppliers through the Coupa platform using a list of supplier IDs and an optional custom message. It returns detailed results for each invitation, including the status, any failure reasons, and counts of successful and failed invitations."
  },
  "confluence_space_list": {
    "id": "confluence_space_list",
    "steps": [
      {
        "id": "getAllSpaces",
        "apiConfig": {
          "id": "getAllSpaces",
          "method": "GET",
          "headers": {
            "Accept": "application/json",
            "Authorization": "Basic <<auth_email>>:<<auth_token>>"
          },
          "urlHost": "https://<<instance_subdomain>>.atlassian.net",
          "urlPath": "/wiki/rest/api/space",
          "instruction": "List all Confluence spaces using GET /wiki/rest/api/space endpoint. Return an array of spaces with id, key, name, type, status, and _links. Support pagination if available."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T03:36:51.848Z",
    "updatedAt": "2025-10-21T03:36:51.848Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "auth_email": {
          "type": "string",
          "description": "Email address for authentication"
        },
        "auth_token": {
          "type": "string",
          "description": "API key"
        },
        "instance_subdomain": {
          "type": "string",
          "description": "Domain prefix of your Confluence instance"
        }
      }
    },
    "instruction": "List all Confluence spaces using GET /wiki/rest/api/space endpoint. Return an array of spaces with id, key, name, type, status, and _links. Support pagination if available.",
    "outputTransform": "(sourceData) => { return { data: (sourceData.getAllSpaces && sourceData.getAllSpaces.results) ? sourceData.getAllSpaces.results : [] }; }",
    "systemIds": [],
    "description": "This tool fetches a comprehensive list of all Confluence spaces from your Atlassian account. It will return detailed information for each space, including its ID, key, name, type, status, and relevant links."
  },
  "slack_schedule_message": {
    "id": "slack_schedule_message",
    "steps": [
      {
        "id": "scheduleSlackMessage",
        "apiConfig": {
          "id": "scheduleSlackMessage",
          "body": "{\"channel\": \"<<channel>>\", \"text\": \"<<text>>\", \"post_at\": <<post_at>> }",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<slack-2_access_token>>"
          },
          "urlHost": "https://slack.com",
          "urlPath": "/api/chat.scheduleMessage",
          "instruction": "Schedule a message to be sent to a Slack channel at a specific Unix timestamp using chat.scheduleMessage."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T05:16:06.306Z",
    "updatedAt": "2025-10-21T05:16:06.306Z",
    "inputSchema": {
      "type": "object",
      "required": ["channel", "text", "post_at"],
      "properties": {
        "text": {
          "type": "string",
          "description": "The message text to send"
        },
        "channel": {
          "type": "string",
          "description": "The channel name or ID"
        },
        "post_at": {
          "type": "integer",
          "description": "Unix timestamp (seconds since epoch) when to post the message"
        }
      }
    },
    "instruction": "Schedule a Slack message to be sent at a specific time using the chat.scheduleMessage API endpoint. The tool should schedule a message to be posted to a channel at the specified Unix timestamp.",
    "outputTransform": "(sourceData) => { return { scheduled_message: sourceData.scheduleSlackMessage }; }",
    "systemIds": [],
    "description": "This tool allows you to schedule a message to be sent to a specific Slack channel at a designated time. It will return details of the scheduled message, including its confirmation that it is set to be posted at your specified time."
  },
  "monday_get_board_items": {
    "id": "monday_get_board_items",
    "steps": [
      {
        "id": "fetchFirstPage",
        "apiConfig": {
          "id": "fetchFirstPage",
          "body": "{\n  \"query\": \"query ($board_id: [ID!], $limit: Int) { boards(ids: $board_id) { items_page(limit: $limit) { cursor items { id name created_at updated_at column_values { id text } } } } }\",\n  \"variables\": {\n    \"board_id\": <<board_id>>,\n    \"limit\": <<(sourceData) => sourceData.page_limit || 100>>\n  }\n}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<monday_apiKey>>"
          },
          "urlHost": "https://api.monday.com/v2",
          "urlPath": "",
          "instruction": "Fetch the first page of items from the specified board using items_page with cursor-based pagination. Request cursor, and for each item: id, name, created_at, updated_at, column_values (id, text)."
        },
        "executionMode": "DIRECT"
      },
      {
        "id": "fetchNextPages",
        "apiConfig": {
          "id": "fetchNextPages",
          "body": "{\n  \"query\": \"query ($cursor: String!, $limit: Int) { next_items_page(cursor: $cursor, limit: $limit) { cursor items { id name created_at updated_at column_values { id text } } } }\",\n  \"variables\": {\n    \"cursor\": <<currentItem>>,\n    \"limit\": <<(sourceData) => sourceData.page_limit || 100>>\n  }\n}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<monday_apiKey>>"
          },
          "urlHost": "https://api.monday.com/v2",
          "urlPath": "",
          "instruction": "Fetch subsequent pages of items from the board using next_items_page and the cursor. Request cursor, and for each item: id, name, created_at, updated_at, column_values (id, text)."
        },
        "dataSelector": "(sourceData) => {\n  const cursor = sourceData.fetchFirstPage?.data?.boards?.[0]?.items_page?.cursor;\n  if (!cursor) return [];\n  return [cursor];\n}",
        "executionMode": "LOOP"
      }
    ],
    "createdAt": "2025-10-20T03:59:42.091Z",
    "updatedAt": "2025-10-20T03:59:42.091Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "board_id": {
              "type": "string",
              "description": "The unique identifier for the board"
            },
            "page_limit": {
              "type": "integer",
              "description": "Maximum number of items to fetch per page"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "monday_apiKey": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Build a Monday.com GraphQL tool to fetch all items from a board using cursor-based pagination.\n\n1. Make a POST request to the Monday.com GraphQL API endpoint\n2. Use Bearer token authentication with the format: \"Authorization: Bearer {apiKey from monday integration}\"\n3. Accept required input: board_id and optional input: page_limit (default 100)\n4. Build a GraphQL query using boards(ids: [board_id]) with items_page for cursor pagination\n5. Query should request: cursor, and for each item: id, name, created_at, updated_at, column_values (id, text)\n6. Set Content-Type header to \"application/json\"\n7. Use LOOP execution mode to paginate through all items using the cursor\n8. Continue looping until cursor is null or empty\n9. Accumulate all items from each page and return the complete list",
    "outputTransform": "(sourceData) => {\n  // Helper to extract items from a page result\n  function extractItems(page) {\n    if (!page) return [];\n    if (page.data?.boards?.[0]?.items_page?.items) return page.data.boards[0].items_page.items;\n    if (page.data?.next_items_page?.items) return page.data.next_items_page.items;\n    return [];\n  }\n\n  // Collect all items from the first page\n  let allItems = extractItems(sourceData.fetchFirstPage);\n\n  // Loop to fetch all next pages using the cursor\n  let nextPage = sourceData.fetchFirstPage;\n  let cursor = nextPage?.data?.boards?.[0]?.items_page?.cursor;\n  let nextPages = [];\n  let seenCursors = new Set();\n  while (cursor) {\n    // Find the next page result in fetchNextPages\n    const nextResult = (Array.isArray(sourceData.fetchNextPages) ? sourceData.fetchNextPages : []).find(p => p?.data?.next_items_page?.cursor === cursor);\n    if (!nextResult) break;\n    const items = extractItems(nextResult);\n    allItems = allItems.concat(items);\n    seenCursors.add(cursor);\n    cursor = nextResult?.data?.next_items_page?.cursor;\n    // Prevent infinite loop if API returns same cursor again\n    if (seenCursors.has(cursor)) break;\n  }\n\n  return { items: allItems };\n}",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool retrieves all items from a specified board on Monday.com using a method that efficiently handles large datasets. It compiles and returns a complete list of items, including their details such as ID, name, creation date, update date, and column values."
  },
  "confluence_page_search": {
    "id": "confluence_page_search",
    "steps": [
      {
        "id": "searchPagesByCQL",
        "apiConfig": {
          "id": "searchPagesByCQL",
          "method": "GET",
          "headers": {
            "Accept": "application/json",
            "Authorization": "Basic <<auth_email>>:<<auth_token>>"
          },
          "urlHost": "https://<<subdomain>>.atlassian.net",
          "urlPath": "/wiki/rest/api/content/search",
          "queryParams": {
            "cql": "<<cql>>"
          },
          "instruction": "Search for Confluence pages by CQL query using GET /wiki/rest/api/content/search endpoint. Return array of pages with id, title, type, status, and _links."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T03:31:44.122Z",
    "updatedAt": "2025-10-21T03:31:44.122Z",
    "inputSchema": {
      "type": "object",
      "required": ["subdomain", "auth_email", "auth_token", "cql"],
      "properties": {
        "subdomain": {
          "type": "string",
          "description": "Domain prefix of your Confluence instance"
        },
        "auth_email": {
          "type": "string",
          "description": "Email address for authentication"
        },
        "auth_token": {
          "type": "string",
          "description": "API key"
        },
        "cql": {
          "type": "string",
          "description": "CQL query string to search for pages"
        }
      }
    },
    "instruction": "Search for Confluence pages by keyword using GET /wiki/rest/api/content/search endpoint. Accept keyword (required) as input. Use CQL query parameter to search for pages with the keyword in text or title. Return array of pages with id, title, type, status, and _links.",
    "outputTransform": "(sourceData) => { return { data: sourceData.searchPagesByCQL.data }; }",
    "systemIds": [],
    "description": "This tool allows you to search for Confluence pages by entering a specific keyword. It will return a list of pages that match your keyword, providing details such as the page ID, title, type, status, and relevant links."
  },
  "monday_create_item": {
    "id": "monday_create_item",
    "steps": [
      {
        "id": "createItem",
        "apiConfig": {
          "id": "createItem",
          "body": "<<(sourceData) => { const validGroupId = 'new_group29179'; const hasColumns = !!sourceData.column_values && Object.keys(sourceData.column_values).length > 0; const colStr = hasColumns ? ', column_values: \"' + JSON.stringify(sourceData.column_values).replace(/\"/g, '\\\\\"') + '\"' : ''; return JSON.stringify({ query: `mutation { create_item(board_id: ${sourceData.board_id}, group_id: \\\"${validGroupId}\\\", item_name: \\\"${sourceData.item_name}\\\"${colStr}) { id name } }` }); }>>",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<monday_apiKey>>"
          },
          "urlHost": "https://api.monday.com/v2/",
          "urlPath": "",
          "instruction": "Create a new item in a specified board and group using the create_item GraphQL mutation. Accepts board_id, group_id, item_name (required), and column_values (optional, as JSON string). Returns id and name of the created item."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T04:01:45.140Z",
    "updatedAt": "2025-10-20T04:01:45.140Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "board_id": {
              "type": "string",
              "description": "The ID of the board where the item will be created"
            },
            "group_id": {
              "type": "string",
              "description": "The ID of the group within the board"
            },
            "item_name": {
              "type": "string",
              "description": "The name of the new item"
            },
            "column_values": {
              "type": "object",
              "properties": {
                "date": {
                  "type": "string",
                  "description": "The date associated with the item"
                },
                "numbers": {
                  "type": "integer",
                  "description": "A numerical value related to the item"
                },
                "project_status": {
                  "type": "string",
                  "description": "The status of the project"
                }
              }
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "monday_apiKey": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Build a Monday.com GraphQL tool to create a new item in a board/group.\n\n1. Make a POST request to the Monday.com GraphQL API endpoint\n2. Use Bearer token authentication with the format: \"Authorization: Bearer {apiKey from monday integration}\"\n3. Accept required inputs: board_id, group_id, item_name\n4. Accept optional input: column_values (JSON object that will be stringified)\n5. Build a GraphQL mutation using create_item with parameters: board_id, group_id, item_name, and column_values (as JSON string)\n6. The mutation should return: id and name of the created item\n7. Set Content-Type header to \"application/json\"\n8. Convert column_values object to JSON string before sending (Monday API requirement)\n9. Return the created item details",
    "outputTransform": "(sourceData) => { const item = sourceData.createItem?.data?.create_item; if (!item) throw new Error('No item returned from Monday.com'); return { id: item.id, name: item.name }; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool connects to Monday.com to create a new item on your specified board and group. It will return the unique ID and name of the newly created item, allowing you to easily track and manage your projects."
  },
  "monday_update_item": {
    "id": "monday_update_item",
    "steps": [
      {
        "id": "updateItemColumns",
        "apiConfig": {
          "id": "updateItemColumns",
          "body": "{\"query\": \"mutation ($board_id: ID!, $item_id: ID!, $column_values: JSON!) { change_multiple_column_values(board_id: $board_id, item_id: $item_id, column_values: $column_values) { id name } }\",\"variables\": {\"board_id\": \"<<(sourceData) => sourceData.board_id>>\",\"item_id\": \"<<(sourceData) => sourceData.item_id>>\",\"column_values\": <<(sourceData) => JSON.stringify(JSON.stringify(sourceData.column_values))>>}}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<monday_apiKey>>"
          },
          "urlHost": "https://api.monday.com/v2/",
          "urlPath": "",
          "instruction": "Update an item's column values using the change_multiple_column_values GraphQL mutation. Return the updated item's id and name."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T04:05:18.214Z",
    "updatedAt": "2025-10-20T04:05:18.214Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "item_id": {
              "type": "string",
              "description": "The unique identifier for the item"
            },
            "board_id": {
              "type": "string",
              "description": "The unique identifier for the board"
            },
            "column_values": {
              "type": "object",
              "properties": {
                "numbers": {
                  "type": "integer",
                  "description": "The numerical value for the column"
                },
                "project_status": {
                  "type": "string",
                  "description": "The status of the project"
                }
              }
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "monday_apiKey": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Build a Monday.com GraphQL tool to update an item's column values.\n\n1. POST to https://api.monday.com/v2\n2. Bearer token auth: \"Authorization: Bearer {monday apiKey}\"\n3. Content-Type: application/json\n4. Required inputs: board_id, item_id, column_values (object)\n5. GraphQL mutation: change_multiple_column_values(board_id: $board_id, item_id: $item_id, column_values: $column_values) { id name }\n6. Build body with query and variables where column_values is JSON.stringify(sourceData.column_values)\n7. Return the updated item's id and name from the response data",
    "outputTransform": "(sourceData) => {\n  const data = sourceData.updateItemColumns?.data?.change_multiple_column_values;\n  if (!data) throw new Error('No data returned from monday.com mutation');\n  return { id: data.id, name: data.name };\n}",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool updates specific columns for an item within your Monday.com boards by sending a request through Monday's API. It will return the updated item's ID and name, confirming the changes made."
  },
  "airtable_update_record": {
    "id": "airtable_update_record",
    "steps": [
      {
        "id": "patchAirtableRecords",
        "apiConfig": {
          "id": "patchAirtableRecords",
          "body": "{\"records\": {{payload.records}}, \"typecast\": {{payload.typecast ? payload.typecast : false}}}",
          "method": "PATCH",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer {{airtable_access_token}}"
          },
          "urlHost": "https://api.airtable.com",
          "urlPath": "/v0/{{payload.base_id}}/{{payload.table_name}}",
          "instruction": "Partially update one or more records in the specified Airtable table using PATCH. Only update fields provided in the input, leave others unchanged.",
          "queryParams": {},
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T05:48:38.431Z",
    "updatedAt": "2025-10-20T05:48:38.431Z",
    "inputSchema": {
      "type": "object",
      "required": ["base_id", "table_name", "records"],
      "properties": {
        "airtable_access_token": {
          "type": "string",
          "description": "Airtable API key"
        },
        "base_id": {
          "type": "string",
          "description": "The Airtable base ID"
        },
        "records": {
          "type": "array",
          "items": {
            "type": "object",
            "required": ["id", "fields"],
            "properties": {
              "id": {
                "type": "string"
              },
              "fields": {
                "type": "object"
              }
            }
          },
          "description": "Array of record objects with id and fields to update"
        },
        "typecast": {
          "type": "boolean",
          "description": "Automatically convert data types (default: false)"
        },
        "table_name": {
          "type": "string",
          "description": "The name or ID of the table"
        }
      }
    },
    "instruction": "Partially update fields on one or more records in an Airtable table.\n\nAPI Configuration:\n- Method: PATCH\n- Base URL: https://api.airtable.com\n- Path: /v0/{base_id}/{table_name}\n- Authentication: Bearer token in Authorization header using the access_token credential\n- Headers: Content-Type: application/json\n\nInput parameters:\n- base_id (required): The Airtable base ID\n- table_name (required): The name or ID of the table\n- records (required): Array of record objects with id and fields to update\n  Example: [{\"id\": \"rec123\", \"fields\": {\"Name\": \"Updated Name\", \"Email\": \"updated@example.com\"}}]\n- typecast (optional, boolean): Automatically convert data types. Default: false\n\nRequest body structure:\n{\n  \"records\": [array of record objects with id and fields from input],\n  \"typecast\": [boolean value from input, default false if not provided]\n}\n\nNote: PATCH only updates the fields provided, leaving other fields unchanged.\n\nOutput format:\n{\n  \"records\": [\n    {\n      \"id\": \"rec...\",\n      \"fields\": { ... },\n      \"createdTime\": \"...\"\n    }\n  ]\n}",
    "outputTransform": "$",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "records": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string"
              },
              "fields": {
                "type": "object"
              },
              "createdTime": {
                "type": "string"
              }
            }
          }
        }
      }
    },
    "description": "This tool seamlessly updates specific fields in one or more records within your Airtable table, ensuring that existing data remains untouched unless specified for change. It returns the updated records with their unique IDs and the time they were last modified, providing you with the latest data at your fingertips."
  },
  "airtable_delete_record": {
    "id": "airtable_delete_record",
    "steps": [
      {
        "id": "deleteAirtableRecord",
        "apiConfig": {
          "id": "deleteAirtableRecord",
          "method": "DELETE",
          "headers": {
            "Authorization": "Bearer {{airtable_access_token}}"
          },
          "urlHost": "https://api.airtable.com",
          "urlPath": "/v0/{{payload.base_id}}/{{payload.table_name}}/{{payload.record_id}}",
          "instruction": "Delete a single record by ID from the specified Airtable base and table",
          "queryParams": {},
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T05:49:43.400Z",
    "updatedAt": "2025-10-20T05:49:43.400Z",
    "inputSchema": {
      "type": "object",
      "required": ["base_id", "table_name", "record_id"],
      "properties": {
        "airtable_access_token": {
          "type": "string",
          "description": "Airtable API key"
        },
        "base_id": {
          "type": "string",
          "description": "The Airtable base ID"
        },
        "record_id": {
          "type": "string",
          "description": "The ID of the record to delete"
        },
        "table_name": {
          "type": "string",
          "description": "The name or ID of the table"
        }
      }
    },
    "instruction": "Delete a single record by ID from an Airtable table.\n\nAPI Configuration:\n- Method: DELETE\n- Base URL: https://api.airtable.com\n- Path: /v0/{base_id}/{table_name}/{record_id}\n- Authentication: Bearer token in Authorization header using the access_token credential\n\nInput parameters:\n- base_id (required): The Airtable base ID\n- table_name (required): The name or ID of the table\n- record_id (required): The ID of the record to delete (e.g., rec...)\n\nOutput format:\n{\n  \"deleted\": true,\n  \"id\": \"rec...\"\n}",
    "outputTransform": "$",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "deleted": {
          "type": "boolean"
        }
      }
    },
    "description": "This tool seamlessly connects to Airtable to remove a specific record from your chosen base and table. It confirms the deletion by returning the record ID and a success status, ensuring your data is updated accurately."
  },
  "airtable_list_tables": {
    "id": "airtable_list_tables",
    "steps": [
      {
        "id": "getTablesAndSchema",
        "apiConfig": {
          "id": "getTablesAndSchema",
          "method": "GET",
          "headers": {
            "Authorization": "Bearer {{airtable_access_token}}"
          },
          "urlHost": "https://api.airtable.com",
          "urlPath": "/v0/meta/bases/{{payload.base_id}}/tables",
          "instruction": "Get all tables and their schema for the specified Airtable base using the Metadata API",
          "queryParams": {},
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T05:51:36.450Z",
    "updatedAt": "2025-10-20T05:51:36.450Z",
    "inputSchema": {
      "type": "object",
      "required": ["base_id"],
      "properties": {
        "airtable_access_token": {
          "type": "string",
          "description": "Airtable API key"
        },
        "base_id": {
          "type": "string",
          "description": "The Airtable base ID"
        }
      }
    },
    "instruction": "List tables and their schema for an Airtable base using the Metadata API.\n\nAPI Configuration:\n- Method: GET\n- Base URL: https://api.airtable.com\n- Path: /v0/meta/bases/{base_id}/tables\n- Authentication: Bearer token in Authorization header using the access_token credential\n- Note: The access token must include the metadata scope (schema.bases:read)\n\nInput parameters:\n- base_id (required): The Airtable base ID\n\nOutput format:\n{\n  \"tables\": [\n    {\n      \"id\": \"...\",\n      \"name\": \"...\",\n      \"primaryFieldId\": \"...\",\n      \"fields\": [\n        {\n          \"id\": \"...\",\n          \"name\": \"...\",\n          \"type\": \"...\"\n        }\n      ]\n    }\n  ]\n}\n\nThe endpoint returns metadata about all tables in the base, including table IDs, names, and field schemas.",
    "outputTransform": "$",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "tables": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string"
              },
              "name": {
                "type": "string"
              },
              "fields": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string"
                    },
                    "name": {
                      "type": "string"
                    },
                    "type": {
                      "type": "string"
                    }
                  }
                }
              },
              "primaryFieldId": {
                "type": "string"
              }
            }
          }
        }
      }
    },
    "description": "This tool retrieves detailed information about all the tables within a specified Airtable base. It provides you with the table IDs, names, and the structure of each field, offering a comprehensive overview of your Airtable database setup."
  },
  "monday_list_boards": {
    "id": "monday_list_boards",
    "steps": [
      {
        "id": "listBoardsWithPagination",
        "apiConfig": {
          "id": "listBoardsWithPagination",
          "body": "{\n  \"query\": \"query ($limit: Int!, $page: Int!) { boards (limit: $limit, page: $page) { id name description state board_folder_id board_kind owner { id name } workspace { id name } } }\",\n  \"variables\": {\n    \"limit\": <<(sourceData) => sourceData.limit || 100>>,\n    \"page\": <<(sourceData) => sourceData.page || 1>>\n  }\n}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<monday_apiKey>>"
          },
          "urlHost": "https://api.monday.com/v2",
          "urlPath": "",
          "version": null,
          "dataPath": null,
          "createdAt": null,
          "updatedAt": null,
          "pagination": null,
          "instruction": "Fetch a paginated list of boards with fields: id, name, description, state, board_folder_id, board_kind, owner (id, name), workspace (id, name). Use limit and page (as offset) for pagination.",
          "queryParams": null,
          "authentication": null,
          "outputSchema": null,
          "responseMapping": null,
          "documentationUrl": null
        },
        "inputMapping": null,
        "loopMaxIters": null,
        "dataSelector": null,
        "executionMode": "DIRECT",
        "responseMapping": null
      }
    ],
    "createdAt": "2025-10-20T04:16:17.574Z",
    "updatedAt": "2025-10-20T04:16:17.574Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "page": {
              "type": "integer",
              "description": "Page number for board listing"
            },
            "limit": {
              "type": "integer",
              "description": "Number of boards to display per page"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "monday_apiKey": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Build a Monday.com GraphQL tool to list boards with pagination.\n\n1. Make a POST request to the Monday.com GraphQL API endpoint\n2. Use Bearer token authentication with the format: \"Authorization: Bearer {apiKey from monday integration}\"\n3. Accept optional input parameters: limit (default 100) and page (default 1)\n4. Build a GraphQL query to fetch boards with pagination using limit and page parameters\n5. Query should request these fields: id, name, description, state, board_folder_id, board_kind, owner (id, name), workspace (id, name)\n6. Set Content-Type header to \"application/json\"\n7. Return the boards data from the response",
    "outputTransform": "(sourceData) => {\n  // Monday.com GraphQL returns data in { data: { boards: [...] } }\n  if (!sourceData.listBoardsWithPagination?.data?.boards) throw new Error('No boards data returned');\n  return { boards: sourceData.listBoardsWithPagination.data.boards };\n}",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool connects with Monday.com to retrieve a list of boards using pagination. It will return detailed information about each board, including their ID, name, description, state, and associated ownership and workspace details."
  },
  "notion_retrieve_page": {
    "id": "notion_retrieve_page",
    "steps": [
      {
        "id": "getPageById",
        "apiConfig": {
          "id": "get_page",
          "method": "GET",
          "headers": {
            "Authorization": "Bearer <<notion_sg_testing_api_key>>",
            "Notion-Version": "2022-06-28"
          },
          "urlHost": "https://api.notion.com",
          "urlPath": "/v1/pages/{{page_id}}",
          "instruction": "Retrieve a Notion page by its ID"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T05:48:53.746Z",
    "updatedAt": "2025-10-21T05:48:53.746Z",
    "inputSchema": {
      "type": "object",
      "required": ["page_id"],
      "properties": {
        "notion_sg_testing_api_key": {
          "type": "string",
          "description": "Your API key"
        },
        "page_id": {
          "type": "string",
          "description": "The ID of the page to retrieve"
        }
      }
    },
    "instruction": "Retrieve a Notion page and its properties by ID. GET to /pages/{page_id} with headers: Notion-Version: 2022-06-28, Authorization: Bearer <<notion_sg_testing_api_key>>. Accept page_id as input and return the complete page object including properties, parent, and metadata.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool connects to Notion to retrieve a specific page using its unique ID. It will return the complete page details, including its properties, parent, and metadata, directly from your Notion account."
  },
  "procore_rfis": {
    "id": "procore_rfis",
    "steps": [
      {
        "id": "listOrCreateRfis",
        "apiConfig": {
          "id": "listOrCreateRfis",
          "method": "GET",
          "headers": {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "Procore-Company-Id": "{company_id}"
          },
          "urlHost": "https://api.procore.com",
          "urlPath": "/rest/v1.0/projects/{project_id}/rfis",
          "instruction": "List or create RFIs in Procore. If input contains 'question' field, POST to create an RFI. Otherwise, GET to list RFIs. Always include Procore-Company-Id header from input company_id field.",
          "queryParams": {},
          "authentication": "OAUTH2",
          "documentationUrl": "https://developers.procore.com/reference/rest/v1/rfis"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T20:32:17.413Z",
    "updatedAt": "2025-10-20T20:32:17.413Z",
    "inputSchema": {
      "type": "object",
      "required": ["project_id", "company_id"],
      "properties": {
        "page": {
          "type": "number",
          "description": "Page number for pagination"
        },
        "title": {
          "type": "string",
          "description": "RFI title"
        },
        "status": {
          "type": "string",
          "description": "RFI status"
        },
        "per_page": {
          "type": "number",
          "description": "Number of results per page"
        },
        "question": {
          "type": "string",
          "description": "RFI question"
        },
        "assignees": {
          "type": "array",
          "description": "Array of assignee IDs"
        },
        "company_id": {
          "type": "number",
          "description": "The Procore company ID"
        },
        "project_id": {
          "type": "number",
          "description": "The Procore project ID"
        },
        "description": {
          "type": "string",
          "description": "RFI description"
        },
        "updated_at_to": {
          "type": "string",
          "description": "Filter RFIs updated before this date"
        },
        "updated_at_from": {
          "type": "string",
          "description": "Filter RFIs updated after this date"
        }
      }
    },
    "instruction": "Build a Procore RFI tool that handles listing and creating RFIs.\n\n**Step 1: List or Create RFIs based on input**\n\nIf the input does NOT contain a \"question\" field, perform LIST operation:\n- Method: GET\n- Full URL: https://api.procore.com/rest/v1.0/projects/{project_id}/rfis\n- Headers (REQUIRED):\n  * Authorization: Bearer {procore.access_token}\n  * Procore-Company-Id: {company_id}\n  * Accept: application/json\n- Query parameters: Add these from input if they exist: updated_at_from, updated_at_to, page, per_page\n- Return the response as: {\"rfis\": <response_data>}\n\nIf the input DOES contain a \"question\" field, perform CREATE operation:\n- Method: POST\n- Full URL: https://api.procore.com/rest/v1.0/projects/{project_id}/rfis\n- Headers (REQUIRED):\n  * Authorization: Bearer {procore.access_token}\n  * Procore-Company-Id: {company_id}\n  * Content-Type: application/json\n  * Accept: application/json\n- Body: {\"rfi\": {\"question\": \"{question}\", \"title\": \"{title}\", \"status\": \"{status}\", \"assignees\": {assignees}}}\n- Return as: {\"rfis\": [<created_rfi>]}\n\nCRITICAL: The Procore-Company-Id header value must come from the input payload's company_id field.",
    "outputTransform": "$",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "rfis": {
          "type": "array",
          "description": "Array of RFI objects from list or single created RFI"
        }
      }
    },
    "description": "This tool interacts with Procore to either list existing RFIs or create a new RFI, depending on the input provided. It returns a collection of RFI details if listing, or the full details of the newly created RFI."
  },
  "procore_submittals": {
    "id": "procore_submittals",
    "steps": [
      {
        "id": "listSubmittals",
        "apiConfig": {
          "id": "listSubmittals",
          "method": "GET",
          "headers": {
            "Accept": "application/json",
            "Procore-Company-Id": "{company_id}"
          },
          "urlHost": "https://api.procore.com",
          "urlPath": "/rest/v1.0/projects/{project_id}/submittals",
          "instruction": "List submittals for a Procore project with status and workflow fields. Include Procore-Company-Id header from input company_id field. Support optional filtering by status, date range, and pagination.",
          "queryParams": {},
          "authentication": "OAUTH2",
          "documentationUrl": "https://developers.procore.com/reference/rest/submittals"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T20:36:16.387Z",
    "updatedAt": "2025-10-20T20:36:16.387Z",
    "inputSchema": {
      "type": "object",
      "required": ["project_id", "company_id"],
      "properties": {
        "page": {
          "type": "number",
          "description": "Page number for pagination"
        },
        "status": {
          "type": "string",
          "description": "Filter by submittal status"
        },
        "per_page": {
          "type": "number",
          "description": "Number of results per page"
        },
        "company_id": {
          "type": "number",
          "description": "The Procore company ID"
        },
        "project_id": {
          "type": "number",
          "description": "The Procore project ID"
        },
        "updated_at_to": {
          "type": "string",
          "description": "Filter submittals updated before this date"
        },
        "updated_at_from": {
          "type": "string",
          "description": "Filter submittals updated after this date"
        }
      }
    },
    "instruction": "Build a Procore Submittals tool (procore_submittals) to list submittals with status fields:\n\n**LIST SUBMITTALS Operation:**\n- Method: GET\n- Full URL: https://api.procore.com/rest/v1.0/projects/{project_id}/submittals\n- Headers (REQUIRED):\n  * Authorization: Bearer {procore.access_token}\n  * Procore-Company-Id: {company_id}\n  * Accept: application/json\n\n**Required Input:**\n- project_id (number): The Procore project ID\n- company_id (number): The Procore company ID\n\n**Optional Query Parameters (add if present in input):**\n- status: Filter by submittal status\n- updated_at_from: Filter submittals updated after this date\n- updated_at_to: Filter submittals updated before this date  \n- page: Page number for pagination\n- per_page: Number of results per page\n\n**Response:**\n- Return the API response transformed to: {\"submittals\": <response_array>}\n- Include all status and workflow fields from the API response",
    "outputTransform": "$",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "submittals": {
          "type": "array",
          "description": "Array of submittal objects with status and workflow fields"
        }
      }
    },
    "description": "This tool connects to Procore to retrieve a list of project submittals, complete with status and workflow details. It provides a comprehensive summary of submittals for a specific project, allowing for optional filtering by status, date range, and pagination."
  },
  "procore_drawing_revisions": {
    "id": "procore_drawing_revisions",
    "steps": [
      {
        "id": "getDrawingRevisions",
        "apiConfig": {
          "id": "getDrawingRevisions",
          "method": "GET",
          "urlHost": "https://api.procore.com",
          "urlPath": "/rest/v1.0/projects/{{project_id}}/drawing_revisions",
          "instruction": "Get drawing revisions for a Procore project with optional filters",
          "queryParams": {
            "page": "{{page}}",
            "current": "{{current}}",
            "per_page": "{{per_page}}",
            "company_id": "{{company_id}}",
            "drawing_area_id": "{{drawing_area_id}}"
          },
          "authentication": "OAUTH2"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T20:48:44.831Z",
    "updatedAt": "2025-10-20T20:48:44.831Z",
    "inputSchema": {
      "type": "object",
      "required": ["project_id", "company_id"],
      "properties": {
        "page": {
          "type": "integer",
          "description": "Page number for pagination (optional)"
        },
        "current": {
          "type": "boolean",
          "description": "Filter for current revisions only (optional)"
        },
        "per_page": {
          "type": "integer",
          "description": "Number of results per page (optional)"
        },
        "company_id": {
          "type": "string",
          "description": "The Procore company ID (required)"
        },
        "project_id": {
          "type": "string",
          "description": "The Procore project ID (required)"
        },
        "drawing_area_id": {
          "type": "string",
          "description": "Filter by drawing area ID (optional)"
        }
      }
    },
    "instruction": "Get drawing revisions for a Procore project. Make a GET request to /projects/{{project_id}}/drawing_revisions endpoint. Use Bearer token authentication. Accept these input parameters: project_id (required - used in URL path), company_id (required - added as query parameter), current (optional boolean - added as query parameter if provided), drawing_area_id (optional - added as query parameter if provided), page (optional - added as query parameter if provided), per_page (optional - added as query parameter if provided). Return the complete API response.",
    "outputTransform": "$",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "drawing_revisions": {
          "type": "array",
          "description": "List of drawing revisions for the project"
        }
      }
    },
    "description": "This tool retrieves the latest drawing revisions for a specific Procore project, using secure authentication to ensure data privacy. It provides comprehensive details of these revisions, including a complete list of all changes made to the drawings within the project."
  },
  "procore_project_users": {
    "id": "procore_project_users",
    "steps": [
      {
        "id": "fetchProjectUsers",
        "apiConfig": {
          "id": "fetchProjectUsers",
          "method": "GET",
          "headers": {
            "Content-Type": "application/json"
          },
          "urlHost": "https://api.procore.com",
          "urlPath": "/rest/v1.0/projects/{{project_id}}/project_users",
          "instruction": "Fetch active users for a Procore project",
          "queryParams": {
            "page": "{{page}}",
            "email": "{{email}}",
            "per_page": "{{per_page}}",
            "company_id": "{{company_id}}"
          },
          "authentication": "OAUTH2"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T22:48:16.443Z",
    "updatedAt": "2025-10-20T22:48:16.443Z",
    "inputSchema": {
      "type": "object",
      "required": ["project_id", "company_id"],
      "properties": {
        "page": {
          "type": "integer",
          "description": "Page number for pagination"
        },
        "email": {
          "type": "string",
          "description": "Filter users by email address"
        },
        "per_page": {
          "type": "integer",
          "description": "Number of items per page"
        },
        "company_id": {
          "type": "string",
          "description": "Procore company ID"
        },
        "project_id": {
          "type": "string",
          "description": "Procore project ID"
        }
      }
    },
    "instruction": "Build a Procore project users tool to list active users for a project.\n\nFetch project users:\n- HTTP GET to https://api.procore.com/rest/v1.0/projects/{project_id}/project_users\n- Replace {project_id} with inputs.project_id\n- Query parameters: company_id (required), page, per_page, email (optional filter from inputs)\n- OAuth Bearer authentication\n- Headers: Content-Type application/json\n- Return the project users array",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool connects to Procore to retrieve a list of active users for a specific project. It will return details of these users based on the project and company IDs provided, including options to filter by email and paginate results."
  },
  "procore_change_events": {
    "id": "procore_change_events",
    "steps": [
      {
        "id": "getChangeEvents",
        "apiConfig": {
          "id": "getChangeEvents",
          "method": "GET",
          "headers": {
            "Content-Type": "application/json"
          },
          "urlHost": "https://api.procore.com",
          "urlPath": "/rest/v1.0/projects/{{project_id}}/change_events",
          "instruction": "Fetch change events from Procore project with optional filters",
          "queryParams": {
            "page": "{{page}}",
            "status": "{{status}}",
            "per_page": "{{per_page}}",
            "company_id": "{{company_id}}",
            "updated_at_to": "{{updated_at_to}}",
            "updated_at_from": "{{updated_at_from}}"
          },
          "authentication": "OAUTH2"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T23:25:39.549Z",
    "updatedAt": "2025-10-20T23:25:39.549Z",
    "inputSchema": {
      "type": "object",
      "required": ["project_id", "company_id"],
      "properties": {
        "page": {
          "type": "integer",
          "description": "Page number for pagination"
        },
        "status": {
          "type": "string",
          "description": "Filter by change event status"
        },
        "per_page": {
          "type": "integer",
          "description": "Number of items per page"
        },
        "company_id": {
          "type": "string",
          "description": "Procore company ID"
        },
        "project_id": {
          "type": "string",
          "description": "Procore project ID"
        },
        "updated_at_to": {
          "type": "string",
          "description": "Filter by updated date to (ISO 8601 format)"
        },
        "updated_at_from": {
          "type": "string",
          "description": "Filter by updated date from (ISO 8601 format)"
        }
      }
    },
    "instruction": "Build a Procore change events tool to list change events with optional filters.\n\nFetch change events:\n- HTTP GET to https://api.procore.com/rest/v1.0/projects/{project_id}/change_events\n- Replace {project_id} with inputs.project_id\n- Query parameters: company_id (required), status, updated_at_from, updated_at_to, page, per_page (optional from inputs)\n- OAuth Bearer authentication\n- Headers: Content-Type application/json\n- Return the change events array",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool retrieves change events from a specific Procore project, allowing you to apply various filters such as status and update dates. It will return a detailed list of these events, providing insights into project modifications based on your specified criteria."
  },
  "confluence_attachment_upload": {
    "id": "confluence_attachment_upload",
    "steps": [
      {
        "id": "uploadAttachment",
        "apiConfig": {
          "id": "uploadAttachment",
          "method": "POST",
          "headers": {
            "Accept": "application/json",
            "Authorization": "Basic <<auth_email>>:<<auth_token>>"
          },
          "urlHost": "https://<<instance_subdomain>>.atlassian.net",
          "urlPath": "/wiki/rest/api/content/{page_id}/child/attachment",
          "instruction": "Upload an attachment to a Confluence page using POST /wiki/rest/api/content/{page_id}/child/attachment endpoint. Accept page_id (required), file_name (required), file_content (required), and comment (optional) as inputs. Use multipart/form-data to upload the file. Return the attachment details including id, title, type, download link, and metadata."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T03:43:16.078Z",
    "updatedAt": "2025-10-21T03:43:16.078Z",
    "inputSchema": {
      "type": "object",
      "required": ["page_id", "file_name", "file_content"],
      "properties": {
        "auth_email": {
          "type": "string",
          "description": "Email address for authentication"
        },
        "auth_token": {
          "type": "string",
          "description": "API key"
        },
        "instance_subdomain": {
          "type": "string",
          "description": "Domain prefix of your Confluence instance"
        },
        "comment": {
          "type": "string",
          "description": "Comment about the attachment"
        },
        "page_id": {
          "type": "string",
          "description": "ID of the page to attach the file to"
        },
        "file_name": {
          "type": "string",
          "description": "Name of the file to upload"
        },
        "file_content": {
          "type": "string",
          "description": "Content of the file"
        }
      }
    },
    "instruction": "Upload an attachment to a Confluence page using POST /wiki/rest/api/content/{page_id}/child/attachment endpoint. Accept page_id (required), file_name (required), file_content (required), and comment (optional) as inputs. Use multipart/form-data to upload the file. Return the attachment details including id, title, type, download link, and metadata.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool allows you to upload a file as an attachment to a specific Confluence page by providing the necessary details such as page ID, file name, and file content. It will return the attachment information, including its ID, title, type, download link, and additional metadata."
  },
  "confluence_page_tree": {
    "id": "confluence_page_tree",
    "steps": [
      {
        "id": "getChildPages",
        "apiConfig": {
          "id": "getChildPages",
          "method": "GET",
          "headers": {
            "Accept": "application/json",
            "Authorization": "Basic <<auth_email>>:<<auth_token>>"
          },
          "urlHost": "https://<<instance_subdomain>>.atlassian.net",
          "urlPath": "/wiki/rest/api/content/{page_id}/child/page",
          "instruction": "Fetch the page hierarchy for a Confluence page using GET /wiki/rest/api/content/{page_id}/child/page endpoint. Accept page_id (required) as input. Return the child pages with id, title, type, status, and _links. Include expand parameter to get descendants and ancestors if needed to show the full hierarchy."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T03:48:46.277Z",
    "updatedAt": "2025-10-21T03:48:46.277Z",
    "inputSchema": {
      "type": "object",
      "required": ["page_id"],
      "properties": {
        "auth_email": {
          "type": "string",
          "description": "Email address for authentication"
        },
        "auth_token": {
          "type": "string",
          "description": "API key"
        },
        "instance_subdomain": {
          "type": "string",
          "description": "Domain prefix of your Confluence instance"
        },
        "page_id": {
          "type": "string",
          "description": "ID of the parent page to fetch children for"
        }
      }
    },
    "instruction": "Fetch the page hierarchy for a Confluence page using GET /wiki/rest/api/content/{page_id}/child/page endpoint. Accept page_id (required) as input. Return the child pages with id, title, type, status, and _links. Include expand parameter to get descendants and ancestors if needed to show the full hierarchy.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool retrieves the hierarchy of pages under a specified Confluence page, giving you a structured overview of its child pages. It returns details such as the ID, title, type, status, and links of each child page, along with options to include additional hierarchical information if needed."
  },
  "servicenow_ticket_update": {
    "id": "servicenow_ticket_update",
    "steps": [
      {
        "id": "patchIncident",
        "apiConfig": {
          "id": "patchIncidentApi",
          "body": "{\"state\": \"${payload.state}\", \"priority\": \"${payload.priority}\", \"urgency\": \"${payload.urgency}\", \"impact\": \"${payload.impact}\", \"assigned_to\": \"${payload.assigned_to}\", \"assignment_group\": \"${payload.assignment_group}\", \"short_description\": \"${payload.short_description}\", \"description\": \"${payload.description}\", \"work_notes\": \"${payload.work_notes}\", \"close_notes\": \"${payload.close_notes}\", \"close_code\": \"${payload.close_code}\", \"resolution_code\": \"${payload.resolution_code}\"}",
          "method": "PATCH",
          "headers": {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "Authorization": "Basic <<servicenow_sim_username>>:<<servicenow_sim_password>>"
          },
          "urlHost": "https://<<servicenow_sim_instance>>.service-now.com",
          "urlPath": "/api/now/table/incident/${payload.sys_id}",
          "instruction": "Update an existing incident in ServiceNow using PATCH for partial updates",
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T04:01:22.080Z",
    "updatedAt": "2025-10-21T04:01:22.080Z",
    "inputSchema": {
      "type": "object",
      "required": ["sys_id"],
      "properties": {
        "servicenow_username": {
          "type": "string",
          "description": "Username for authentication"
        },
        "servicenow_password": {
          "type": "string",
          "description": "Password for authentication"
        },
        "servicenow_instance": {
          "type": "string",
          "description": "Domain prefix of your ServiceNow instance"
        },
        "state": {
          "type": "string",
          "description": "Incident state"
        },
        "impact": {
          "enum": ["1", "2", "3"],
          "type": "string",
          "description": "Business impact"
        },
        "sys_id": {
          "type": "string",
          "description": "The sys_id of the incident to update"
        },
        "urgency": {
          "enum": ["1", "2", "3"],
          "type": "string",
          "description": "Urgency level"
        },
        "priority": {
          "enum": ["1", "2", "3", "4", "5"],
          "type": "string",
          "description": "Priority level"
        },
        "close_code": {
          "type": "string",
          "description": "Closure classification code"
        },
        "work_notes": {
          "type": "string",
          "description": "Internal work notes"
        },
        "assigned_to": {
          "type": "string",
          "description": "sys_id of the user to assign the incident to"
        },
        "close_notes": {
          "type": "string",
          "description": "Notes about the resolution"
        },
        "description": {
          "type": "string",
          "description": "Detailed description of the incident"
        },
        "resolution_code": {
          "type": "string",
          "description": "Resolution classification code"
        },
        "assignment_group": {
          "type": "string",
          "description": "sys_id of the group to assign the incident to"
        },
        "short_description": {
          "type": "string",
          "description": "Brief description of the incident"
        }
      }
    },
    "instruction": "Update an existing incident in ServiceNow by sys_id. Accept sys_id (required) and any fields to update including state (optional), priority (optional, 1-5), urgency (optional, 1-3), impact (optional, 1-3), assigned_to (optional sys_id), assignment_group (optional sys_id), short_description (optional), description (optional), work_notes (optional), close_notes (optional), close_code (optional), resolution_code (optional). Use PATCH to /api/now/table/incident/{sys_id} endpoint for partial updates. Return the updated incident with all fields.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool allows you to update an existing incident in your ServiceNow system by providing the incident's unique identifier and any details you wish to modify, such as its state, priority, or assigned personnel. It will return the updated incident information, reflecting all the changes made to the incident's fields."
  },
  "servicenow_ticket_list": {
    "id": "servicenow_ticket_list",
    "steps": [
      {
        "id": "listIncidents",
        "apiConfig": {
          "id": "listIncidentsApi",
          "method": "GET",
          "headers": {
            "Accept": "application/json",
            "Authorization": "Basic <<servicenow_sim_username>>:<<servicenow_sim_password>>"
          },
          "urlHost": "https://<<servicenow_sim_instance>>.service-now.com",
          "urlPath": "/api/now/table/incident",
          "instruction": "List incidents from ServiceNow Table API with flexible query filtering and pagination",
          "queryParams": {
            "sysparm_limit": "${payload.limit || '100'}",
            "sysparm_query": "${payload.query || 'state=' + payload.state + (payload.priority ? '^priority=' + payload.priority : '') + (payload.assigned_to ? '^assigned_to=' + payload.assigned_to : '') + (payload.assignment_group ? '^assignment_group=' + payload.assignment_group : '') + (payload.caller_id ? '^caller_id=' + payload.caller_id : '') + (payload.category ? '^category=' + payload.category : '') + (payload.active ? '^active=' + payload.active : '')}",
            "sysparm_fields": "${payload.fields}",
            "sysparm_offset": "${payload.offset || '0'}",
            "sysparm_query_order": "${payload.order_direction === 'desc' ? 'ORDERBYDESC' : 'ORDERBY'}${payload.order_by}",
            "sysparm_display_value": "true",
            "sysparm_exclude_reference_link": "true"
          },
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T04:02:08.278Z",
    "updatedAt": "2025-10-21T04:02:08.278Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "servicenow_username": {
          "type": "string",
          "description": "Username for authentication"
        },
        "servicenow_password": {
          "type": "string",
          "description": "Password for authentication"
        },
        "servicenow_instance": {
          "type": "string",
          "description": "Domain prefix of your ServiceNow instance"
        },
        "limit": {
          "type": "string",
          "default": "100",
          "description": "Maximum number of records to return"
        },
        "query": {
          "type": "string",
          "description": "Custom encoded query string"
        },
        "state": {
          "type": "string",
          "description": "Filter by incident state"
        },
        "active": {
          "type": "string",
          "description": "Filter by active status"
        },
        "fields": {
          "type": "string",
          "description": "Comma-separated list of fields to return"
        },
        "offset": {
          "type": "string",
          "default": "0",
          "description": "Starting record index for pagination"
        },
        "category": {
          "type": "string",
          "description": "Filter by category"
        },
        "order_by": {
          "type": "string",
          "description": "Field name to sort results by"
        },
        "priority": {
          "type": "string",
          "description": "Filter by priority"
        },
        "caller_id": {
          "type": "string",
          "description": "Filter by caller sys_id"
        },
        "assigned_to": {
          "type": "string",
          "description": "Filter by assigned user sys_id"
        },
        "order_direction": {
          "enum": ["asc", "desc"],
          "type": "string",
          "description": "Sort direction"
        },
        "assignment_group": {
          "type": "string",
          "description": "Filter by assignment group sys_id"
        }
      }
    },
    "instruction": "List incidents from ServiceNow with flexible query filtering. Accept query (optional encoded query string using ServiceNow query syntax like \"state=1^priority=1\"), state (optional), priority (optional), assigned_to (optional), assignment_group (optional), caller_id (optional), category (optional), active (optional true/false), limit (optional, default 100), offset (optional, default 0), fields (optional comma-separated field list), order_by (optional field to sort by), order_direction (optional asc/desc). Use GET to /api/now/table/incident endpoint. Build sysparm_query from individual filters if query not provided. Support pagination and field selection. Return array of incidents with requested fields.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool connects to your ServiceNow account to retrieve a list of incidents based on specific criteria you set, such as state, priority, and assigned user. It returns detailed information about each incident, including your specified fields, allowing for easy sorting and filtering to meet your needs."
  },
  "servicenow_user_lookup": {
    "id": "servicenow_user_lookup",
    "steps": [
      {
        "id": "getSysUserRecords",
        "apiConfig": {
          "id": "getSysUserRecordsApi",
          "method": "GET",
          "headers": {
            "Accept": "application/json",
            "Authorization": "Basic <<servicenow_sim_username>>:<<servicenow_sim_password>>"
          },
          "urlHost": "https://<<servicenow_sim_instance>>.service-now.com",
          "urlPath": "/api/now/table/sys_user${payload.sys_id ? '/' + payload.sys_id : ''}",
          "instruction": "Retrieve user records from ServiceNow sys_user table with filtering",
          "queryParams": {
            "sysparm_limit": "${payload.limit || '100'}",
            "sysparm_query": "${payload.query || (payload.user_name ? 'user_name=' + payload.user_name : '') + (payload.email ? '^email=' + payload.email : '') + (payload.employee_number ? '^employee_number=' + payload.employee_number : '') + (payload.name ? '^nameLIKE' + payload.name : '') + (payload.active ? '^active=' + payload.active : '')}",
            "sysparm_fields": "${payload.fields}",
            "sysparm_offset": "${payload.offset || '0'}",
            "sysparm_display_value": "true",
            "sysparm_exclude_reference_link": "true"
          },
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T04:03:19.662Z",
    "updatedAt": "2025-10-21T04:03:19.662Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "servicenow_username": {
          "type": "string",
          "description": "Username for authentication"
        },
        "servicenow_password": {
          "type": "string",
          "description": "Password for authentication"
        },
        "servicenow_instance": {
          "type": "string",
          "description": "Domain prefix of your ServiceNow instance"
        },
        "name": {
          "type": "string",
          "description": "Filter by full name (contains search)"
        },
        "email": {
          "type": "string",
          "description": "Filter by email address"
        },
        "limit": {
          "type": "string",
          "default": "100",
          "description": "Maximum number of records to return (default: 100)"
        },
        "query": {
          "type": "string",
          "description": "Custom encoded query string using ServiceNow syntax"
        },
        "active": {
          "type": "string",
          "description": "Filter by active status (true/false)"
        },
        "fields": {
          "type": "string",
          "description": "Comma-separated list of fields to return"
        },
        "offset": {
          "type": "string",
          "default": "0",
          "description": "Starting record index for pagination (default: 0)"
        },
        "sys_id": {
          "type": "string",
          "description": "Unique sys_id of the user to retrieve"
        },
        "user_name": {
          "type": "string",
          "description": "Filter by ServiceNow username/login"
        },
        "employee_number": {
          "type": "string",
          "description": "Filter by employee number"
        }
      }
    },
    "instruction": "Retrieve user/employee records from ServiceNow sys_user table. Accept sys_id (optional), user_name (optional), email (optional), employee_number (optional), name (optional), active (optional true/false), query (optional custom query string), limit (optional, default 100), offset (optional, default 0), fields (optional comma-separated field list). Use GET to /api/now/table/sys_user endpoint. If sys_id is provided, fetch single user by appending /{sys_id} to URL path. Otherwise, use query parameters to filter users. Return user details including sys_id, user_name, email, name, first_name, last_name, title, department, manager, phone, mobile_phone, location, active status, roles, and other fields.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool fetches user or employee records directly from ServiceNow based on specified criteria such as name, email, or employee number. It returns detailed information about the users, including their roles, contact details, and active status."
  },
  "servicenow_asset_lookup": {
    "id": "servicenow_asset_lookup",
    "steps": [
      {
        "id": "getCmdbCiRecords",
        "apiConfig": {
          "id": "getCmdbCiRecordsApi",
          "method": "GET",
          "headers": {
            "Accept": "application/json",
            "Authorization": "Basic <<servicenow_sim_username>>:<<servicenow_sim_password>>"
          },
          "urlHost": "https://<<servicenow_sim_instance>>.service-now.com",
          "urlPath": "/api/now/table/cmdb_ci${payload.sys_id ? '/' + payload.sys_id : ''}",
          "instruction": "Retrieve CMDB CI records from ServiceNow cmdb_ci table with filtering",
          "queryParams": {
            "sysparm_limit": "${payload.limit || '100'}",
            "sysparm_query": "${payload.query || (payload.asset_tag ? 'asset_tag=' + payload.asset_tag : '') + (payload.serial_number ? '^serial_number=' + payload.serial_number : '') + (payload.name ? '^nameLIKE' + payload.name : '') + (payload.sys_class_name ? '^sys_class_name=' + payload.sys_class_name : '') + (payload.install_status ? '^install_status=' + payload.install_status : '') + (payload.operational_status ? '^operational_status=' + payload.operational_status : '') + (payload.assigned_to ? '^assigned_to=' + payload.assigned_to : '') + (payload.location ? '^location=' + payload.location : '')}",
            "sysparm_fields": "${payload.fields}",
            "sysparm_offset": "${payload.offset || '0'}",
            "sysparm_display_value": "true",
            "sysparm_exclude_reference_link": "true"
          },
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T04:03:57.088Z",
    "updatedAt": "2025-10-21T04:03:57.088Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "servicenow_username": {
          "type": "string",
          "description": "Username for authentication"
        },
        "servicenow_password": {
          "type": "string",
          "description": "Password for authentication"
        },
        "servicenow_instance": {
          "type": "string",
          "description": "Domain prefix of your ServiceNow instance"
        },
        "name": {
          "type": "string",
          "description": "Filter by CI name"
        },
        "limit": {
          "type": "string",
          "default": "100",
          "description": "Maximum number of records to return"
        },
        "query": {
          "type": "string",
          "description": "Custom encoded query string"
        },
        "fields": {
          "type": "string",
          "description": "Comma-separated list of fields to return"
        },
        "offset": {
          "type": "string",
          "default": "0",
          "description": "Starting record index for pagination"
        },
        "sys_id": {
          "type": "string",
          "description": "Unique sys_id of the CI to retrieve"
        },
        "location": {
          "type": "string",
          "description": "Filter by location sys_id or name"
        },
        "asset_tag": {
          "type": "string",
          "description": "Filter by asset tag identifier"
        },
        "assigned_to": {
          "type": "string",
          "description": "Filter by assigned user sys_id"
        },
        "serial_number": {
          "type": "string",
          "description": "Filter by serial number"
        },
        "install_status": {
          "type": "string",
          "description": "Filter by installation status"
        },
        "sys_class_name": {
          "type": "string",
          "description": "Filter by CI class type"
        },
        "operational_status": {
          "type": "string",
          "description": "Filter by operational status"
        }
      }
    },
    "instruction": "Retrieve IT asset and CMDB (Configuration Management Database) records from ServiceNow cmdb_ci table. Accept sys_id (optional), asset_tag (optional), serial_number (optional), name (optional), sys_class_name (optional CI class like cmdb_ci_computer, cmdb_ci_server, cmdb_ci_network_gear), install_status (optional), operational_status (optional), assigned_to (optional user sys_id), location (optional), query (optional custom query string), limit (optional, default 100), offset (optional, default 0), fields (optional comma-separated field list). Use GET to /api/now/table/cmdb_ci endpoint. If sys_id is provided, fetch single CI by appending /{sys_id} to URL path. Otherwise, use query parameters to filter CIs. Return asset details including sys_id, name, asset_tag, serial_number, model, manufacturer, sys_class_name, install_status, operational_status, assigned_to, location, support_group, cost, purchase_date, warranty_expiration, and other fields.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool retrieves detailed IT asset and configuration records from your ServiceNow database, allowing you to filter by various criteria such as asset tag, serial number, and location. It returns comprehensive asset information, including identifiers, status, and specifics like model and manufacturer."
  },
  "servicenow_change_request": {
    "id": "servicenow_change_request",
    "steps": [
      {
        "id": "createChangeRequest",
        "apiConfig": {
          "id": "createChangeRequestApi",
          "body": "{\"short_description\": \"${payload.short_description}\", \"description\": \"${payload.description}\", \"type\": \"${payload.type}\", \"priority\": \"${payload.priority}\", \"risk\": \"${payload.risk}\", \"impact\": \"${payload.impact}\", \"assignment_group\": \"${payload.assignment_group}\", \"assigned_to\": \"${payload.assigned_to}\", \"start_date\": \"${payload.start_date}\", \"end_date\": \"${payload.end_date}\", \"justification\": \"${payload.justification}\", \"implementation_plan\": \"${payload.implementation_plan}\", \"backout_plan\": \"${payload.backout_plan}\", \"test_plan\": \"${payload.test_plan}\"}",
          "method": "POST",
          "headers": {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "Authorization": "Basic <<servicenow_sim_username>>:<<servicenow_sim_password>>"
          },
          "urlHost": "https://<<servicenow_sim_instance>>.service-now.com",
          "urlPath": "/api/now/table/change_request",
          "instruction": "Create a new change request in ServiceNow (use when action=create)",
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T04:06:48.026Z",
    "updatedAt": "2025-10-21T04:06:48.026Z",
    "inputSchema": {
      "type": "object",
      "required": ["action"],
      "properties": {
        "servicenow_username": {
          "type": "string",
          "description": "Username for authentication"
        },
        "servicenow_password": {
          "type": "string",
          "description": "Password for authentication"
        },
        "servicenow_instance": {
          "type": "string",
          "description": "Domain prefix of your ServiceNow instance"
        },
        "risk": {
          "enum": ["1", "2", "3", "4"],
          "type": "string",
          "description": "Risk level (1=High, 2=Medium, 3=Low, 4=Very Low)"
        },
        "type": {
          "enum": ["standard", "normal", "emergency"],
          "type": "string",
          "description": "Change type: standard, normal, or emergency"
        },
        "limit": {
          "type": "string",
          "default": "100",
          "description": "Maximum number of records to return (default: 100, for fetch action)"
        },
        "query": {
          "type": "string",
          "description": "Custom encoded query string (for fetch action)"
        },
        "state": {
          "type": "string",
          "description": "Change state to filter by (for fetch action)"
        },
        "action": {
          "enum": ["create", "fetch"],
          "type": "string",
          "description": "Action to perform: 'create' to create new change request, 'fetch' to retrieve existing change requests"
        },
        "fields": {
          "type": "string",
          "description": "Comma-separated list of fields to return (for fetch action)"
        },
        "impact": {
          "enum": ["1", "2", "3"],
          "type": "string",
          "description": "Business impact (1=High, 2=Medium, 3=Low)"
        },
        "number": {
          "type": "string",
          "description": "Change request number to filter by (for fetch action)"
        },
        "offset": {
          "type": "string",
          "default": "0",
          "description": "Starting record index for pagination (default: 0, for fetch action)"
        },
        "sys_id": {
          "type": "string",
          "description": "sys_id of change request to fetch (for fetch action)"
        },
        "end_date": {
          "type": "string",
          "description": "Planned end date/time (format: YYYY-MM-DD HH:MM:SS)"
        },
        "priority": {
          "enum": ["1", "2", "3", "4", "5"],
          "type": "string",
          "description": "Priority level (1=Critical, 2=High, 3=Moderate, 4=Low, 5=Planning)"
        },
        "test_plan": {
          "type": "string",
          "description": "Testing plan to validate the change"
        },
        "start_date": {
          "type": "string",
          "description": "Planned start date/time (format: YYYY-MM-DD HH:MM:SS)"
        },
        "assigned_to": {
          "type": "string",
          "description": "sys_id of the user to assign the change to"
        },
        "description": {
          "type": "string",
          "description": "Detailed description of the change"
        },
        "backout_plan": {
          "type": "string",
          "description": "Plan to rollback if change fails"
        },
        "justification": {
          "type": "string",
          "description": "Business justification for the change"
        },
        "assignment_group": {
          "type": "string",
          "description": "sys_id of the group to assign the change to"
        },
        "short_description": {
          "type": "string",
          "description": "Brief description of the change (required for create)"
        },
        "implementation_plan": {
          "type": "string",
          "description": "Detailed implementation plan"
        }
      }
    },
    "instruction": "Create a new change request or fetch existing change requests from ServiceNow change_request table. Accept action (required, 'create' or 'fetch'), and for create: short_description (required), description (optional), type (optional, 'standard', 'normal', 'emergency'), priority (optional 1-5), risk (optional 1-4), impact (optional 1-3), assignment_group (optional sys_id), assigned_to (optional sys_id), start_date (optional), end_date (optional), justification (optional), implementation_plan (optional), backout_plan (optional), test_plan (optional). For fetch: sys_id (optional), number (optional), state (optional), type (optional), priority (optional), assigned_to (optional), assignment_group (optional), query (optional custom query string), limit (optional, default 100), offset (optional, default 0), fields (optional). If action is 'create', use POST to /api/now/table/change_request. If action is 'fetch' and sys_id provided, use GET to /api/now/table/change_request/{sys_id}. If action is 'fetch' without sys_id, use GET with query parameters. Return change request details.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool allows you to create a new change request or retrieve existing change requests from ServiceNow by providing the necessary details such as description, priority, and type. It will return the complete details of the change request, including its status and identifying information, from your ServiceNow account."
  },
  "servicenow_service_catalog": {
    "id": "servicenow_service_catalog",
    "steps": [
      {
        "id": "getCatalogItems",
        "apiConfig": {
          "id": "getCatalogItemsApi",
          "method": "GET",
          "headers": {
            "Accept": "application/json",
            "Authorization": "Basic <<servicenow_sim_username>>:<<servicenow_sim_password>>"
          },
          "urlHost": "https://<<servicenow_sim_instance>>.service-now.com",
          "urlPath": "/api/now/table/sc_cat_item${payload.sys_id ? '/' + payload.sys_id : ''}",
          "instruction": "Retrieve service catalog items from ServiceNow sc_cat_item table with filtering",
          "queryParams": {
            "sysparm_limit": "${payload.limit || '100'}",
            "sysparm_query": "${payload.query || (payload.name ? 'nameLIKE' + payload.name : '') + (payload.category ? '^category=' + payload.category : '') + (payload.active ? '^active=' + payload.active : '') + (payload.available_standalone ? '^available_standalone=' + payload.available_standalone : '')}",
            "sysparm_fields": "${payload.fields}",
            "sysparm_offset": "${payload.offset || '0'}",
            "sysparm_display_value": "true",
            "sysparm_exclude_reference_link": "true"
          },
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T04:07:21.629Z",
    "updatedAt": "2025-10-21T04:07:21.629Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "servicenow_username": {
          "type": "string",
          "description": "Username for authentication"
        },
        "servicenow_password": {
          "type": "string",
          "description": "Password for authentication"
        },
        "servicenow_instance": {
          "type": "string",
          "description": "Domain prefix of your ServiceNow instance"
        },
        "name": {
          "type": "string",
          "description": "Filter by catalog item name"
        },
        "limit": {
          "type": "string",
          "default": "100",
          "description": "Maximum number of records to return"
        },
        "query": {
          "type": "string",
          "description": "Custom encoded query string"
        },
        "active": {
          "type": "string",
          "description": "Filter by active status"
        },
        "fields": {
          "type": "string",
          "description": "Comma-separated list of fields to return"
        },
        "offset": {
          "type": "string",
          "default": "0",
          "description": "Starting record index for pagination"
        },
        "sys_id": {
          "type": "string",
          "description": "Unique sys_id of the catalog item"
        },
        "category": {
          "type": "string",
          "description": "Filter by category sys_id"
        },
        "available_standalone": {
          "type": "string",
          "description": "Filter by standalone availability"
        }
      }
    },
    "instruction": "Query service catalog items from ServiceNow sc_cat_item table. Accept sys_id (optional), name (optional), category (optional sys_id), active (optional true/false), available_standalone (optional true/false), query (optional custom query string), limit (optional, default 100), offset (optional, default 0), fields (optional comma-separated field list). Use GET to /api/now/table/sc_cat_item endpoint. If sys_id is provided, fetch single catalog item by appending /{sys_id} to URL path. Otherwise, use query parameters to filter catalog items. Return catalog item details including sys_id, name, short_description, description, category, price, picture, active, available_standalone, and other fields.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool retrieves detailed information about service catalog items from your ServiceNow account, allowing you to filter results based on various criteria like name, category, and active status. It will return comprehensive details of each catalog item, such as its ID, name, description, price, and availability status."
  },
  "salesforce_query_accounts": {
    "id": "salesforce_query_accounts",
    "steps": [
      {
        "id": "queryAccounts",
        "apiConfig": {
          "id": "queryAccounts",
          "method": "GET",
          "headers": {
            "Authorization": "Bearer <<salesforce_demo_api_key>>"
          },
          "urlHost": "https://<<salesforce_instance>>.my.salesforce.com",
          "urlPath": "/services/data/v59.0/query",
          "instruction": "Query accounts from Salesforce using SOQL",
          "queryParams": {
            "q": "SELECT Id, Name, Industry, AnnualRevenue, Phone, BillingCity FROM Account"
          },
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T04:32:07.233Z",
    "updatedAt": "2025-10-22T01:49:47.322Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "salesforce_demo_api_key": {
          "type": "string",
          "description": "API key"
        },
        "salesforce_instance": {
          "type": "string",
          "description": "Domain prefix"
        },
        "industry": {
          "type": "string",
          "description": "Filter accounts by industry"
        },
        "minRevenue": {
          "type": "number",
          "description": "Filter accounts with a minimum annual revenue"
        }
      }
    },
    "instruction": "Query accounts from Salesforce with optional filters for industry and minRevenue",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool connects to Salesforce to retrieve information about accounts, such as their name, industry, and revenue. It can apply optional filters to narrow down the results based on specific industry types or minimum revenue, providing a list of matching accounts and their details."
  },
  "salesforce_fetch_tasks": {
    "id": "salesforce_fetch_tasks",
    "steps": [
      {
        "id": "fetchTasks",
        "apiConfig": {
          "id": "fetchTasks",
          "method": "GET",
          "headers": {
            "Authorization": "Bearer <<salesforce_demo_api_key>>"
          },
          "urlHost": "https://<<salesforce_instance>>.my.salesforce.com",
          "urlPath": "/services/data/v59.0/query",
          "instruction": "Query tasks from Salesforce using SOQL",
          "queryParams": {
            "q": "SELECT Id, Subject, Status, Priority, ActivityDate, WhoId, WhatId, OwnerId FROM Task"
          },
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T04:34:42.515Z",
    "updatedAt": "2025-10-22T01:49:52.068Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "salesforce_demo_api_key": {
          "type": "string",
          "description": "API key"
        },
        "salesforce_instance": {
          "type": "string",
          "description": "Domain prefix"
        },
        "status": {
          "type": "string",
          "description": "Filter tasks by their current status"
        },
        "assignedTo": {
          "type": "string",
          "description": "Filter tasks by the assigned person's ID"
        }
      }
    },
    "instruction": "Fetch tasks from Salesforce with optional filters for status and assignedTo",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool retrieves tasks from your Salesforce account, allowing you to filter them by status or the person they're assigned to. It will return detailed information about each task, including its subject, status, priority, and more."
  },
  "salesforce_insert_activity": {
    "id": "salesforce_insert_activity",
    "steps": [
      {
        "id": "createTask",
        "apiConfig": {
          "id": "createTask",
          "body": "{\"Subject\": \"{{payload.subject}}\", \"ActivityDate\": \"{{payload.activityDate}}\", \"Status\": \"{{payload.status}}\", \"Priority\": \"{{payload.priority}}\", \"WhatId\": \"{{payload.relatedToId}}\"}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<salesforce_demo_api_key>>"
          },
          "urlHost": "https://<<salesforce_instance>>.my.salesforce.com",
          "urlPath": "/services/data/v59.0/sobjects/Task",
          "instruction": "Create a new task in Salesforce",
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T04:34:51.917Z",
    "updatedAt": "2025-10-22T01:49:59.702Z",
    "inputSchema": {
      "type": "object",
      "required": ["subject"],
      "properties": {
        "salesforce_demo_api_key": {
          "type": "string",
          "description": "API key"
        },
        "salesforce_instance": {
          "type": "string",
          "description": "Domain prefix"
        },
        "status": {
          "type": "string",
          "description": "The current status of the task"
        },
        "subject": {
          "type": "string",
          "description": "The main topic or title of the task"
        },
        "priority": {
          "type": "string",
          "description": "The importance level of the task"
        },
        "relatedToId": {
          "type": "string",
          "description": "The ID of the related record"
        },
        "activityDate": {
          "type": "string",
          "description": "The date the task is scheduled for"
        }
      }
    },
    "instruction": "Insert an activity (task) in Salesforce with subject, activityDate, status, priority, and relatedToId",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool seamlessly integrates with Salesforce to create a new task based on the provided details such as subject, activity date, status, priority, and a related ID. It will return the complete task information directly from your Salesforce account, ensuring all activity records are up-to-date."
  },
  "salesforce_search_records": {
    "id": "salesforce_search_records",
    "steps": [
      {
        "id": "searchRecordsWithSOSL",
        "apiConfig": {
          "id": "searchRecordsWithSOSL",
          "method": "GET",
          "headers": {
            "Authorization": "Bearer <<salesforce_demo_api_key>>"
          },
          "urlHost": "https://<<salesforce_instance>>.my.salesforce.com",
          "urlPath": "/services/data/v59.0/search",
          "instruction": "Search records using SOSL",
          "queryParams": {
            "q": "FIND {{{payload.searchTerm}}} IN ALL FIELDS RETURNING Account(Id, Name), Contact(Id, Name), Lead(Id, Name)"
          },
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T04:37:52.671Z",
    "updatedAt": "2025-10-22T01:50:10.048Z",
    "inputSchema": {
      "type": "object",
      "required": ["searchTerm"],
      "properties": {
        "salesforce_demo_api_key": {
          "type": "string",
          "description": "API key"
        },
        "salesforce_instance": {
          "type": "string",
          "description": "Domain prefix"
        },
        "searchTerm": {
          "type": "string",
          "description": "The keyword or phrase you want to search for"
        },
        "objectTypes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of Salesforce object types to include in the search"
        }
      }
    },
    "instruction": "Search records in Salesforce using SOSL with searchTerm and objectTypes",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool searches your Salesforce database to find records that match a given search term across all fields. It returns a list of matching accounts, contacts, and leads with their IDs and names."
  },
  "salesforce_get_sobject_metadata": {
    "id": "salesforce_get_sobject_metadata",
    "steps": [
      {
        "id": "getSObjectMetadata",
        "apiConfig": {
          "id": "getSObjectMetadata",
          "method": "GET",
          "headers": {
            "Authorization": "Bearer <<salesforce_demo_api_key>>"
          },
          "urlHost": "https://<<salesforce_instance>>.my.salesforce.com",
          "urlPath": "/services/data/v59.0/sobjects/{{payload.objectType}}/describe",
          "instruction": "Retrieve metadata for a Salesforce SObject",
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T04:37:59.449Z",
    "updatedAt": "2025-10-22T01:50:16.236Z",
    "inputSchema": {
      "type": "object",
      "required": ["objectType"],
      "properties": {
        "salesforce_demo_api_key": {
          "type": "string",
          "description": "API key"
        },
        "salesforce_instance": {
          "type": "string",
          "description": "Domain prefix"
        },
        "objectType": {
          "type": "string",
          "description": "Type of Salesforce SObject you want metadata for"
        }
      }
    },
    "instruction": "Get metadata for a specific Salesforce SObject type",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool connects to Salesforce to retrieve detailed metadata about a specific SObject type. It will return comprehensive information about the SObject, including field definitions and data types, directly from your Salesforce account."
  },
  "slack_delete_message": {
    "id": "slack_delete_message",
    "steps": [
      {
        "id": "deleteSlackMessage",
        "apiConfig": {
          "id": "deleteSlackMessage",
          "body": "{ \"channel\": \"<<channel>>\", \"ts\": \"<<ts>>\" }",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<slack_api_key_api_token>>"
          },
          "urlHost": "https://slack.com/api",
          "urlPath": "/chat.delete",
          "instruction": "Delete a Slack message using chat.delete. Requires channel and ts (timestamp) in the body."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T05:13:38.646Z",
    "updatedAt": "2025-10-22T00:15:19.206Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "ts": {
              "type": "string",
              "description": "The timestamp of the message to be deleted"
            },
            "channel": {
              "type": "string",
              "description": "The channel ID where the message is located"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "slack_api_key_api_token": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Delete a Slack message. Make a POST request to /chat.delete with Authorization header: Bearer <<slack_api_key_api_token>>. Headers: Content-Type: application/json. Body should accept: channel (required), ts (required, message timestamp).",
    "outputTransform": "(sourceData) => { return sourceData.deleteSlackMessage; }",
    "systemIds": [],
    "description": "This tool allows you to delete a specific message from a Slack channel by providing the message's timestamp and channel details. It will confirm the deletion by returning the operation's outcome directly from your Slack account."
  },
  "slack_list_channel_members": {
    "id": "slack_list_channel_members",
    "steps": [
      {
        "id": "getChannelMembers",
        "apiConfig": {
          "id": "getChannelMembers",
          "method": "GET",
          "headers": {
            "Authorization": "Bearer <<slack_api_key_api_token>>"
          },
          "urlHost": "https://slack.com/api",
          "urlPath": "/conversations.members",
          "instruction": "Get the list of members in a Slack channel using conversations.members endpoint. Requires channel ID as query parameter and Bearer token in Authorization header.",
          "queryParams": {
            "channel": "<<channel>>"
          }
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T05:14:59.089Z",
    "updatedAt": "2025-10-22T00:15:26.102Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "channel": {
              "type": "string",
              "description": "The ID of the Slack channel"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "slack_api_key_api_token": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "List members of a Slack channel. Make a GET request to /conversations.members with Authorization header: Bearer <<slack_api_key_api_token>>. Include query parameter: channel (required, the channel ID).",
    "outputTransform": "(sourceData) => { return sourceData.getChannelMembers; }",
    "systemIds": [],
    "description": "This tool connects to Slack to retrieve a list of all members in a specified channel. It will provide detailed information about each member, such as their names and user IDs, directly from your Slack workspace."
  },
  "asana_list_tasks_in_project": {
    "id": "asana_list_tasks_in_project",
    "steps": [
      {
        "id": "getAllTasksInProject",
        "apiConfig": {
          "id": "getAllTasksInProject",
          "method": "GET",
          "headers": {
            "Authorization": "Bearer <<asana_apiKey>>"
          },
          "urlHost": "https://app.asana.com",
          "urlPath": "/api/1.0/projects/<<project_id>>/tasks",
          "pagination": {
            "type": "CURSOR_BASED",
            "pageSize": "100",
            "cursorPath": "next_page.offset"
          },
          "instruction": "Get all tasks in the specified Asana project with details, using cursor-based pagination with offset, 100 per page, and return gid, name, completed, due_on, assignee.name, notes.",
          "queryParams": {
            "limit": "100",
            "opt_fields": "gid,name,completed,due_on,assignee.name,notes"
          }
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T19:02:42.321Z",
    "updatedAt": "2025-10-21T19:02:42.321Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "The unique identifier for the Asana project"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "asana_apiKey": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "List all tasks in a specific Asana project.\n\nStep 1: Get all tasks from the project\n- Make a GET request to https://app.asana.com/api/1.0/projects/{project_id}/tasks\n- Use Bearer token authentication with the API key\n- Query parameters: opt_fields=gid,name,completed,due_on,assignee.name,notes\n- Implement cursor-based pagination using offset parameter, incrementing by 100 until we get fewer than 100 results\n\nReturn the result as an array of tasks with their details.",
    "outputTransform": "(sourceData) => {\n  const pages = sourceData.getAllTasksInProject?.results;\n  if (!Array.isArray(pages)) return [];\n\n  const allTasks = pages.flatMap((page) =>\n    Array.isArray(page?.data) ? page.data : [],\n  );\n  return allTasks;\n};\n",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool retrieves all tasks from a specified Asana project, providing detailed information such as task ID, name, completion status, due date, assignee's name, and notes. It returns a comprehensive list of these tasks directly from your Asana account."
  },
  "notion_create_page": {
    "id": "notion_create_page",
    "steps": [
      {
        "id": "createNotionPage",
        "apiConfig": {
          "id": "create_page",
          "body": "{ \"parent\": { \"page_id\": \"<<parent_id>>\" }, \"properties\": { \"title\": { \"title\": [ { \"text\": { \"content\": \"<<title>>\" } } ] } }, \"children\": [ { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"<<text>>\" } } ] } } ] }",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<api_key>>",
            "Notion-Version": "2022-06-28"
          },
          "urlHost": "https://api.notion.com",
          "urlPath": "/v1/pages",
          "instruction": "Create a new page in Notion workspace"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T05:42:48.638Z",
    "updatedAt": "2025-10-21T05:42:48.638Z",
    "inputSchema": {
      "type": "object",
      "required": ["payload"],
      "properties": {
        "payload": {
          "type": "object",
          "required": ["api_key", "title", "parent_id"],
          "properties": {
            "api_key": {
              "type": "string",
              "description": "Your API key"
            },
            "title": {
              "type": "string",
              "description": "The title of the new page"
            },
            "text": {
              "type": "string",
              "description": "The text of the new page first paragraph"
            },
            "parent_id": {
              "type": "string",
              "description": "The ID of the parent page or database where the new page will be created"
            }
          }
        }
      }
    },
    "instruction": "Create a page in Notion. POST to /pages with headers: Notion-Version: 2022-06-28, Authorization: Bearer <<api_key>>, Content-Type: application/json. Body: {\"parent\": {\"page_id\": parent_id}, \"properties\": {\"title\": {\"title\": [{\"text\": {\"content\": title}}]}}, \"children\": content}. Accept parent_id, title, and optional content array as input.",
    "outputTransform": "(sourceData) => { return sourceData.createNotionPage.data; }",
    "systemIds": [],
    "description": "This tool allows you to create a new page within your Notion workspace by specifying a parent page or database, a title, and optionally, content for the page. It will return the details of the newly created page, ensuring it's seamlessly added to your existing Notion setup."
  },
  "notion_update_page": {
    "id": "notion_update_page",
    "steps": [
      {
        "id": "updateNotionPage",
        "apiConfig": {
          "id": "update_page",
          "body": "{\"properties\": {{properties}}, \"archived\": {{archived}}}",
          "method": "PATCH",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<notion_sg_testing_api_key>>",
            "Notion-Version": "2022-06-28"
          },
          "urlHost": "https://api.notion.com",
          "urlPath": "/v1/pages/{{page_id}}",
          "instruction": "Update a Notion page properties or archive status"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T05:42:53.243Z",
    "updatedAt": "2025-10-21T05:42:53.243Z",
    "inputSchema": {
      "type": "object",
      "required": ["page_id"],
      "properties": {
        "notion_sg_testing_api_key": {
          "type": "string",
          "description": "Your API key"
        },
        "page_id": {
          "type": "string",
          "description": "The ID of the page to update"
        },
        "archived": {
          "type": "boolean",
          "description": "Optional boolean to archive or unarchive the page"
        },
        "properties": {
          "type": "object",
          "description": "Optional properties object to update page metadata"
        }
      }
    },
    "instruction": "Update a Notion page. PATCH to /pages/{page_id} with headers: Notion-Version: 2022-06-28, Authorization: Bearer <<notion_sg_testing_api_key>>, Content-Type: application/json. Body can include: {\"properties\": properties, \"archived\": archived}. Accept page_id, optional properties object for metadata updates, and optional archived boolean as input.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool connects to Notion to update or archive a specific page. It will modify the page's properties or status and return the updated details based on your Notion account."
  },
  "notion_query_database": {
    "id": "notion_query_database",
    "steps": [
      {
        "id": "queryNotionDatabase",
        "apiConfig": {
          "id": "query_database",
          "body": "{\"filter\": {{filter}}, \"sorts\": {{sorts}}, \"start_cursor\": \"{{start_cursor}}\", \"page_size\": {{page_size}}}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<notion_sg_testing_api_key>>",
            "Notion-Version": "2022-06-28"
          },
          "urlHost": "https://api.notion.com",
          "urlPath": "/v1/databases/{{database_id}}/query",
          "instruction": "Query a Notion database with optional filters and sorting"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T05:42:57.944Z",
    "updatedAt": "2025-10-21T05:42:57.944Z",
    "inputSchema": {
      "type": "object",
      "required": ["database_id"],
      "properties": {
        "notion_sg_testing_api_key": {
          "type": "string",
          "description": "Your API key"
        },
        "sorts": {
          "type": "array",
          "items": {
            "type": "object"
          },
          "description": "Optional array of sort objects to sort results"
        },
        "filter": {
          "type": "object",
          "description": "Optional filter object to filter database entries"
        },
        "page_size": {
          "type": "number",
          "description": "Optional number of results per page (max 100)"
        },
        "database_id": {
          "type": "string",
          "description": "The ID of the database to query"
        },
        "start_cursor": {
          "type": "string",
          "description": "Optional cursor for pagination"
        }
      }
    },
    "instruction": "Query a Notion database. POST to /databases/{database_id}/query with headers: Notion-Version: 2022-06-28, Authorization: Bearer <<notion_sg_testing_api_key>>, Content-Type: application/json. Body can include: {\"filter\": filter, \"sorts\": sorts, \"start_cursor\": start_cursor, \"page_size\": page_size}. Accept database_id as required, and optional filter object, sorts array, start_cursor string, and page_size number as inputs.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool interacts with your Notion workspace to retrieve specific database entries based on your chosen filters and sorting preferences. It will return a structured list of results from the specified database, tailored to the criteria you set, such as the number of results per page and pagination options."
  },
  "notion_search": {
    "id": "notion_search",
    "steps": [
      {
        "id": "searchNotionWorkspace",
        "apiConfig": {
          "id": "search_workspace",
          "body": "{\"query\": \"{{query}}\", \"filter\": {{filter}}, \"sort\": {{sort}}, \"start_cursor\": \"{{start_cursor}}\", \"page_size\": {{page_size}}}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<notion_sg_testing_api_key>>",
            "Notion-Version": "2022-06-28"
          },
          "urlHost": "https://api.notion.com",
          "urlPath": "/v1/search",
          "instruction": "Search across pages and databases in the Notion workspace using the /search endpoint"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T05:49:01.669Z",
    "updatedAt": "2025-10-21T05:49:01.669Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "notion_sg_testing_api_key": {
          "type": "string",
          "description": "Your API key"
        },
        "sort": {
          "type": "object",
          "description": "Optional sort object to sort results"
        },
        "query": {
          "type": "string",
          "description": "Optional search query text"
        },
        "filter": {
          "type": "object",
          "description": "Optional filter object to filter by type (page or database)"
        },
        "page_size": {
          "type": "number",
          "description": "Optional number of results per page (max 100)"
        },
        "start_cursor": {
          "type": "string",
          "description": "Optional cursor for pagination"
        }
      }
    },
    "instruction": "Search across pages and databases in a Notion workspace. POST to /search with headers: Notion-Version: 2022-06-28, Authorization: Bearer <<notion_sg_testing_api_key>>, Content-Type: application/json. Body can include: {\"query\": query, \"filter\": filter, \"sort\": sort, \"start_cursor\": start_cursor, \"page_size\": page_size}. Accept optional query string, filter object (with value \"page\" or \"database\"), sort object, start_cursor, and page_size as inputs.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool searches through pages and databases in a Notion workspace to find information based on your specified criteria. It will return a list of search results that match your query, with options to filter, sort, and paginate the data."
  },
  "notion_create_database": {
    "id": "notion_create_database",
    "steps": [
      {
        "id": "createDatabase",
        "apiConfig": {
          "id": "create_database",
          "body": "{\"parent\": {\"page_id\": \"{{parent_id}}\"}, \"title\": [{\"type\": \"text\", \"text\": {\"content\": \"{{title}}\"}}], \"properties\": {{properties}}}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<notion_sg_testing_api_key>>",
            "Notion-Version": "2022-06-28"
          },
          "urlHost": "https://api.notion.com",
          "urlPath": "/v1/databases",
          "instruction": "Create a new database in Notion"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T05:51:36.479Z",
    "updatedAt": "2025-10-21T05:51:36.479Z",
    "inputSchema": {
      "type": "object",
      "required": ["parent_id", "title", "properties"],
      "properties": {
        "notion_sg_testing_api_key": {
          "type": "string",
          "description": "Your API key"
        },
        "title": {
          "type": "string",
          "description": "The name/title of the new database"
        },
        "parent_id": {
          "type": "string",
          "description": "The ID of the parent page where the database will be created"
        },
        "properties": {
          "type": "object",
          "description": "Object defining the database schema with property names and types (e.g., title, select, multi_select, date, etc.)"
        }
      }
    },
    "instruction": "Create a new database in Notion. POST to /databases with headers: Notion-Version: 2022-06-28, Authorization: Bearer <<notion_sg_testing_api_key>>, Content-Type: application/json. Body: {\"parent\": {\"page_id\": parent_id}, \"title\": [{\"type\": \"text\", \"text\": {\"content\": title}}], \"properties\": properties}. Accept parent_id (page ID where database will be created), title (database name), and properties (object defining database schema with property types) as inputs.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool seamlessly integrates with Notion to create a new database within a specified page. It will return the full details of the newly created database, including its name and schema, directly from your Notion account."
  },
  "notion_update_database": {
    "id": "notion_update_database",
    "steps": [
      {
        "id": "updateDatabaseSchema",
        "apiConfig": {
          "id": "update_database",
          "body": "{\"title\": {{title}}, \"description\": {{description}}, \"properties\": {{properties}}}",
          "method": "PATCH",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<notion_sg_testing_api_key>>",
            "Notion-Version": "2022-06-28"
          },
          "urlHost": "https://api.notion.com",
          "urlPath": "/v1/databases/{{database_id}}",
          "instruction": "Update a Notion database schema or properties"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T05:51:43.778Z",
    "updatedAt": "2025-10-21T05:51:43.778Z",
    "inputSchema": {
      "type": "object",
      "required": ["database_id"],
      "properties": {
        "notion_sg_testing_api_key": {
          "type": "string",
          "description": "Your API key"
        },
        "title": {
          "type": "array",
          "items": {
            "type": "object"
          },
          "description": "Optional array of rich text objects to update the database title"
        },
        "properties": {
          "type": "object",
          "description": "Optional object to update database properties/schema (add, modify, or remove fields)"
        },
        "database_id": {
          "type": "string",
          "description": "The ID of the database to update"
        },
        "description": {
          "type": "array",
          "items": {
            "type": "object"
          },
          "description": "Optional array of rich text objects to update the database description"
        }
      }
    },
    "instruction": "Update a Notion database schema or properties. PATCH to /databases/{database_id} with headers: Notion-Version: 2022-06-28, Authorization: Bearer <<notion_sg_testing_api_key>>, Content-Type: application/json. Body can include: {\"title\": title, \"description\": description, \"properties\": properties}. Accept database_id as required, and optional title array, description array, and properties object to update the database schema.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool updates the structure or details of a Notion database by modifying its title, description, or properties as specified. It returns the updated database schema directly from your Notion account."
  },
  "notion_append_block": {
    "id": "notion_append_block",
    "steps": [
      {
        "id": "appendBlockChildren",
        "apiConfig": {
          "id": "append_blocks",
          "body": "{\"children\": {{children}}}",
          "method": "PATCH",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<notion_sg_testing_api_key>>",
            "Notion-Version": "2022-06-28"
          },
          "urlHost": "https://api.notion.com",
          "urlPath": "/v1/blocks/{{block_id}}/children",
          "instruction": "Append blocks to a Notion page or block"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T05:51:51.075Z",
    "updatedAt": "2025-10-21T05:51:51.075Z",
    "inputSchema": {
      "type": "object",
      "required": ["block_id", "children"],
      "properties": {
        "notion_sg_testing_api_key": {
          "type": "string",
          "description": "Your API key"
        },
        "block_id": {
          "type": "string",
          "description": "The ID of the page or block to append children to"
        },
        "children": {
          "type": "array",
          "items": {
            "type": "object"
          },
          "description": "Array of block objects to append (e.g., paragraphs, headings, lists, etc.)"
        }
      }
    },
    "instruction": "Append blocks (text or other content) to a Notion page. PATCH to /blocks/{block_id}/children with headers: Notion-Version: 2022-06-28, Authorization: Bearer <<notion_sg_testing_api_key>>, Content-Type: application/json. Body: {\"children\": children}. Accept block_id (page ID or block ID to append to) and children (array of block objects) as inputs.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool allows you to add new content, like text or lists, to a specific section of your Notion workspace. It will update the designated page or block with the new information you provide and return the updated content details directly from Notion."
  },
  "asana_add_comment_to_task": {
    "id": "asana_add_comment_to_task",
    "steps": [
      {
        "id": "addCommentToTask",
        "apiConfig": {
          "id": "addCommentToTask",
          "body": "{\"data\": {\"text\": \"<<comment_text>>\"}}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<asana_apiKey>>"
          },
          "urlHost": "https://app.asana.com",
          "urlPath": "/api/1.0/tasks/<<task_id>>/stories",
          "instruction": "Create a story (comment) on the specified Asana task and return the created story details."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T19:07:58.107Z",
    "updatedAt": "2025-10-21T19:07:58.107Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "task_id": {
              "type": "string",
              "description": "The unique identifier for the Asana task"
            },
            "comment_text": {
              "type": "string",
              "description": "The text of the comment to add to the task"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "asana_apiKey": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Add a comment (story) to an Asana task.\n\nStep 1: Create a story/comment on the task\n- Make a POST request to https://app.asana.com/api/1.0/tasks/{task_id}/stories\n- Use Bearer token authentication with the API key\n- Headers: Content-Type: application/json\n- Body: {\"data\": {\"text\": \"{comment_text}\"}}\n\nReturn the created story/comment details.",
    "outputTransform": "(sourceData) => { return sourceData.addCommentToTask; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool allows you to add a comment to an Asana task directly, ensuring your team stays informed and organized. It returns the details of the newly created comment, giving you a quick overview of what was added to the task."
  },
  "asana_list_sections_in_project": {
    "id": "asana_list_sections_in_project",
    "steps": [
      {
        "id": "getAllSections",
        "apiConfig": {
          "id": "getAllSections",
          "method": "GET",
          "headers": {
            "Authorization": "Bearer <<asana_apiKey>>"
          },
          "urlHost": "https://app.asana.com",
          "urlPath": "/api/1.0/projects/<<project_id>>/sections",
          "pagination": {
            "type": "CURSOR_BASED",
            "pageSize": "100",
            "cursorPath": "next_page.offset"
          },
          "instruction": "Get all sections in the specified Asana project with their gid, name, and created_at. Use cursor-based pagination with the offset parameter to retrieve all results.",
          "queryParams": {
            "opt_fields": "gid,name,created_at"
          }
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T19:08:01.013Z",
    "updatedAt": "2025-10-21T19:08:01.013Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "The unique identifier for the Asana project"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "asana_apiKey": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "List all sections in a specific Asana project.\n\nStep 1: Get all sections from the project\n- Make a GET request to https://app.asana.com/api/1.0/projects/{project_id}/sections\n- Use Bearer token authentication with the API key\n- Query parameters: opt_fields=gid,name,created_at\n- Implement cursor-based pagination using offset parameter until we get all results\n\nReturn the result as an array of sections with their details.",
    "outputTransform": "(sourceData) => {\n  const results = sourceData.getAllSections?.results;\n  if (!Array.isArray(results)) return [];\n\n  const sections = results.flatMap((page) =>\n    Array.isArray(page.data) ? page.data : [],\n  );\n  return sections;\n};\n",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool connects to Asana to retrieve all the sections within a specified project. It will return a list of sections, providing details such as their unique IDs, names, and creation dates."
  },
  "slack_post_message": {
    "id": "slack_post_message",
    "steps": [
      {
        "id": "postSlackMessage",
        "apiConfig": {
          "id": "postSlackMessage",
          "body": "{\"channel\": \"<<channel>>\", \"text\": \"<<text>>\"}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<slack_api_key_api_token>>"
          },
          "urlHost": "https://slack.com",
          "urlPath": "/api/chat.postMessage",
          "instruction": "Post a message to a Slack channel using /chat.postMessage. Accepts channel (required), text (required), and optional fields like thread_ts, blocks, attachments."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T04:58:12.607Z",
    "updatedAt": "2025-10-22T00:14:07.975Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "The message content you want to post"
            },
            "channel": {
              "type": "string",
              "description": "The Slack channel where the message will be posted"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "slack_api_key_api_token": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Post a message to a Slack channel. Make a POST request to /chat.postMessage with Authorization header: Bearer <<slack_api_key_api_token>>. Headers: Content-Type: application/json. Body should accept: channel (required), text (required), and optional fields like thread_ts, blocks, attachments.",
    "outputTransform": "(sourceData) => { return { ok: sourceData.postSlackMessage.ok, channel: sourceData.postSlackMessage.channel, ts: sourceData.postSlackMessage.ts, message: sourceData.postSlackMessage.message }; }",
    "systemIds": [],
    "description": "This tool sends a message directly to a specified Slack channel. It will return confirmation details, including whether the message was successfully sent, the channel it was posted to, and a timestamp of the message."
  },
  "slack_add_reaction": {
    "id": "slack_add_reaction",
    "steps": [
      {
        "id": "addReactionToMessage",
        "apiConfig": {
          "id": "addReactionToMessage",
          "body": "{ \"channel\": \"<<channel>>\", \"timestamp\": \"<<timestamp>>\", \"name\": \"<<name>>\" }",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<slack_api_key_api_token>>"
          },
          "urlHost": "https://slack.com/api",
          "urlPath": "/reactions.add",
          "instruction": "Add a reaction emoji to a Slack message using /reactions.add. Requires channel, timestamp, and emoji name (without colons)."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T05:08:04.145Z",
    "updatedAt": "2025-10-22T00:14:15.694Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Emoji name without colons"
            },
            "channel": {
              "type": "string",
              "description": "Channel ID where the message is located"
            },
            "timestamp": {
              "type": "string",
              "description": "Timestamp of the message to react to"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "slack_api_key_api_token": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Add a reaction emoji to a Slack message. Make a POST request to /reactions.add with Authorization header: Bearer <<slack_api_key_api_token>>. Headers: Content-Type: application/json. Body should accept: channel (required), timestamp (required, the message ts), name (required, emoji name without colons).",
    "outputTransform": "(sourceData) => { return sourceData.addReactionToMessage; }",
    "systemIds": [],
    "description": "This tool allows you to add an emoji reaction to a specific message in Slack by specifying the channel, timestamp, and emoji name. It will return confirmation that the reaction has been successfully added to the message, using your Slack account credentials."
  },
  "slack_thread_reply": {
    "id": "slack_thread_reply",
    "steps": [
      {
        "id": "replyToSlackThread",
        "apiConfig": {
          "id": "replyToSlackThread",
          "body": "{ \"channel\": \"<<channel>>\", \"text\": \"<<text>>\", \"thread_ts\": \"<<thread_ts>>\" }",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<slack_api_key_api_token>>"
          },
          "urlHost": "https://slack.com/api",
          "urlPath": "/chat.postMessage",
          "instruction": "Reply to a Slack thread by posting a message to a channel with a parent message timestamp (thread_ts)."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T05:10:36.073Z",
    "updatedAt": "2025-10-22T00:15:06.058Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "The message you want to post"
            },
            "channel": {
              "type": "string",
              "description": "The Slack channel ID"
            },
            "thread_ts": {
              "type": "string",
              "description": "The timestamp of the parent message"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "slack_api_key_api_token": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Reply to a Slack thread. Make a POST request to /chat.postMessage with Authorization header: Bearer <<slack_api_key_api_token>>. Headers: Content-Type: application/json. Body should accept: channel (required), text (required), thread_ts (required, the parent message timestamp).",
    "outputTransform": "(sourceData) => { return { result: sourceData.replyToSlackThread }; }",
    "systemIds": [],
    "description": "This tool allows you to post a reply directly to a specific thread in a Slack channel. It will send your message and return confirmation of the successful post along with relevant details from Slack."
  },
  "slack_update_message": {
    "id": "slack_update_message",
    "steps": [
      {
        "id": "updateSlackMessage",
        "apiConfig": {
          "id": "updateSlackMessage",
          "body": "{ \"channel\": \"<<channel>>\", \"ts\": \"<<ts>>\", \"text\": \"<<text>>\" }",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<slack_api_key_api_token>>"
          },
          "urlHost": "https://slack.com/api",
          "urlPath": "/chat.update",
          "instruction": "Update a Slack message in a channel using /chat.update. Requires channel, ts (timestamp), and new text."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T05:12:48.000Z",
    "updatedAt": "2025-10-22T00:15:13.166Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "ts": {
              "type": "string",
              "description": "Message timestamp"
            },
            "text": {
              "type": "string",
              "description": "New text for the message"
            },
            "channel": {
              "type": "string",
              "description": "Channel identifier"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "slack_api_key_api_token": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Update a Slack message. Make a POST request to /chat.update with Authorization header: Bearer <<slack_api_key_api_token>>. Headers: Content-Type: application/json. Body should accept: channel (required), ts (required, message timestamp), text (required, new text).",
    "outputTransform": "(sourceData) => { return { ok: sourceData.updateSlackMessage?.ok, message: sourceData.updateSlackMessage?.message, error: sourceData.updateSlackMessage?.error }; }",
    "systemIds": [],
    "description": "This tool allows you to update an existing message in a Slack channel by providing the channel name, message timestamp, and the new message text. It will return confirmation of the update along with any error messages if the update was not successful."
  },
  "workday_update_worker": {
    "id": "workday_update_worker",
    "steps": [
      {
        "id": "updateWorker",
        "apiConfig": {
          "id": "update_worker_endpoint",
          "body": "{{updateData}}",
          "method": "PATCH",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<workday_api_key>>"
          },
          "urlHost": "https://demo-tenant.workday.com",
          "urlPath": "/ccx/api/v1/<<workday_tenant>>/workers/{{workerId}}",
          "instruction": "Update worker information in Workday",
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-22T00:26:44.124Z",
    "updatedAt": "2025-10-22T00:28:00.888Z",
    "inputSchema": {
      "type": "object",
      "required": ["workerId", "updateData"],
      "properties": {
        "workday_api_key": {
          "type": "string",
          "description": "Your Workday API key"
        },
        "workday_tenant": {
          "type": "string",
          "description": "Your Workday tenant"
        },
        "workerId": {
          "type": "string",
          "description": "Worker ID to update"
        },
        "updateData": {
          "type": "object",
          "description": "Data for updating worker details"
        }
      }
    },
    "instruction": "Update employee details or job data in Workday HCM.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool connects to Workday to update an employee's information, such as personal details or job data, in the system. It returns the updated worker's details, confirming the changes made in your Workday account."
  },
  "workday_get_worker": {
    "id": "workday_get_worker",
    "steps": [
      {
        "id": "getWorker",
        "apiConfig": {
          "id": "get_worker_endpoint",
          "method": "GET",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<workday_api_key>>"
          },
          "urlHost": "https://demo-tenant.workday.com",
          "urlPath": "/ccx/api/v1/<<workday_tenant>>/workers/{{workerId}}",
          "instruction": "Get worker details from Workday",
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-22T00:26:47.089Z",
    "updatedAt": "2025-10-22T00:28:06.036Z",
    "inputSchema": {
      "type": "object",
      "required": ["workerId"],
      "properties": {
        "workday_api_key": {
          "type": "string",
          "description": "Your Workday API key"
        },
        "workday_tenant": {
          "type": "string",
          "description": "Your Workday tenant"
        },
        "workerId": {
          "type": "string",
          "description": "Worker ID to retrieve full worker details"
        }
      }
    },
    "instruction": "Retrieve worker information by ID from Workday HCM.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool connects to Workday to fetch detailed information about a specific worker using their Worker ID. It will return comprehensive worker details, including personal information, employment data, job information, and contact details, directly from your Workday system."
  },
  "workday_create_requisition": {
    "id": "workday_create_requisition",
    "steps": [
      {
        "id": "createRequisition",
        "apiConfig": {
          "id": "create_requisition_endpoint",
          "body": "{{requisitionData}}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<workday_api_key>>"
          },
          "urlHost": "https://demo-tenant.workday.com",
          "urlPath": "/ccx/api/v1/<<workday_tenant>>/staffing/jobRequisitions",
          "instruction": "Create a job requisition in Workday",
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-22T00:26:54.352Z",
    "updatedAt": "2025-10-22T00:28:20.504Z",
    "inputSchema": {
      "type": "object",
      "required": ["requisitionData"],
      "properties": {
        "workday_api_key": {
          "type": "string",
          "description": "Your Workday API key"
        },
        "workday_tenant": {
          "type": "string",
          "description": "Your Workday tenant"
        },
        "requisitionData": {
          "type": "object",
          "description": "Complete requisition data including job title, department, position details, hiring manager, location, job description, required qualifications, and any other requisition fields"
        }
      }
    },
    "instruction": "Create a new job requisition in Workday HCM.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool seamlessly integrates with Workday to create a new job requisition. It returns the complete details of the requisition, including job title, department, and other key information entered during the process."
  },
  "workday_get_requisition": {
    "id": "workday_get_requisition",
    "steps": [
      {
        "id": "getRequisition",
        "apiConfig": {
          "id": "get_requisition_endpoint",
          "method": "GET",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<workday_api_key>>"
          },
          "urlHost": "https://demo-tenant.workday.com",
          "urlPath": "/ccx/api/v1/<<workday_tenant>>/staffing/jobRequisitions/{{requisitionId}}",
          "instruction": "Get job requisition details from Workday",
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-22T00:26:56.817Z",
    "updatedAt": "2025-10-22T00:26:56.817Z",
    "inputSchema": {
      "type": "object",
      "required": ["requisitionId"],
      "properties": {
        "workday_api_key": {
          "type": "string",
          "description": "Your Workday API key"
        },
        "workday_tenant": {
          "type": "string",
          "description": "Your Workday tenant"
        },
        "requisitionId": {
          "type": "string",
          "description": "Requisition ID to retrieve"
        }
      }
    },
    "instruction": "Get details of a specific job requisition from Workday HCM system using API key authentication.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool connects to the Workday system to retrieve detailed information about a specific job requisition. It will return the full set of requisition details, such as job title, department, and hiring status, using the provided requisition ID."
  },
  "workday_submit_time": {
    "id": "workday_submit_time",
    "steps": [
      {
        "id": "submitTime",
        "apiConfig": {
          "id": "submit_time_endpoint",
          "body": "{\"workerId\": \"{{workerId}}\", \"date\": \"{{date}}\", \"hours\": {{hours}}, \"timeType\": \"{{timeType}}\", \"timeEntryData\": {{timeEntryData}}}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<workday_api_key>>"
          },
          "urlHost": "https://demo-tenant.workday.com",
          "urlPath": "/ccx/api/v1/<<workday_tenant>>/time/timeEntries",
          "instruction": "Submit time entry in Workday",
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-22T00:27:01.424Z",
    "updatedAt": "2025-10-22T00:27:01.424Z",
    "inputSchema": {
      "type": "object",
      "required": ["workerId", "date", "hours"],
      "properties": {
        "workday_api_key": {
          "type": "string",
          "description": "Your Workday API key"
        },
        "workday_tenant": {
          "type": "string",
          "description": "Your Workday tenant"
        },
        "date": {
          "type": "string",
          "description": "Date for time entry in ISO format"
        },
        "hours": {
          "type": "number",
          "description": "Number of hours"
        },
        "timeType": {
          "type": "string",
          "description": "Type of time (regular, overtime, etc.)"
        },
        "workerId": {
          "type": "string",
          "description": "Worker ID submitting time"
        },
        "timeEntryData": {
          "type": "object",
          "description": "Additional time entry data"
        }
      }
    },
    "instruction": "Submit time entry for a worker in Workday HCM system using API key authentication.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool submits a worker's time entry directly into the Workday system using an API key for secure access. It will record the date, hours worked, and type of time (such as regular or overtime), and return confirmation of the submission."
  },
  "workday_get_pay_slip": {
    "id": "workday_get_pay_slip",
    "steps": [
      {
        "id": "getPaySlip",
        "apiConfig": {
          "id": "get_payslip_endpoint",
          "method": "GET",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<workday_api_key>>"
          },
          "urlHost": "https://demo-tenant.workday.com",
          "urlPath": "/ccx/api/v1/<<workday_tenant>>/payroll/paySlips/{{paySlipId}}",
          "instruction": "Get pay slip from Workday",
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-22T00:27:04.042Z",
    "updatedAt": "2025-10-22T00:27:04.042Z",
    "inputSchema": {
      "type": "object",
      "required": ["paySlipId"],
      "properties": {
        "workday_api_key": {
          "type": "string",
          "description": "Your Workday API key"
        },
        "workday_tenant": {
          "type": "string",
          "description": "Your Workday tenant"
        },
        "paySlipId": {
          "type": "string",
          "description": "Pay slip ID to retrieve"
        }
      }
    },
    "instruction": "Get pay slip information for a worker from Workday HCM system using API key authentication.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool retrieves a worker's pay slip directly from the Workday system using secure API key authentication. It will provide complete details of the pay slip, including all relevant financial information associated with the specified pay slip ID."
  },
  "workday_create_worker": {
    "id": "workday_create_worker",
    "steps": [
      {
        "id": "createWorker",
        "apiConfig": {
          "id": "create_worker_endpoint",
          "body": "{{workerData}}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<workday_api_key>>"
          },
          "urlHost": "https://demo-tenant.workday.com",
          "urlPath": "/ccx/api/v1/<<workday_tenant>>/workers",
          "instruction": "Create a new worker in Workday HCM",
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-22T00:26:41.128Z",
    "updatedAt": "2025-10-22T00:27:55.242Z",
    "inputSchema": {
      "type": "object",
      "required": ["workerData"],
      "properties": {
        "workday_api_key": {
          "type": "string",
          "description": "Your Workday API key"
        },
        "workday_tenant": {
          "type": "string",
          "description": "Your Workday tenant"
        },
        "workerData": {
          "type": "object",
          "description": "Complete worker data object including personal info, contact details, employment data, and any other required fields per Workday API specification"
        }
      }
    },
    "instruction": "Create a new worker record in Workday HCM.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool integrates with Workday to create a new employee profile using the provided worker details. It will return the complete profile information of the newly created worker directly from your Workday system."
  },
  "workday_list_workers": {
    "id": "workday_list_workers",
    "steps": [
      {
        "id": "listWorkers",
        "apiConfig": {
          "id": "list_workers_endpoint",
          "method": "GET",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<workday_api_key>>"
          },
          "urlHost": "https://demo-tenant.workday.com",
          "urlPath": "/ccx/api/v1/<<workday_tenant>>/workers",
          "pagination": {
            "type": "OFFSET_BASED",
            "pageSize": "100"
          },
          "instruction": "List all workers from Workday",
          "queryParams": {
            "type": "{{type}}",
            "limit": "{{limit}}",
            "offset": "{{offset}}"
          },
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-22T00:26:50.378Z",
    "updatedAt": "2025-10-22T00:28:14.176Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "workday_api_key": {
          "type": "string",
          "description": "Your Workday API key"
        },
        "workday_tenant": {
          "type": "string",
          "description": "Your Workday tenant"
        },
        "type": {
          "type": "string",
          "description": "Filter by worker type (e.g., 'Employee', 'Contingent_Worker', or leave empty for all)"
        },
        "limit": {
          "type": "string",
          "description": "Number of workers to return per page (default: 100)"
        },
        "offset": {
          "type": "string",
          "description": "Offset for pagination (default: 0)"
        }
      }
    },
    "instruction": "List all active workers in the organization from Workday HCM.",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool connects to Workday to retrieve a list of all active workers in your organization. It will return detailed information about each worker, which can be filtered by worker type and paginated for easier review."
  },
  "coupa_get_supplier": {
    "id": "coupa_get_supplier",
    "steps": [
      {
        "id": "getSupplier",
        "apiConfig": {
          "id": "getSupplierById",
          "method": "GET",
          "headers": {
            "Accept": "application/json",
            "X-COUPA-API-KEY": "<<coupa_sim_api_key>>"
          },
          "urlHost": "https://<<coupa_sim_coupa_instance>>.coupahost.com",
          "urlPath": "/api/suppliers/{{payload.supplier_id}}",
          "instruction": "Get a specific supplier by ID from Coupa",
          "queryParams": {
            "exported": "{{payload.exported !== false}}"
          },
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T01:22:41.856Z",
    "updatedAt": "2025-10-22T01:02:54.975Z",
    "inputSchema": {
      "type": "object",
      "required": ["supplier_id"],
      "properties": {
        "coupa_sim_api_key": {
          "type": "string",
          "description": "API key"
        },
        "coupa_sim_coupa_instance": {
          "type": "string",
          "description": "Coupa instance"
        },
        "exported": {
          "type": "boolean",
          "default": true,
          "description": "Include all fields in the response"
        },
        "supplier_id": {
          "type": "number",
          "description": "The ID of the supplier to retrieve"
        }
      }
    },
    "instruction": "Get a specific supplier by ID from Coupa using API key authentication",
    "outputTransform": "$",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "description": "Supplier ID"
        },
        "name": {
          "type": "string",
          "description": "Supplier name"
        },
        "status": {
          "type": "string",
          "description": "Supplier status"
        },
        "contacts": {
          "type": "array",
          "items": {
            "type": "object"
          },
          "description": "Supplier contact information"
        },
        "created_at": {
          "type": "string",
          "description": "Creation timestamp"
        },
        "updated_at": {
          "type": "string",
          "description": "Last update timestamp"
        }
      }
    },
    "description": "This tool retrieves detailed information about a specific supplier from your Coupa system using an API key. It will return the supplier's ID, name, status, contact information, and timestamps for creation and last update."
  },
  "coupa_list_purchase_order_lines": {
    "id": "coupa_list_purchase_order_lines",
    "steps": [
      {
        "id": "getPurchaseOrderLines",
        "apiConfig": {
          "id": "listPurchaseOrderLines",
          "method": "GET",
          "headers": {
            "Accept": "application/json",
            "X-COUPA-API-KEY": "<<coupa_sim_api_key>>"
          },
          "urlHost": "https://<<coupa_sim_coupa_instance>>.coupahost.com",
          "urlPath": "/api/purchase_order_lines",
          "pagination": {
            "type": "OFFSET_BASED",
            "pageSize": "50"
          },
          "instruction": "Get list of purchase order lines from Coupa with pagination and filtering",
          "queryParams": {
            "limit": "{{payload.limit || 50}}",
            "offset": "{{payload.offset || 0}}",
            "status": "{{payload.status}}",
            "exported": "{{payload.exported !== false}}",
            "order_header_id": "{{payload.order_header_id}}"
          },
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T01:23:44.886Z",
    "updatedAt": "2025-10-22T01:03:12.211Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "coupa_sim_api_key": {
          "type": "string",
          "description": "API key"
        },
        "coupa_sim_coupa_instance": {
          "type": "string",
          "description": "Coupa instance"
        },
        "limit": {
          "type": "number",
          "default": 50,
          "description": "Number of results to return"
        },
        "offset": {
          "type": "number",
          "default": 0,
          "description": "Number of results to skip for pagination"
        },
        "status": {
          "type": "string",
          "description": "Filter by line status"
        },
        "exported": {
          "type": "boolean",
          "default": true,
          "description": "Include all fields in the response"
        },
        "order_header_id": {
          "type": "number",
          "description": "Filter by purchase order ID"
        }
      }
    },
    "instruction": "List purchase order lines from Coupa using API key authentication with pagination and filtering support",
    "outputTransform": "$",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "page": {
          "type": "integer",
          "description": "Current page number"
        },
        "per_page": {
          "type": "integer",
          "description": "Items per page"
        },
        "total_count": {
          "type": "integer",
          "description": "Total number of purchase order lines"
        },
        "purchase_order_lines": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "integer",
                "description": "Purchase order line ID"
              },
              "item": {
                "type": "object",
                "properties": {
                  "id": {
                    "type": "integer"
                  },
                  "name": {
                    "type": "string"
                  },
                  "item_number": {
                    "type": "string"
                  }
                },
                "description": "Item information"
              },
              "price": {
                "type": "number",
                "description": "Unit price"
              },
              "total": {
                "type": "number",
                "description": "Line total amount"
              },
              "status": {
                "type": "string",
                "description": "Line status"
              },
              "line_num": {
                "type": "integer",
                "description": "Line number in the purchase order"
              },
              "quantity": {
                "type": "number",
                "description": "Quantity ordered"
              },
              "created_at": {
                "type": "string",
                "description": "Creation timestamp"
              },
              "updated_at": {
                "type": "string",
                "description": "Last update timestamp"
              },
              "description": {
                "type": "string",
                "description": "Line item description"
              },
              "purchase_order": {
                "type": "object",
                "properties": {
                  "id": {
                    "type": "integer"
                  }
                },
                "description": "Parent purchase order reference"
              }
            }
          },
          "description": "Array of purchase order line objects"
        }
      }
    },
    "description": "This tool retrieves a list of purchase order lines from Coupa, allowing you to apply filters like status and purchase order ID, and supports pagination for easier data management. It returns detailed information about each purchase order line, such as item details, prices, quantities, and status."
  },
  "coupa_search_requisitions": {
    "id": "coupa_search_requisitions",
    "steps": [
      {
        "id": "searchRequisitions",
        "apiConfig": {
          "id": "searchRequisitions",
          "method": "GET",
          "headers": {
            "Accept": "application/json",
            "X-COUPA-API-KEY": "<<coupa_sim_api_key>>"
          },
          "urlHost": "https://<<coupa_sim_coupa_instance>>.coupahost.com",
          "urlPath": "/api/requisitions",
          "pagination": {
            "type": "OFFSET_BASED",
            "pageSize": "50"
          },
          "instruction": "Search requisitions from Coupa with pagination and filtering",
          "queryParams": {
            "limit": "{{payload.limit || 50}}",
            "offset": "{{payload.offset || 0}}",
            "status": "{{payload.status}}",
            "exported": "{{payload.exported !== false}}",
            "created_at[gt]": "{{payload.created_at_gt}}",
            "updated_at[gt]": "{{payload.updated_at_gt}}",
            "requested_by_id": "{{payload.requested_by_id}}"
          },
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-20T01:24:50.193Z",
    "updatedAt": "2025-10-22T01:08:47.712Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "coupa_sim_api_key": {
          "type": "string",
          "description": "API key"
        },
        "coupa_sim_coupa_instance": {
          "type": "string",
          "description": "Coupa instance"
        },
        "limit": {
          "type": "number",
          "default": 50,
          "description": "Number of results to return"
        },
        "offset": {
          "type": "number",
          "default": 0,
          "description": "Number of results to skip for pagination"
        },
        "status": {
          "type": "string",
          "description": "Filter by requisition status"
        },
        "exported": {
          "type": "boolean",
          "default": true,
          "description": "Include all fields in the response"
        },
        "created_at_gt": {
          "type": "string",
          "description": "Filter by created date greater than"
        },
        "updated_at_gt": {
          "type": "string",
          "description": "Filter by updated date greater than"
        },
        "requested_by_id": {
          "type": "number",
          "description": "Filter by requester user ID"
        }
      }
    },
    "instruction": "Search and list requisitions from Coupa using API key authentication with pagination and filtering support",
    "outputTransform": "$",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "page": {
          "type": "integer",
          "description": "Current page number"
        },
        "per_page": {
          "type": "integer",
          "description": "Items per page"
        },
        "total_count": {
          "type": "integer",
          "description": "Total number of requisitions"
        },
        "requisitions": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "integer",
                "description": "Requisition ID"
              },
              "total": {
                "type": "number",
                "description": "Total requisition amount"
              },
              "status": {
                "type": "string",
                "description": "Requisition status (e.g., pending_approval, approved, ordered)"
              },
              "currency": {
                "type": "object",
                "properties": {
                  "code": {
                    "type": "string"
                  }
                },
                "description": "Currency information"
              },
              "requester": {
                "type": "object",
                "properties": {
                  "id": {
                    "type": "integer"
                  },
                  "email": {
                    "type": "string"
                  },
                  "login": {
                    "type": "string"
                  },
                  "fullname": {
                    "type": "string"
                  }
                },
                "description": "Requester information"
              },
              "created_at": {
                "type": "string",
                "description": "Creation timestamp"
              },
              "updated_at": {
                "type": "string",
                "description": "Last update timestamp"
              },
              "need_by_date": {
                "type": "string",
                "description": "Date items are needed by"
              },
              "requisition_number": {
                "type": "string",
                "description": "Requisition number"
              }
            }
          },
          "description": "Array of requisition objects"
        }
      }
    },
    "description": "This tool accesses your Coupa account to search and retrieve detailed information about requisitions based on specified criteria such as status, requester, and date filters. It will provide a comprehensive list of requisitions including their IDs, amounts, statuses, and requester details."
  },
  "salesforce_create_lead": {
    "id": "salesforce_create_lead",
    "steps": [
      {
        "id": "createLead",
        "apiConfig": {
          "id": "createLead",
          "body": "{\"FirstName\": \"{{payload.firstName}}\", \"LastName\": \"{{payload.lastName}}\", \"Company\": \"{{payload.company}}\", \"Email\": \"{{payload.email}}\"}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<salesforce_demo_api_key>>"
          },
          "urlHost": "https://<<salesforce_instance>>.my.salesforce.com",
          "urlPath": "/services/data/v59.0/sobjects/Lead",
          "instruction": "Create a new lead in Salesforce",
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T04:31:58.629Z",
    "updatedAt": "2025-10-22T01:49:36.106Z",
    "inputSchema": {
      "type": "object",
      "required": ["firstName", "lastName", "company"],
      "properties": {
        "salesforce_demo_api_key": {
          "type": "string",
          "description": "API key"
        },
        "salesforce_instance": {
          "type": "string",
          "description": "Domain prefix"
        },
        "email": {
          "type": "string",
          "description": "Lead's email address"
        },
        "company": {
          "type": "string",
          "description": "Lead's company name"
        },
        "lastName": {
          "type": "string",
          "description": "Lead's last name"
        },
        "firstName": {
          "type": "string",
          "description": "Lead's first name"
        }
      }
    },
    "instruction": "Create a lead in Salesforce with firstName, lastName, company, and email",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool seamlessly integrates with Salesforce to create a new lead using the provided first name, last name, company, and email details. It will return confirmation of the newly created lead, including all entered details directly from your Salesforce account."
  },
  "salesforce_update_opportunity": {
    "id": "salesforce_update_opportunity",
    "steps": [
      {
        "id": "updateOpportunity",
        "apiConfig": {
          "id": "updateOpportunity",
          "body": "{\"StageName\": \"{{payload.stageName}}\", \"Amount\": {{payload.amount}}, \"CloseDate\": \"{{payload.closeDate}}\"}",
          "method": "PATCH",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<salesforce_demo_api_key>>"
          },
          "urlHost": "https://<<salesforce_instance>>.my.salesforce.com",
          "urlPath": "/services/data/v59.0/sobjects/Opportunity/{{payload.opportunityId}}",
          "instruction": "Update an existing opportunity in Salesforce",
          "authentication": "HEADER"
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-21T04:32:03.416Z",
    "updatedAt": "2025-10-22T01:49:44.242Z",
    "inputSchema": {
      "type": "object",
      "required": ["opportunityId"],
      "properties": {
        "salesforce_demo_api_key": {
          "type": "string",
          "description": "API key"
        },
        "salesforce_instance": {
          "type": "string",
          "description": "Domain prefix"
        },
        "amount": {
          "type": "number",
          "description": "The total value of the opportunity"
        },
        "closeDate": {
          "type": "string",
          "description": "The expected closing date of the opportunity"
        },
        "stageName": {
          "type": "string",
          "description": "The current stage of the opportunity"
        },
        "opportunityId": {
          "type": "string",
          "description": "The unique identifier for the opportunity"
        }
      }
    },
    "instruction": "Update an opportunity in Salesforce with opportunityId, stageName, amount, and closeDate",
    "outputTransform": "$",
    "systemIds": [],
    "description": "This tool seamlessly updates an existing opportunity in your Salesforce account by modifying details such as stage name, amount, and close date. It returns the updated information for the specified opportunity, ensuring your Salesforce data is current and accurate."
  },
  "elevenlabs_text_to_speech_stream": {
    "id": "elevenlabs_text_to_speech_stream",
    "steps": [
      {
        "id": "streamSpeechAudio",
        "apiConfig": {
          "id": "streamSpeechAudio",
          "body": "{ \"text\": \"<<text>>\"<< (sourceData) => sourceData.model_id ? \", \\\"model_id\\\": \\\"\" + sourceData.model_id + \"\\\"\" : \"\" >><< (sourceData) => sourceData.voice_settings ? \", \\\"voice_settings\\\": \" + JSON.stringify(sourceData.voice_settings) : \"\" >> }",
          "method": "POST",
          "headers": {
            "xi-api-key": "<<elevenlabs_api_key>>",
            "Content-Type": "application/json"
          },
          "urlHost": "https://api.elevenlabs.io/v1",
          "urlPath": "/text-to-speech/<<voice_id>>/stream",
          "instruction": "Stream speech audio in real-time as text is being processed, allowing for lower latency playback. This streaming endpoint is ideal for applications requiring immediate audio feedback like chatbots, voice assistants, or interactive applications. Accepts voice_id to specify the voice, text content to convert, optional model_id to select the TTS model (e.g., eleven_monolingual_v1, eleven_multilingual_v2, eleven_turbo_v2, eleven_turbo_v2_5), and optional voice_settings object containing stability (0-1, controls voice consistency), similarity_boost (0-1, controls voice matching accuracy), style (0-1, controls expressiveness), and use_speaker_boost (boolean, enhances clarity). Returns streaming audio chunks in MP3 format that can be played as they arrive, reducing perceived latency compared to the standard text-to-speech endpoint."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-22T04:41:18.716Z",
    "updatedAt": "2025-10-22T04:55:58.936Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "Text to convert to speech"
            },
            "model_id": {
              "type": "string",
              "description": "Optional: Choose a TTS model"
            },
            "voice_id": {
              "type": "string",
              "description": "Voice ID for speech generation"
            },
            "voice_settings": {
              "type": "object",
              "description": "Optional: Adjust voice output settings"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "elevenlabs_api_key": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Stream speech audio in real-time while text is being processed, reducing latency for immediate playback. This tool uses the /text-to-speech/{voice_id}/stream endpoint with POST method. Ideal for conversational AI, voice assistants, and interactive applications where low latency is critical. Provide voice_id (from elevenlabs_list_voices), text to convert, optional model_id to select the TTS model (turbo models are faster), and optional voice_settings object with stability (0-1, higher = more consistent but less expressive), similarity_boost (0-1, higher = closer to original voice), style (0-1, higher = more dramatic), and use_speaker_boost (true/false for enhanced clarity). Returns streaming audio chunks in MP3 format for progressive playback. Character usage counts toward quota.",
    "outputTransform": "(sourceData) => { return sourceData.streamSpeechAudio; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool converts text into speech audio in real-time, allowing for immediate playback as the text is processed. It provides streaming audio in MP3 format, ideal for use in applications like chatbots and voice assistants where quick audio feedback is essential."
  },
  "elevenlabs_get_voice": {
    "id": "elevenlabs_get_voice",
    "steps": [
      {
        "id": "getVoiceDetails",
        "apiConfig": {
          "id": "getVoiceDetails",
          "method": "GET",
          "headers": {
            "xi-api-key": "<<elevenlabs_api_key>>"
          },
          "urlHost": "https://api.elevenlabs.io/v1",
          "urlPath": "/voices/<<voice_id>>",
          "instruction": "Get comprehensive detailed information about a specific voice by its unique voice_id. This endpoint retrieves in-depth metadata including the voice name, category (premade/cloned/generated/professional), complete label set (gender, age, accent, language, use_case, descriptive characteristics), preview_url for audio samples, detailed description, fine_tuning configuration and status across different models, current voice settings (stability, similarity_boost, style, use_speaker_boost values), sharing permissions if applicable, high_quality_base_model_ids showing which models are optimized for this voice, verified_languages with locale and accent information, voice_verification status, creation timestamps, and ownership details. Use this when you need full specifications of a particular voice, want to check its compatibility with specific models, or need to retrieve its configured settings before making TTS requests."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-22T04:41:26.341Z",
    "updatedAt": "2025-10-22T04:56:29.228Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "voice_id": {
              "type": "string",
              "description": "The unique voice ID to retrieve detailed information for"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "elevenlabs_api_key": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Get comprehensive detailed information about a specific voice by its ID from ElevenLabs. This tool uses the GET /voices/{voice_id} endpoint to retrieve in-depth metadata for a single voice. Provide the voice_id parameter (obtainable from elevenlabs_list_voices). The response includes: voice_id, name, category (premade/cloned/generated/professional), complete labels (gender, age, accent, language, use_case, descriptive traits), preview_url (audio sample), detailed description, fine_tuning status and capabilities across different models, current settings object (stability, similarity_boost, style, use_speaker_boost, speed values), sharing configuration, high_quality_base_model_ids (optimized models list), verified_languages array with model_id/accent/locale/preview_url per language, voice_verification status, safety_control settings, permission_on_resource, ownership flags (is_owner, is_legacy, is_mixed), and timestamps (favorited_at_unix, created_at_unix). Essential for checking voice specifications, model compatibility, and configured parameters before TTS generation.",
    "outputTransform": "(sourceData) => { return sourceData.getVoiceDetails; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool retrieves detailed information about a specific voice from ElevenLabs by using the voice's unique ID. It provides comprehensive metadata including the voice's name, category, characteristics, sample preview, and settings, helping you understand its specifications and compatibility with various models."
  },
  "elevenlabs_design_voice": {
    "id": "elevenlabs_design_voice",
    "steps": [
      {
        "id": "designVoice",
        "apiConfig": {
          "id": "designVoice",
          "body": "{\n  \"text\": \"<<text>>\",\n  \"gender\": \"<<gender>>\",\n  \"accent\": \"<<accent>>\"\n}",
          "method": "POST",
          "headers": {
            "xi-api-key": "<<elevenlabs_api_key>>",
            "Content-Type": "application/json"
          },
          "urlHost": "https://api.elevenlabs.io/v1",
          "urlPath": "/voice-generation/generate-voice",
          "instruction": "Create a new synthetic voice design based on provided parameters including a text description of the desired voice characteristics, gender specification (male, female, or neutral), age category (young, middle_aged, old), and accent preference (american, british, african, australian, indian, etc.). This endpoint uses ElevenLabs' voice generation AI to synthesize a completely new voice matching your specifications. The system analyzes your parameters and generates a unique voice profile that can be previewed before committing to save it permanently. The generated voice receives a temporary generated_voice_id which can be used with elevenlabs_create_voice_from_design to register it as a permanent voice in your account. The response includes audio preview data allowing you to evaluate if the generated voice meets your requirements. This is useful for creating custom branded voices, character voices for games/animations, or unique voices for specific use cases without requiring voice samples or recordings."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-22T04:46:37.843Z",
    "updatedAt": "2025-10-22T04:56:46.345Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "Descriptive text explaining the desired voice characteristics"
            },
            "accent": {
              "type": "string",
              "description": "Desired accent: american, british, african, australian, indian, etc"
            },
            "gender": {
              "type": "string",
              "description": "Gender of the voice: male, female, or neutral"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "elevenlabs_api_key": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Create a new synthetic voice design based on descriptive parameters using ElevenLabs' AI voice generation. This tool uses the POST /voice-generation/generate-voice endpoint to synthesize completely new voices from scratch. Provide three key parameters: text (descriptive explanation of desired voice characteristics like 'professional narrator', 'energetic young character', 'authoritative business voice'), gender (male/female/neutral), and accent (american/british/african/australian/indian/etc.). The AI analyzes these parameters and generates a unique voice profile with a temporary generated_voice_id. The response includes audio preview data (typically in base64 or binary format) so you can evaluate the generated voice. If satisfied, use the returned generated_voice_id with elevenlabs_create_voice_from_design to permanently save this voice to your account. Ideal for creating custom branded voices, character voices for entertainment, or specialized voices for specific applications without needing actual voice recordings or samples. Generation quality and availability may depend on your subscription tier.",
    "outputTransform": "(sourceData) => { return sourceData.designVoice; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool uses ElevenLabs' AI to create a synthetic voice tailored to your specifications, including text description, gender, and accent. It generates a unique voice profile with an audio preview, allowing you to evaluate if it meets your needs before saving it permanently."
  },
  "elevenlabs_generate_sound_effects": {
    "id": "elevenlabs_generate_sound_effects",
    "steps": [
      {
        "id": "generateSoundEffect",
        "apiConfig": {
          "id": "generateSoundEffect",
          "body": "{\n  \"text\": \"<<text>>\",\n  \"duration_seconds\": <<duration_seconds>>\n}",
          "method": "POST",
          "headers": {
            "xi-api-key": "<<elevenlabs_api_key>>",
            "Content-Type": "application/json"
          },
          "urlHost": "https://api.elevenlabs.io/v1",
          "urlPath": "/sound-generation",
          "instruction": "Generate custom sound effects, ambience, or audio based on natural language text prompts. This endpoint uses ElevenLabs' AI sound generation model to create realistic sound effects and atmospheric audio from descriptive text. Simply describe what you want to hear (e.g., 'ocean waves crashing on a beach', 'footsteps on gravel', 'bustling city street with car horns', 'peaceful forest with birds chirping') and optionally specify duration_seconds for how long the audio should be (typically 1-22 seconds depending on plan). The AI interprets your prompt and synthesizes appropriate audio matching the description. This is ideal for game development, video production, podcast creation, content creation, or any application requiring custom sound effects without the need for recording equipment or sound effect libraries. The generated audio is returned in a standard audio format (typically MP3 or WAV). Quality and duration limits may vary based on your subscription tier. More detailed and specific prompts generally yield better results."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-22T04:46:41.372Z",
    "updatedAt": "2025-10-22T04:59:49.961Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "Natural language description of the sound effect or ambience to generate"
            },
            "duration_seconds": {
              "type": "number",
              "description": "Length of the generated audio in seconds"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "elevenlabs_api_key": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Generate custom sound effects, ambience, or audio from natural language text prompts using ElevenLabs' AI sound generation. This tool uses the POST /sound-generation endpoint to create realistic audio effects without recording equipment. Provide two parameters: text (descriptive prompt like 'ocean waves crashing', 'footsteps on wooden floor', 'car engine starting', 'medieval marketplace ambience', 'laser gun sound effect'), and duration_seconds (audio length, typically 1-22 seconds based on plan tier). The AI sound model interprets your prompt and synthesizes matching audio. More specific and detailed descriptions yield better results (e.g., 'slow footsteps on creaky wooden floorboards' vs just 'footsteps'). Perfect for game developers, video producers, podcasters, content creators, or anyone needing custom audio without sound effect libraries or recording sessions. Response contains generated audio in standard format (MP3/WAV). Generation capabilities, duration limits, and quality depend on subscription level. Use descriptive language and specify environmental context for best results.",
    "outputTransform": "(sourceData) => { return sourceData.generateSoundEffect; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool uses advanced AI to create custom sound effects and ambient audio from your descriptive text prompts. It will generate and return realistic audio clips, perfect for enhancing games, videos, podcasts, or any creative project, in standard formats like MP3 or WAV."
  },
  "elevenlabs_generation_history": {
    "id": "elevenlabs_generation_history",
    "steps": [
      {
        "id": "getAudioHistory",
        "apiConfig": {
          "id": "getAudioHistory",
          "method": "GET",
          "headers": {
            "xi-api-key": "<<elevenlabs_api_key>>"
          },
          "urlHost": "https://api.elevenlabs.io/v1",
          "urlPath": "/history",
          "instruction": "Retrieve the complete history of previously generated audio items from your ElevenLabs account. This endpoint returns a chronological list of all audio generation requests you've made, including text-to-speech generations, voice cloning attempts, and sound effect creations. Each history item contains comprehensive metadata: history_item_id (unique identifier for this generation), request_id (for tracking and support), voice_id and voice_name used, model_id that processed the request, the original text input, date_unix timestamp of creation, character_count_change_from and character_count_change_to showing quota impact, content_type (e.g., audio/mpeg), generation state (created, deleted, etc.), settings used (stability, similarity_boost, style, use_speaker_boost, speed values), feedback if provided, share_link_id if shared publicly, source indicating generation type (TTS, voice cloning, etc.), and alignment/dialogue data if available. This is invaluable for auditing usage, tracking character consumption against quota, reviewing past generations for reuse, debugging issues by examining exact parameters used, monitoring team usage patterns, and maintaining records for billing or compliance purposes. Results can typically be filtered and paginated based on your plan tier."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-22T04:46:47.451Z",
    "updatedAt": "2025-10-22T05:02:09.702Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object"
        },
        "credentials": {
          "type": "object",
          "properties": {
            "elevenlabs_api_key": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "View the complete history of previously generated audio items with detailed metadata and usage tracking. This tool uses the GET /history endpoint to retrieve all your past audio generations. No parameters required (filtering may be available depending on plan). Returns array of history items, each containing: history_item_id (unique identifier), request_id (for support/tracking), voice_id and voice_name used, model_id that processed it, original text input, date_unix (creation timestamp), character_count_change_from/to (quota usage tracking - shows how many characters were consumed), content_type (audio format like audio/mpeg), state (created/deleted/processing), settings object (exact stability, similarity_boost, style, use_speaker_boost, speed parameters used), feedback (if provided), share_link_id (if publicly shared), source (generation type: TTS/voice_cloning/sound_generation), alignments and dialogue data (if available for synchronization). Essential for: auditing API usage and spending, tracking character quota consumption over time, reviewing past generations to avoid duplicates, debugging by examining exact parameters, monitoring team member usage patterns, maintaining compliance/billing records, and accessing previous generations for reuse. Pagination and filtering capabilities depend on subscription tier (Free/Starter/Creator/Pro/Scale).",
    "outputTransform": "(sourceData) => { return { audioHistory: sourceData.getAudioHistory?.history || [] }; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool retrieves a detailed history of all your audio generation activities from ElevenLabs, including text-to-speech and voice cloning requests. It provides comprehensive metadata for each request, helping you track usage, monitor team activity, and maintain records for billing and compliance."
  },
  "elevenlabs_create_voice_from_design": {
    "id": "elevenlabs_create_voice_from_design",
    "steps": [
      {
        "id": "createVoiceFromDesign",
        "apiConfig": {
          "id": "createVoiceFromDesign",
          "body": "{\n  \"voice_name\": \"<<voice_name>>\",\n  \"voice_description\": \"<<voice_description>>\",\n  \"generated_voice_id\": \"<<generated_voice_id>>\"\n}",
          "method": "POST",
          "headers": {
            "xi-api-key": "<<elevenlabs_api_key>>",
            "Content-Type": "application/json"
          },
          "urlHost": "https://api.elevenlabs.io/v1",
          "urlPath": "/voice-generation/create-voice",
          "instruction": "Save and permanently register a new voice from a previously generated voice design. This endpoint takes a generated_voice_id (obtained from elevenlabs_design_voice), a voice_name to identify the voice in your library, and a voice_description explaining the voice's characteristics and intended use. Once saved, the voice becomes a permanent part of your voice library and can be used with all text-to-speech endpoints just like premade voices. The voice will receive a permanent voice_id that replaces the temporary generated_voice_id. This is the final step in the custom voice creation workflow - first use elevenlabs_design_voice to generate and preview voices, then use this endpoint to commit the design you're satisfied with. The saved voice will appear in your voice list from elevenlabs_list_voices and can be retrieved with elevenlabs_get_voice. Important: This feature requires a paid ElevenLabs subscription plan as voice creation is not available on free tiers. Character generation and fine-tuning capabilities depend on your specific plan level."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-22T04:52:35.279Z",
    "updatedAt": "2025-10-22T04:59:31.308Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "voice_name": {
              "type": "string",
              "description": "A unique name for this voice in your library"
            },
            "voice_description": {
              "type": "string",
              "description": "Detailed description of the voice's characteristics and use case"
            },
            "generated_voice_id": {
              "type": "string",
              "description": "The temporary voice ID to save"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "elevenlabs_api_key": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Save and permanently register a new custom voice from a generated voice design. This tool uses the POST /voice-generation/create-voice endpoint to commit a voice design to your library. This is step 2 of the custom voice creation workflow (after elevenlabs_design_voice). Required parameters: generated_voice_id (the temporary ID from elevenlabs_design_voice output), voice_name (unique identifier for your library like 'Brand Narrator' or 'Character Voice 1'), and voice_description (detailed explanation of characteristics and use case). Once saved, the voice receives a permanent voice_id and becomes available in your voice library alongside premade voices. You can then use it with elevenlabs_text_to_speech, elevenlabs_text_to_speech_stream, and view it via elevenlabs_list_voices or elevenlabs_get_voice. IMPORTANT: This feature requires a paid ElevenLabs subscription - it will fail on free plans with an error indicating voice creation is restricted. The response includes the new permanent voice_id and full voice object. Voice limits depend on your subscription tier (Starter/Creator/Pro/Scale plans have different voice slot allowances).",
    "outputTransform": "(sourceData) => { return sourceData.createVoiceFromDesign; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool lets you permanently save a custom voice design into your voice library, giving it a unique name and description for future use. Once saved, the voice is assigned a permanent ID and can be used like any other premade voice, provided you have a paid ElevenLabs subscription."
  },
  "elevenlabs_create_dubbing_job": {
    "id": "elevenlabs_create_dubbing_job",
    "steps": [
      {
        "id": "createDubbingJob",
        "apiConfig": {
          "id": "createDubbingJob",
          "body": "{\n  \"source_url\": \"<<source_url>>\",\n  \"source_lang\": \"<<source_language>>\",\n  \"target_lang\": \"<<target_language>>\"\n}",
          "method": "POST",
          "headers": {
            "xi-api-key": "<<elevenlabs_api_key>>",
            "Content-Type": "application/json"
          },
          "urlHost": "https://api.elevenlabs.io/v1",
          "urlPath": "/dubbing",
          "instruction": "Initiate a dubbing job to automatically translate and dub audio or video content from one language to another while preserving the original voice characteristics, timing, and emotional tone. This endpoint accepts a source_url pointing to the audio or video file to be dubbed (must be publicly accessible), source_lang specifying the original language code (e.g., 'en' for English, 'es' for Spanish, 'fr' for French, 'de' for German, etc.), and target_lang indicating the desired output language code. ElevenLabs' dubbing system analyzes the source content, transcribes the speech, translates it to the target language, and generates dubbed audio that matches the original speaker's voice characteristics and timing. The process preserves emotional inflection, speaking pace, and voice identity across languages. The endpoint returns a dubbing_id which can be used to check job status and retrieve the completed dubbed content via elevenlabs_get_dubbed_audio. Processing time varies based on content length, typically taking several minutes to hours for longer videos. Dubbing quality and language support depend on your subscription tier."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-22T04:52:43.518Z",
    "updatedAt": "2025-10-22T05:00:09.319Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "source_url": {
              "type": "string",
              "description": "Publicly accessible URL of the audio or video file to dub"
            },
            "source_language": {
              "type": "string",
              "description": "Source language code (e.g., 'en' for English)"
            },
            "target_language": {
              "type": "string",
              "description": "Target language code for dubbing output"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "elevenlabs_api_key": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Start a dubbing job to automatically translate and dub audio or video content from one language to another with voice preservation. This tool uses the POST /dubbing endpoint to initiate AI-powered dubbing that maintains the original speaker's voice characteristics, timing, and emotional tone across languages. Required parameters: source_url (publicly accessible URL to your audio/video file in formats like MP3, WAV, MP4, MOV), source_language (original language code like 'en', 'es', 'fr', 'de', 'it', 'pt', 'ja', 'zh', 'ko', 'hi', 'ar', etc.), and target_language (desired output language code). The system transcribes speech, translates content, and generates dubbed audio matching original voice identity and pacing. Returns a dubbing_id for tracking job status and retrieving completed output via elevenlabs_get_dubbed_audio. Processing duration depends on content length (minutes to hours). Perfect for international content distribution, video localization, e-learning translation, podcast multilingual expansion, or making content accessible to global audiences. Dubbing quality, supported languages, and simultaneous job limits vary by subscription tier (Free/Starter/Creator/Pro/Scale plans).",
    "outputTransform": "(sourceData) => { return sourceData.createDubbingJob; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool automatically translates and dubs your audio or video content from one language to another, while preserving the original speaker's voice characteristics and emotional tone. It returns a unique dubbing ID, which you can use to track the status of your job and retrieve the completed dubbed content."
  },
  "elevenlabs_get_dubbed_audio": {
    "id": "elevenlabs_get_dubbed_audio",
    "steps": [
      {
        "id": "getDubbedAudio",
        "apiConfig": {
          "id": "getDubbedAudio",
          "method": "GET",
          "headers": {
            "xi-api-key": "<<elevenlabs_api_key>>"
          },
          "urlHost": "https://api.elevenlabs.io/v1",
          "urlPath": "/dubbing/<<dubbing_id>>/audio/<<language_code>>",
          "instruction": "Retrieve or download the completed dubbed audio or video output for a specific target language from a previously created dubbing job. This endpoint requires two parameters: dubbing_id (the unique identifier returned from elevenlabs_create_dubbing_job) and language_code (the target language code matching what was specified in the dubbing job, e.g., 'es' for Spanish, 'fr' for French, 'de' for German). The endpoint returns the fully processed dubbed audio/video file where the original speech has been translated and re-voiced in the target language while preserving the speaker's voice characteristics, emotional tone, timing, and lip-sync quality (for video). Only call this endpoint after the dubbing job has completed processing - you can check job status first to ensure completion. The returned file format matches the source format (if video input, returns video with dubbed audio; if audio input, returns audio). Use this to retrieve final localized content ready for distribution to target language audiences."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-22T04:52:51.540Z",
    "updatedAt": "2025-10-22T05:00:25.799Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "dubbing_id": {
              "type": "string",
              "description": "The unique dubbing job ID"
            },
            "language_code": {
              "type": "string",
              "description": "Target language code from the dubbing job"
            }
          }
        },
        "credentials": {
          "type": "object",
          "properties": {
            "elevenlabs_api_key": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Retrieve or download the completed dubbed audio or video output from a finished dubbing job. This tool uses the GET /dubbing/{dubbing_id}/audio/{language_code} endpoint to fetch the final localized content. Required parameters: dubbing_id (unique identifier from elevenlabs_create_dubbing_job response - identifies which dubbing job) and language_code (target language code like 'es', 'fr', 'de', 'it', 'pt', 'ja', 'zh' that matches the target language specified when creating the job). Returns the completed dubbed file where speech has been translated and re-voiced in the target language with preserved voice characteristics, emotional tone, timing, and lip-sync (for video). File format matches input (video returns video with dubbed audio, audio returns dubbed audio). Only call this after dubbing job completion - check job status first if uncertain. Use the output for international content distribution, multi-language platforms, global audience reach, or localized marketing campaigns. The dubbed content maintains professional quality suitable for commercial use, educational content, entertainment, or corporate communications.",
    "outputTransform": "(sourceData) => { return sourceData.getDubbedAudio; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool retrieves the completed dubbed audio or video in your chosen language from a previous dubbing job, ensuring that the original speech is accurately translated and re-voiced while maintaining the speaker's characteristics and emotional tone. It returns the finalized localized content, ready for distribution to audiences in the target language."
  },
  "elevenlabs_text_to_speech": {
    "id": "elevenlabs_text_to_speech",
    "steps": [
      {
        "id": "convertTextToSpeech",
        "apiConfig": {
          "id": "convertTextToSpeech",
          "body": "{\n  \"text\": \"<<text>>\",\n  << (sourceData) => sourceData.model_id ? `\"model_id\": \"${sourceData.model_id}\",` : '' >>\n  << (sourceData) => sourceData.voice_settings ? `\"voice_settings\": ${JSON.stringify(sourceData.voice_settings)}` : '' >>\n}",
          "method": "POST",
          "headers": {
            "xi-api-key": "<<elevenlabs_api_key>>",
            "Content-Type": "application/json"
          },
          "urlHost": "https://api.elevenlabs.io/v1",
          "urlPath": "/text-to-speech/<<voice_id>>",
          "instruction": "Convert text into high-quality speech audio using ElevenLabs' text-to-speech API. This endpoint accepts a voice_id to specify which voice to use, the text content to convert, and optional parameters like model_id to select the TTS model (e.g., eleven_monolingual_v1, eleven_multilingual_v2, eleven_turbo_v2) and voice_settings to fine-tune the output (stability: 0-1 controls consistency, similarity_boost: 0-1 controls how closely it matches the original voice, style: 0-1 for style exaggeration, use_speaker_boost: boolean for clarity enhancement). Returns audio data in MP3 format by default."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-22T04:41:12.115Z",
    "updatedAt": "2025-10-22T04:55:42.830Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "elevenlabs_api_key": {
              "type": "string",
              "description": "Your personal API key"
            },
            "text": {
              "type": "string",
              "description": "The text content to convert to speech"
            },
            "model_id": {
              "type": "string",
              "description": "Optional: The model ID to use"
            },
            "voice_id": {
              "type": "string",
              "description": "The voice ID to use for speech generation"
            },
            "voice_settings": {
              "type": "object",
              "description": "Optional: Fine-tune voice output settings"
            }
          }
        }
      }
    },
    "instruction": "Convert text into high-quality speech audio using a selected voice from ElevenLabs. This tool uses the /text-to-speech/{voice_id} endpoint with POST method. Provide a voice_id (obtain from elevenlabs_list_voices), the text to convert, and optionally specify model_id for different TTS models and voice_settings object to control stability (0-1, higher = more consistent), similarity_boost (0-1, higher = closer to original voice), style (0-1, higher = more expressive), and use_speaker_boost (true/false for clarity). The response contains audio data in MP3 format. Character usage counts against your plan quota.",
    "outputTransform": "(sourceData) => { return sourceData.convertTextToSpeech; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool converts your text into high-quality speech using ElevenLabs' advanced text-to-speech technology, allowing you to choose from different voices and customize settings like stability and style. It returns the audio in MP3 format, providing a seamless way to generate natural-sounding speech from written content."
  },
  "elevenlabs_list_voices": {
    "id": "elevenlabs_list_voices",
    "steps": [
      {
        "id": "getAllVoices",
        "apiConfig": {
          "id": "getAllVoices",
          "method": "GET",
          "headers": {
            "xi-api-key": "<<elevenlabs_api_key>>"
          },
          "urlHost": "https://api.elevenlabs.io/v1",
          "urlPath": "/voices",
          "instruction": "Retrieve a comprehensive list of all available voices in your ElevenLabs account, including both premade voices provided by ElevenLabs and any custom voices you have created or cloned. This endpoint returns detailed metadata for each voice including voice_id (required for TTS requests), name, category (premade, cloned, generated, or professional), labels (gender, age, accent, use case, descriptive qualities), preview_url (to listen to voice samples), description, fine_tuning status and supported models, settings (default stability, similarity_boost, style values), and high_quality_base_model_ids (which models work best with this voice). Use this endpoint to discover available voices, their characteristics, and obtain voice_ids needed for text-to-speech generation. Filtering and pagination may be available depending on your plan.",
          "queryParams": {}
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-22T04:41:22.923Z",
    "updatedAt": "2025-10-22T04:56:14.595Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object",
          "properties": {
            "elevenlabs_api_key": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "Retrieve all available voices with comprehensive metadata and filtering options from your ElevenLabs account. This tool uses the GET /voices endpoint to fetch both premade ElevenLabs voices and your custom created/cloned voices. The response includes detailed information for each voice: voice_id (use this for TTS requests), name, category (premade/cloned/generated/professional), labels (gender, age, accent, language, use_case, descriptive traits like 'warm', 'authoritative', 'friendly'), preview_url (audio sample link), description, fine_tuning capabilities and status, default voice settings (stability, similarity_boost, style), high_quality_base_model_ids (compatible models), and verified_languages. This is essential for discovering available voices and obtaining the voice_id needed for elevenlabs_text_to_speech and elevenlabs_text_to_speech_stream tools. No parameters required - returns all voices accessible to your account.",
    "outputTransform": "(sourceData) => {\n  if (!sourceData.getAllVoices || !Array.isArray(sourceData.getAllVoices.voices)) {\n    throw new Error('No voices found in response');\n  }\n  return {\n    voices: sourceData.getAllVoices.voices\n  };\n}",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool retrieves a complete list of all voices available in your ElevenLabs account, including both premade and custom voices. It provides detailed information about each voice, such as its unique ID, name, category, descriptive labels, and a link to an audio sample, helping you choose the right voice for text-to-speech applications."
  },
  "elevenlabs_list_models": {
    "id": "elevenlabs_list_models",
    "steps": [
      {
        "id": "listModels",
        "apiConfig": {
          "id": "listModels",
          "method": "GET",
          "headers": {
            "xi-api-key": "<<elevenlabs_api_key>>"
          },
          "urlHost": "https://api.elevenlabs.io/v1",
          "urlPath": "/models",
          "instruction": "List all available ElevenLabs AI models including text-to-speech models, multilingual models, turbo models for faster processing, sound effects generation models, and dubbing models. This endpoint returns comprehensive information about each model including model_id (required for TTS and other API calls), name, description of capabilities and use cases, supported languages with locale codes, model category/type (e.g., TTS, dubbing, sound generation), technical specifications, quality characteristics (accuracy, naturalness, latency), token costs or pricing tier if applicable, version information, release date, and any special features or limitations. Different models offer various trade-offs between quality, speed, language support, and cost. For example, monolingual models (like eleven_monolingual_v1) provide highest quality for single language, multilingual models (like eleven_multilingual_v2) support many languages, turbo models (like eleven_turbo_v2, eleven_turbo_v2_5) prioritize speed over quality for real-time applications, and flash models balance quality with performance. Use this endpoint to discover which models are available to your account, understand their capabilities, and select the appropriate model_id for your specific use case requirements."
        },
        "executionMode": "DIRECT"
      }
    ],
    "createdAt": "2025-10-22T04:46:44.282Z",
    "updatedAt": "2025-10-22T05:00:42.340Z",
    "inputSchema": {
      "type": "object",
      "properties": {
        "payload": {
          "type": "object"
        },
        "credentials": {
          "type": "object",
          "properties": {
            "elevenlabs_api_key": {
              "type": "string",
              "description": "Your personal API key"
            }
          }
        }
      }
    },
    "instruction": "List all available ElevenLabs models for text-to-speech, dubbing, sound effects generation, and other AI audio services. This tool uses the GET /models endpoint to retrieve comprehensive model information. No parameters required. Returns array of model objects containing: model_id (use this in TTS requests and other endpoints), name, description (capabilities and optimal use cases), supported_languages (array with language codes and locales), model category/type, technical specifications, quality characteristics (naturalness, accuracy, latency metrics), pricing/token cost information, version details, release dates, and special features or constraints. Models include monolingual (highest quality single language like eleven_monolingual_v1), multilingual (broad language support like eleven_multilingual_v2), turbo (faster processing for real-time like eleven_turbo_v2/eleven_turbo_v2_5), flash (quality-speed balance like eleven_flash_v2), and specialized models for sound effects or dubbing. Use this to understand which models are accessible on your plan, compare their trade-offs (quality vs speed vs language support vs cost), and select the appropriate model_id for your application requirements. Model availability depends on subscription tier.",
    "outputTransform": "(sourceData) => { return sourceData.listModels; }",
    "systemIds": [],
    "outputSchema": {},
    "description": "This tool connects to ElevenLabs to provide a comprehensive list of AI models available for various audio services, such as text-to-speech and sound effects generation. It returns detailed information about each model, including its capabilities, supported languages, and any special features, allowing you to select the most suitable model for your needs."
  },
  "bitbucket_comment_pull_request": {
    "id": "bitbucket_comment_pull_request",
    "steps": [
      {
        "id": "addPullRequestComment",
        "apiConfig": {
          "id": "addPullRequestComment",
          "body": "{\"content\": {\"raw\": \"<<comment_text>>\"}}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Basic <<bitbucket_username>>:<<bitbucket_apiKey>>"
          },
          "urlHost": "https://api.bitbucket.org",
          "urlPath": "/2.0/repositories/<<workspace>>/<<repository>>/pullrequests/<<pull_request_id>>/comments",
          "dataPath": null,
          "pagination": null,
          "instruction": "Add a comment to a specific pull request in the given Bitbucket workspace and repository. The comment content should be the provided text. Return the created comment details.",
          "queryParams": null,
          "authentication": null,
          "outputSchema": null,
          "responseMapping": null,
          "documentationUrl": null
        },
        "inputMapping": null,
        "loopMaxIters": null,
        "dataSelector": "(sourceData) => ({});",
        "executionMode": null,
        "responseMapping": "$"
      }
    ],
    "createdAt": "2025-11-04T13:46:49.865Z",
    "updatedAt": "2025-11-04T13:46:49.865Z",
    "inputSchema": {
      "type": "object",
      "required": ["payload", "credentials"],
      "properties": {
        "payload": {
          "type": "object",
          "required": ["workspace", "repository", "pull_request_id", "comment_text"],
          "properties": {
            "workspace": {
              "type": "string",
              "description": "Your Bitbucket workspace"
            },
            "repository": {
              "type": "string",
              "description": "Your Bitbucket repository"
            },
            "comment_text": {
              "type": "string",
              "description": "Text of the comment to add"
            },
            "pull_request_id": {
              "type": "string",
              "description": "ID of the pull request"
            }
          }
        },
        "credentials": {
          "type": "object",
          "required": ["bitbucket_apiKey", "bitbucket_username"],
          "properties": {
            "bitbucket_apiKey": {
              "type": "string",
              "description": "Your API key"
            },
            "bitbucket_username": {
              "type": "string",
              "description": "Your Bitbucket username"
            }
          }
        }
      }
    },
    "instruction": "Create a Bitbucket pull request comment tool named 'bitbucket_comment_pull_request'.\nSteps:\n1. Add a comment to a specific pull request using POST /2.0/repositories/{workspace}/{repository}/pullrequests/{pull_request_id}/comments\n2. The comment should include the content text provided\n3. Return success status and comment details",
    "outputTransform": "(sourceData) => { return { success: !!sourceData.addPullRequestComment.data?.id, comment: sourceData.addPullRequestComment.data }; }",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "message": {
          "type": "string"
        },
        "success": {
          "type": "boolean"
        },
        "comment_id": {
          "type": "string"
        }
      }
    },
    "description": "This tool allows you to add a comment to a specific pull request in your Bitbucket repository. It will return the success status along with the details of the created comment, including the comment ID."
  },
  "bitbucket_create_branch": {
    "id": "bitbucket_create_branch",
    "steps": [
      {
        "id": "createBranch",
        "apiConfig": {
          "id": "createBranch",
          "body": "{\n  \"name\": \"<<branch_name>>\",\n  \"target\": {\n    \"hash\": \"<<target>>\"\n  }\n}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer <<bitbucket_apiKey>>"
          },
          "urlHost": "https://api.bitbucket.org",
          "urlPath": "/2.0/repositories/<<workspace>>/<<repository>>/refs/branches",
          "dataPath": null,
          "pagination": null,
          "instruction": "Create a new branch in the specified Bitbucket repository using the provided workspace, repository, branch name, and target (commit hash or branch name). Return the created branch details.",
          "queryParams": null,
          "authentication": null,
          "outputSchema": null,
          "responseMapping": null,
          "documentationUrl": null
        },
        "inputMapping": null,
        "loopMaxIters": null,
        "dataSelector": "(sourceData) => ({});",
        "executionMode": null,
        "responseMapping": "$"
      }
    ],
    "createdAt": "2025-11-04T14:47:17.302Z",
    "updatedAt": "2025-11-04T14:47:17.302Z",
    "inputSchema": {
      "type": "object",
      "required": ["payload", "credentials"],
      "properties": {
        "payload": {
          "type": "object",
          "required": ["workspace", "repository", "branch_name", "target"],
          "properties": {
            "target": {
              "type": "string",
              "description": "Commit hash or branch name to base the new branch on"
            },
            "workspace": {
              "type": "string",
              "description": "Your workspace name"
            },
            "repository": {
              "type": "string",
              "description": "Your repository name"
            },
            "branch_name": {
              "type": "string",
              "description": "Name for the new branch"
            }
          }
        },
        "credentials": {
          "type": "object",
          "required": ["bitbucket_apiKey", "bitbucket_username"],
          "properties": {
            "bitbucket_apiKey": {
              "type": "string",
              "description": "Your API key"
            },
            "bitbucket_username": {
              "type": "string",
              "description": "Your Bitbucket username"
            }
          }
        }
      }
    },
    "instruction": "Create a Bitbucket branch creation tool named 'bitbucket_create_branch'.\nSteps:\n1. Create a new branch using POST /2.0/repositories/{workspace}/{repository}/refs/branches\n2. Include workspace, repository, branch name, and target commit/branch to create the branch from\n3. Return the created branch details including name and commit hash",
    "outputTransform": "(sourceData) => {\n  const branch = sourceData.createBranch.data;\n  return {\n    name: branch?.name,\n    target_hash: branch?.target?.hash,\n    branch_details: branch\n  };\n}",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "message": {
          "type": "string"
        },
        "success": {
          "type": "boolean"
        },
        "branch_name": {
          "type": "string"
        },
        "commit_hash": {
          "type": "string"
        },
        "branch_details": {
          "type": "object"
        }
      }
    },
    "description": "This tool connects to Bitbucket to create a new branch in a specified repository using details like workspace, repository name, branch name, and starting point (commit hash or branch name). It will return the details of the newly created branch, including its name and commit hash."
  },
  "bitbucket_create_pull_request": {
    "id": "bitbucket_create_pull_request",
    "steps": [
      {
        "id": "createPullRequest",
        "apiConfig": {
          "id": "createPullRequest",
          "body": "{\n  \"title\": \"<<title>>\",\n  \"description\": \"<<description>>\",\n  \"source\": {\n    \"branch\": { \"name\": \"<<source_branch>>\" }\n  },\n  \"destination\": {\n    \"branch\": { \"name\": \"<<destination_branch>>\" }\n  },\n  \"reviewers\": <<(sourceData) => Array.isArray(sourceData.reviewers) ? sourceData.reviewers.map(r => (typeof r === 'string' ? {uuid: r} : r)) : []>>\n}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Basic <<bitbucket_username>>:<<bitbucket_apiKey>>"
          },
          "urlHost": "https://api.bitbucket.org/",
          "urlPath": "/2.0/repositories/<<workspace>>/<<repository>>/pullrequests",
          "dataPath": null,
          "pagination": null,
          "instruction": "Create a new pull request in the specified Bitbucket repository using the provided title, description, source branch, destination branch, and reviewers. Return the created pull request details.",
          "queryParams": null,
          "authentication": null,
          "outputSchema": null,
          "responseMapping": null,
          "documentationUrl": null
        },
        "inputMapping": null,
        "loopMaxIters": null,
        "dataSelector": "(sourceData) => ({});",
        "executionMode": null,
        "responseMapping": "$"
      }
    ],
    "createdAt": "2025-11-04T14:04:07.450Z",
    "updatedAt": "2025-11-04T14:04:07.450Z",
    "inputSchema": {
      "type": "object",
      "required": ["payload", "credentials"],
      "properties": {
        "payload": {
          "type": "object",
          "required": [
            "workspace",
            "repository",
            "title",
            "description",
            "source_branch",
            "destination_branch",
            "reviewers"
          ],
          "properties": {
            "title": {
              "type": "string",
              "description": "Title of the pull request"
            },
            "reviewers": {
              "type": "array",
              "description": "List of reviewers for the pull request"
            },
            "workspace": {
              "type": "string",
              "description": "Workspace name"
            },
            "repository": {
              "type": "string",
              "description": "Repository name"
            },
            "description": {
              "type": "string",
              "description": "Description of the pull request"
            },
            "source_branch": {
              "type": "string",
              "description": "Source branch name"
            },
            "destination_branch": {
              "type": "string",
              "description": "Destination branch name"
            }
          }
        },
        "credentials": {
          "type": "object",
          "required": ["bitbucket_apiKey", "bitbucket_username"],
          "properties": {
            "bitbucket_apiKey": {
              "type": "string",
              "description": "Your API key"
            },
            "bitbucket_username": {
              "type": "string",
              "description": "Your Bitbucket username"
            }
          }
        }
      }
    },
    "instruction": "Create a Bitbucket pull request creation tool named 'bitbucket_create_pull_request'.\nSteps:\n1. Create a new pull request using POST /2.0/repositories/{workspace}/{repository}/pullrequests\n2. Include title, description, source branch, destination branch, and reviewers\n3. Return the created pull request details including ID and URL",
    "outputTransform": "(sourceData) => {\n  const pr = sourceData.createPullRequest.data;\n  return {\n    id: pr.id || pr.uuid,\n    url: pr.links?.html?.href,\n    title: pr.title,\n    description: pr.description,\n    source_branch: pr.source?.branch?.name,\n    destination_branch: pr.destination?.branch?.name,\n    reviewers: pr.reviewers?.map(r => ({ uuid: r.uuid, display_name: r.display_name, account_id: r.account_id })),\n    raw: pr\n  };\n}",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "message": {
          "type": "string"
        },
        "success": {
          "type": "boolean"
        },
        "pull_request_id": {
          "type": "string"
        },
        "pull_request_url": {
          "type": "string"
        }
      }
    },
    "description": "This tool allows you to effortlessly create a pull request in your specified Bitbucket repository by providing details like the title, description, and branches involved. It will return the details of the newly created pull request, including its ID and URL, allowing you to track and manage your code changes."
  },
  "bitbucket-create-repo": {
    "id": "bitbucket-create-repo",
    "steps": [
      {
        "id": "createRepository",
        "apiConfig": {
          "id": "createRepository",
          "body": "{\n  \"scm\": \"<<scm>>\",\n  \"description\": \"<<description>>\",\n  \"is_private\": <<is_private>>\n}",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Basic <<bitbucket_username>>:<<bitbucket_apiKey>>"
          },
          "urlHost": "https://api.bitbucket.org/",
          "urlPath": "/2.0/repositories/<<workspace>>/<<repository>>",
          "dataPath": null,
          "pagination": null,
          "instruction": "Create a new Bitbucket repository in the specified workspace with the provided name, description, privacy setting, and SCM type. Return the created repository details.",
          "queryParams": null,
          "authentication": null,
          "outputSchema": null,
          "responseMapping": null,
          "documentationUrl": null
        },
        "inputMapping": null,
        "loopMaxIters": null,
        "dataSelector": "(sourceData) => ({});",
        "executionMode": null,
        "responseMapping": "$"
      }
    ],
    "createdAt": "2025-11-04T14:27:39.722Z",
    "updatedAt": "2025-11-04T14:27:39.722Z",
    "inputSchema": {
      "type": "object",
      "required": ["payload", "credentials"],
      "properties": {
        "payload": {
          "type": "object",
          "required": ["workspace", "repository", "description", "is_private", "scm"],
          "properties": {
            "scm": {
              "type": "string",
              "description": "Type of source control management"
            },
            "workspace": {
              "type": "string",
              "description": "Name of your workspace"
            },
            "is_private": {
              "type": "boolean",
              "description": "Set repository as private or public"
            },
            "repository": {
              "type": "string",
              "description": "Name of your repository"
            },
            "description": {
              "type": "string",
              "description": "Brief description of your repository"
            }
          }
        },
        "credentials": {
          "type": "object",
          "required": ["bitbucket_apiKey", "bitbucket_username"],
          "properties": {
            "bitbucket_apiKey": {
              "type": "string",
              "description": "Your API key"
            },
            "bitbucket_username": {
              "type": "string",
              "description": "Your Bitbucket username"
            }
          }
        }
      }
    },
    "instruction": "Create a Bitbucket repository creation tool named 'bitbucket-create-repo'.\nSteps:\n1. Create a new repository using POST /2.0/repositories/{workspace}/{repository}\n2. Include repository name, description, privacy settings, and other configuration\n3. Return the created repository details",
    "outputTransform": "(sourceData) => sourceData.createRepository.data",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "message": {
          "type": "string"
        },
        "success": {
          "type": "boolean"
        },
        "clone_url": {
          "type": "string"
        },
        "repository": {
          "type": "object"
        }
      }
    },
    "description": "This tool helps you effortlessly create a new Bitbucket repository in your specified workspace by using your provided credentials and configuration details such as repository name, description, privacy settings, and SCM type. It will return the details of the newly created repository, including a message of success and the clone URL."
  },
  "bitbucket_create_webhook": {
    "id": "bitbucket_create_webhook",
    "steps": [
      {
        "id": "listWebhooks",
        "apiConfig": {
          "id": "listWebhooks",
          "body": null,
          "method": "GET",
          "headers": {
            "Authorization": "Basic <<bitbucket_username>>:<<bitbucket_apiKey>>"
          },
          "urlHost": "https://api.bitbucket.org/",
          "urlPath": "/2.0/repositories/<<workspace>>/<<repository>>/hooks",
          "dataPath": null,
          "pagination": null,
          "instruction": "Retrieve all existing webhooks for the specified Bitbucket repository. This should return all webhook objects, including their URLs, events, and active status.",
          "queryParams": null,
          "authentication": null,
          "outputSchema": null,
          "responseMapping": null,
          "documentationUrl": null
        },
        "inputMapping": null,
        "loopMaxIters": null,
        "dataSelector": "(sourceData) => ({});",
        "executionMode": null,
        "responseMapping": "$"
      },
      {
        "id": "createWebhookIfNeeded",
        "apiConfig": {
          "id": "createWebhookIfNeeded",
          "body": "{ \"url\": \"<<webhook_url>>\", \"events\": <<(sourceData) => JSON.stringify(sourceData.events)>>, \"active\": <<active>> }",
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Basic <<bitbucket_username>>:<<bitbucket_apiKey>>"
          },
          "urlHost": "https://api.bitbucket.org/",
          "urlPath": "/2.0/repositories/<<workspace>>/<<repository>>/hooks",
          "dataPath": null,
          "pagination": null,
          "instruction": "Create a new webhook for the repository if no existing webhook matches the target URL, events, and active status. Use the provided webhook_url, events array, and active status. Only execute if the correct webhook does not already exist.",
          "queryParams": null,
          "authentication": null,
          "outputSchema": null,
          "responseMapping": null,
          "documentationUrl": null
        },
        "inputMapping": null,
        "loopMaxIters": null,
        "dataSelector": "(sourceData) => { return [{}]; }",
        "executionMode": null,
        "responseMapping": "$"
      }
    ],
    "createdAt": "2025-11-04T13:38:57.121Z",
    "updatedAt": "2025-11-04T13:38:57.121Z",
    "inputSchema": {
      "type": "object",
      "required": ["payload", "credentials"],
      "properties": {
        "payload": {
          "type": "object",
          "required": ["workspace", "repository", "webhook_url", "events", "active"],
          "properties": {
            "active": {
              "type": "boolean",
              "description": "Whether the webhook is active"
            },
            "events": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of events to trigger the webhook"
            },
            "workspace": {
              "type": "string",
              "description": "Your Bitbucket workspace name"
            },
            "repository": {
              "type": "string",
              "description": "Your Bitbucket repository name"
            },
            "webhook_url": {
              "type": "string",
              "description": "The URL for the webhook"
            }
          }
        },
        "credentials": {
          "type": "object",
          "required": ["bitbucket_apiKey", "bitbucket_username"],
          "properties": {
            "bitbucket_apiKey": {
              "type": "string",
              "description": "Your API key"
            },
            "bitbucket_username": {
              "type": "string",
              "description": "Your Bitbucket username"
            }
          }
        }
      }
    },
    "instruction": "Create a Bitbucket webhook management tool named 'bitbucket_create_webhook'. \nSteps:\n1. List existing webhooks for the repository using GET /2.0/repositories/{workspace}/{repository}/hooks\n2. Check if a webhook with the target URL already exists with correct events and active status\n3. If it exists properly configured, return success message\n4. If it doesn't exist, create it using POST /2.0/repositories/{workspace}/{repository}/hooks with the webhook_url, events array, and active status\n5. Return the result with webhook details",
    "outputTransform": "(sourceData) => {\n  // Step 1: Get all webhooks\n  const hooks = sourceData.listWebhooks.data && Array.isArray(sourceData.listWebhooks.data.values) ? sourceData.listWebhooks.data.values : [];\n  const targetUrl = sourceData.webhook_url;\n  const targetEvents = Array.isArray(sourceData.events) ? sourceData.events.sort() : [];\n  const targetActive = sourceData.active;\n\n  // Find a matching webhook\n  const found = hooks.find(hook => {\n    if (hook.url !== targetUrl) return false;\n    if (!!hook.active !== !!targetActive) return false;\n    if (!Array.isArray(hook.events)) return false;\n    const eventsSorted = [...hook.events].sort();\n    if (eventsSorted.length !== targetEvents.length) return false;\n    for (let i = 0; i < eventsSorted.length; i++) {\n      if (eventsSorted[i] !== targetEvents[i]) return false;\n    }\n    return true;\n  });\n\n  if (found) {\n    return {\n      success: true,\n      message: 'Webhook already exists and is properly configured.',\n      webhook: found\n    };\n  }\n\n  // If not found, check if the createWebhookIfNeeded step succeeded\n  const created = Array.isArray(sourceData.createWebhookIfNeeded) && sourceData.createWebhookIfNeeded[0]?.data;\n  if (created && created.url === targetUrl) {\n    return {\n      success: true,\n      message: 'Webhook created successfully.',\n      webhook: created\n    };\n  }\n\n  // If neither, return error\n  return {\n    success: false,\n    message: 'Failed to find or create webhook.',\n    details: {\n      attempted_url: targetUrl,\n      attempted_events: targetEvents,\n      attempted_active: targetActive\n    }\n  };\n}",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "status": {
          "type": "string"
        },
        "message": {
          "type": "string"
        },
        "success": {
          "type": "boolean"
        },
        "webhook_id": {
          "type": "string"
        }
      }
    },
    "description": "This tool manages webhooks for your Bitbucket repository by checking existing ones and creating new ones if needed. It will confirm success with details of the webhook or notify you if it couldn't find or create the webhook."
  },
  "bitbucket_get_pipeline_status": {
    "id": "bitbucket_get_pipeline_status",
    "steps": [
      {
        "id": "getRepositoryMetadata",
        "apiConfig": {
          "id": "getRepositoryMetadata",
          "body": null,
          "method": "GET",
          "headers": {
            "Authorization": "Bearer <<bitbucket_apiKey>>"
          },
          "urlHost": "https://api.bitbucket.org",
          "urlPath": "/2.0/repositories/<<workspace>>/<<repository>>",
          "dataPath": null,
          "pagination": null,
          "instruction": "Retrieve repository metadata for the given workspace and repository. This should include information about the default branch.",
          "queryParams": null,
          "authentication": null,
          "outputSchema": null,
          "responseMapping": null,
          "documentationUrl": null
        },
        "inputMapping": null,
        "loopMaxIters": null,
        "dataSelector": "(sourceData) => ({});",
        "executionMode": null,
        "responseMapping": "$"
      },
      {
        "id": "getRecentPipelines",
        "apiConfig": {
          "id": "getRecentPipelines",
          "body": null,
          "method": "GET",
          "headers": {
            "Authorization": "Bearer <<bitbucket_apiKey>>"
          },
          "urlHost": "https://api.bitbucket.org",
          "urlPath": "/2.0/repositories/<<workspace>>/<<repository>>/pipelines/",
          "dataPath": null,
          "pagination": null,
          "instruction": "Fetch the 5 most recent pipelines for the given workspace and repository, sorted by creation date descending.",
          "queryParams": {
            "sort": "-created_on",
            "pagelen": "5"
          },
          "authentication": null,
          "outputSchema": null,
          "responseMapping": null,
          "documentationUrl": null
        },
        "inputMapping": null,
        "loopMaxIters": null,
        "dataSelector": "(sourceData) => ({})",
        "executionMode": null,
        "responseMapping": "$"
      }
    ],
    "createdAt": "2025-11-04T13:43:45.503Z",
    "updatedAt": "2025-11-04T13:43:45.503Z",
    "inputSchema": {
      "type": "object",
      "required": ["payload", "credentials"],
      "properties": {
        "payload": {
          "type": "object",
          "required": ["workspace", "repository"],
          "properties": {
            "workspace": {
              "type": "string",
              "description": "Your Bitbucket workspace name"
            },
            "repository": {
              "type": "string",
              "description": "Your Bitbucket repository name"
            }
          }
        },
        "credentials": {
          "type": "object",
          "required": ["bitbucket_apiKey", "bitbucket_username"],
          "properties": {
            "bitbucket_apiKey": {
              "type": "string",
              "description": "Your API key"
            },
            "bitbucket_username": {
              "type": "string",
              "description": "Your Bitbucket username"
            }
          }
        }
      }
    },
    "instruction": "Create a Bitbucket pipeline status tool named 'bitbucket_get_pipeline_status'.\nSteps:\n1. Get repository metadata using GET /2.0/repositories/{workspace}/{repository} to find the default branch\n2. Fetch recent pipelines using GET /2.0/repositories/{workspace}/{repository}/pipelines/?sort=-created_on&pagelen=5\n3. Return the pipeline status information for the most recent pipeline",
    "outputTransform": "(sourceData) => {\n  // Defensive: ensure pipelines array exists\n  const pipelines = sourceData.getRecentPipelines.data?.values;\n  if (!Array.isArray(pipelines) || pipelines.length === 0) {\n    return { status: 'No pipelines found', pipeline: null };\n  }\n  // Return the status info for the most recent pipeline\n  const mostRecent = pipelines[0];\n  return {\n    status: mostRecent.state?.result?.name || mostRecent.state?.name || 'UNKNOWN',\n    pipeline: {\n      uuid: mostRecent.uuid,\n      build_number: mostRecent.build_number,\n      created_on: mostRecent.created_on,\n      target: mostRecent.target,\n      state: mostRecent.state,\n      url: mostRecent.links?.web?.href || mostRecent.links?.self?.href\n    }\n  };\n}",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "success": {
          "type": "boolean"
        },
        "default_branch": {
          "type": "string"
        },
        "latest_pipeline": {
          "type": "object"
        },
        "pipeline_status": {
          "type": "string"
        }
      }
    },
    "description": "This tool connects to Bitbucket to retrieve information about your repository and its recent pipelines. It provides the status of the most recent pipeline, including details like its creation date and unique identifier."
  },
  "bitbucket-get-repo-metadata": {
    "id": "bitbucket-get-repo-metadata",
    "steps": [
      {
        "id": "fetchRepoMetadata",
        "apiConfig": {
          "id": "fetchRepoMetadata",
          "body": null,
          "method": "GET",
          "headers": {
            "Authorization": "Bearer <<bitbucket_apiKey>>"
          },
          "urlHost": "https://api.bitbucket.org/",
          "urlPath": "/2.0/repositories/<<workspace>>/<<repository>>",
          "dataPath": null,
          "pagination": null,
          "instruction": "Fetch comprehensive metadata for a specific Bitbucket repository, including details such as default branch, description, language, size, and other available metadata fields. The response should provide all available repository information.",
          "queryParams": null,
          "authentication": null,
          "outputSchema": null,
          "responseMapping": null,
          "documentationUrl": null
        },
        "inputMapping": null,
        "loopMaxIters": null,
        "dataSelector": "(sourceData) => ({ workspace: sourceData.workspace, repository: sourceData.repository });",
        "executionMode": null,
        "responseMapping": "$"
      }
    ],
    "createdAt": "2025-11-04T14:14:03.467Z",
    "updatedAt": "2025-11-04T14:14:03.467Z",
    "inputSchema": {
      "type": "object",
      "required": ["payload", "credentials"],
      "properties": {
        "payload": {
          "type": "object",
          "required": ["workspace", "repository"],
          "properties": {
            "workspace": {
              "type": "string",
              "description": "Your Bitbucket workspace name"
            },
            "repository": {
              "type": "string",
              "description": "Your Bitbucket repository name"
            }
          }
        },
        "credentials": {
          "type": "object",
          "required": ["bitbucket_apiKey", "bitbucket_username"],
          "properties": {
            "bitbucket_apiKey": {
              "type": "string",
              "description": "Your API key"
            },
            "bitbucket_username": {
              "type": "string",
              "description": "Your Bitbucket username"
            }
          }
        }
      }
    },
    "instruction": "Create a Bitbucket repository metadata tool named 'bitbucket-get-repo-metadata'.\nSteps:\n1. Fetch repository metadata using GET /2.0/repositories/{workspace}/{repository}\n2. Return comprehensive repository information including default branch, description, language, size, and other metadata",
    "outputTransform": "(sourceData) => {\n  const repo = sourceData.fetchRepoMetadata.data;\n  if (!repo) throw new Error('No repository metadata found');\n  return {\n    name: repo.name,\n    full_name: repo.full_name,\n    uuid: repo.uuid,\n    description: repo.description,\n    is_private: repo.is_private,\n    language: repo.language,\n    size: repo.size,\n    created_on: repo.created_on,\n    updated_on: repo.updated_on,\n    mainbranch: repo.mainbranch?.name,\n    default_branch: repo.mainbranch?.name,\n    slug: repo.slug,\n    scm: repo.scm,\n    website: repo.website,\n    project: repo.project,\n    owner: repo.owner,\n    links: repo.links,\n    fork_policy: repo.fork_policy,\n    has_issues: repo.has_issues,\n    has_wiki: repo.has_wiki,\n    watchers_count: repo.watchers?.size,\n    forks_count: repo.forks?.size,\n    parent: repo.parent,\n    workspace: repo.workspace,\n    // Add any other available metadata fields as needed\n    raw: repo // include full raw object for completeness\n  };\n}",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "success": {
          "type": "boolean"
        },
        "language": {
          "type": "string"
        },
        "repository": {
          "type": "object"
        },
        "default_branch": {
          "type": "string"
        }
      }
    },
    "description": "This tool connects to Bitbucket to retrieve detailed information about a specific repository. It provides comprehensive metadata, including the repository's default branch, description, programming language, size, and more."
  },
  "bitbucket-list-repos": {
    "id": "bitbucket-list-repos",
    "steps": [
      {
        "id": "listRepositories",
        "apiConfig": {
          "id": "listRepositories",
          "body": null,
          "method": "GET",
          "headers": {
            "Authorization": "Basic <<bitbucket_username>>:<<bitbucket_apiKey>>"
          },
          "urlHost": "https://api.bitbucket.org/",
          "urlPath": "/2.0/repositories/<<workspace>>",
          "dataPath": null,
          "pagination": {
            "type": "PAGE_BASED",
            "pageSize": "<<pagelen>>",
            "cursorPath": "",
            "stopCondition": "(response, pageInfo) => !response.data.next"
          },
          "instruction": "Retrieve all repositories for the specified workspace, supporting pagination and optional filters. Return all available metadata for each repository, including name, full_name, description, and clone URLs.",
          "queryParams": {
            "page": "<<page>>",
            "pagelen": "<<pagelen>>"
          },
          "authentication": null,
          "outputSchema": null,
          "responseMapping": null,
          "documentationUrl": null
        },
        "inputMapping": null,
        "loopMaxIters": null,
        "dataSelector": "(sourceData) => ({});",
        "executionMode": null,
        "responseMapping": "$"
      }
    ],
    "createdAt": "2025-11-04T14:52:28.635Z",
    "updatedAt": "2025-11-04T14:52:28.635Z",
    "inputSchema": {
      "type": "object",
      "required": ["payload", "credentials"],
      "properties": {
        "payload": {
          "type": "object",
          "required": ["workspace", "page", "pagelen"],
          "properties": {
            "page": {
              "type": "integer",
              "description": "Page number to start from"
            },
            "pagelen": {
              "type": "integer",
              "description": "Number of repositories per page"
            },
            "workspace": {
              "type": "string",
              "description": "Your workspace name"
            }
          }
        },
        "credentials": {
          "type": "object",
          "required": ["bitbucket_apiKey", "bitbucket_username"],
          "properties": {
            "bitbucket_apiKey": {
              "type": "string",
              "description": "Your API key"
            },
            "bitbucket_username": {
              "type": "string",
              "description": "Your Bitbucket username"
            }
          }
        }
      }
    },
    "instruction": "Create a Bitbucket repository listing tool named 'bitbucket-list-repos'.\nSteps:\n1. List repositories for a workspace using GET /2.0/repositories/{workspace}\n2. Include pagination parameters and filters if needed\n3. Return the list of repositories with basic metadata like name, full_name, description, and clone URLs",
    "outputTransform": "(sourceData) => {\n  // Bitbucket paginated response: { values: [ ... ], next: ... }\n  // We want: [{ name, full_name, description, clone_urls: [...] }, ...]\n  const allRepos = Array.isArray(sourceData.listRepositories)\n    ? sourceData.listRepositories.flatMap(item => item.data.values || [])\n    : (sourceData.listRepositories.data?.values || []);\n  return allRepos.map(repo => ({\n    name: repo.name,\n    full_name: repo.full_name,\n    description: repo.description,\n    clone_urls: Array.isArray(repo.links?.clone) ? repo.links.clone.map(c => ({ href: c.href, name: c.name })) : []\n  }));\n}",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "page": {
          "type": "number"
        },
        "message": {
          "type": "string"
        },
        "success": {
          "type": "boolean"
        },
        "total_count": {
          "type": "number"
        },
        "repositories": {
          "type": "array",
          "items": {
            "type": "object"
          }
        }
      }
    },
    "description": "This tool connects to Bitbucket to retrieve a list of all repositories within a specified workspace. It returns detailed information for each repository, including their names, descriptions, and clone URLs, while supporting pagination for large datasets."
  },
  "bitbucket_list_tags": {
    "id": "bitbucket_list_tags",
    "steps": [
      {
        "id": "fetchAllTags",
        "apiConfig": {
          "id": "fetchAllTags",
          "body": null,
          "method": "GET",
          "headers": {
            "Authorization": "Bearer <<bitbucket_apiKey>>"
          },
          "urlHost": "https://api.bitbucket.org",
          "urlPath": "/2.0/repositories/<<workspace>>/<<repository>>/refs/tags",
          "dataPath": null,
          "pagination": {
            "type": "CURSOR_BASED",
            "pageSize": "100",
            "cursorPath": "data.next",
            "stopCondition": "(response, pageInfo) => !response.data.next"
          },
          "instruction": "Fetch all tags from the specified Bitbucket repository, using pagination (pagelen=100) and following the next cursor to retrieve all tags and their metadata.",
          "queryParams": {
            "pagelen": "100"
          },
          "authentication": null,
          "outputSchema": null,
          "responseMapping": null,
          "documentationUrl": null
        },
        "inputMapping": null,
        "loopMaxIters": null,
        "dataSelector": "(sourceData) => ({});",
        "executionMode": null,
        "responseMapping": "$"
      }
    ],
    "createdAt": "2025-11-04T13:43:40.868Z",
    "updatedAt": "2025-11-04T13:43:40.868Z",
    "inputSchema": {
      "type": "object",
      "required": ["payload", "credentials"],
      "properties": {
        "payload": {
          "type": "object",
          "required": ["workspace", "repository"],
          "properties": {
            "workspace": {
              "type": "string",
              "description": "Your Bitbucket workspace name"
            },
            "repository": {
              "type": "string",
              "description": "Your Bitbucket repository name"
            }
          }
        },
        "credentials": {
          "type": "object",
          "required": ["bitbucket_apiKey", "bitbucket_username"],
          "properties": {
            "bitbucket_apiKey": {
              "type": "string",
              "description": "Your API key"
            },
            "bitbucket_username": {
              "type": "string",
              "description": "Your Bitbucket username"
            }
          }
        }
      }
    },
    "instruction": "Create a Bitbucket tags listing tool named 'bitbucket_list_tags'.\nSteps:\n1. Fetch all tags from the repository using GET /2.0/repositories/{workspace}/{repository}/refs/tags\n2. Use pagination to get all tags (pagelen=100 and follow next cursor)\n3. Return the complete list of tags with their metadata",
    "outputTransform": "(sourceData) => { return { tags: Array.isArray(sourceData.fetchAllTags) ? sourceData.fetchAllTags.flatMap(item => item.data.values || []) : (sourceData.fetchAllTags.data?.values || []) }; }",
    "systemIds": [],
    "outputSchema": {
      "type": "object",
      "properties": {
        "tags": {
          "type": "array",
          "items": {
            "type": "object"
          }
        },
        "success": {
          "type": "boolean"
        },
        "total_count": {
          "type": "number"
        }
      }
    },
    "description": "This tool connects to Bitbucket to retrieve a comprehensive list of all tags from a specified repository. It will return detailed information about each tag, including metadata, ensuring you have a complete overview of your repository's tagging structure."
  }
}
