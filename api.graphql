scalar JSONSchema
scalar JSON
scalar JSONata
scalar DateTime
scalar Upload

interface BaseConfig {
  id: ID
  version: String
  createdAt: DateTime
  updatedAt: DateTime
}

union ConfigType = ApiConfig | Workflow | ExtractConfig

# deprecated - only left in for backwards compatibility with one customer
type ApiConfig implements BaseConfig {
  # BaseConfig
  id: ID
  version: String
  createdAt: DateTime
  updatedAt: DateTime

  # Specific implementation
  urlHost: String
  urlPath: String
  instruction: String
  method: HttpMethod
  queryParams: JSON
  headers: JSON
  body: String
  pagination: Pagination
}

# used by the tool creation for file content extraction
type ExtractConfig implements BaseConfig {
  # BaseConfig
  id: ID
  version: String
  createdAt: DateTime
  updatedAt: DateTime

  # Specific implementation
  urlHost: String
  urlPath: String
  queryParams: JSON
  instruction: String
  method: HttpMethod
  headers: JSON
  body: String
  documentationUrl: String
  decompressionMethod: DecompressionMethod
  authentication: AuthType
  fileType: FileType
  dataPath: String
}

type RunResult {
  id: ID!
  success: Boolean!
  data: JSON
  headers: JSON
  statusCode: Int
  error: String
  startedAt: DateTime!
  completedAt: DateTime!
  config: ConfigType
}

type Run {
  id: ID!
  toolId: String!
  status: RunStatus!
  toolConfig: Workflow
  toolPayload: JSON
  toolResult: JSON
  stepResults: [WorkflowStepResult!]
  options: JSON
  requestSource: String
  error: String
  startedAt: DateTime!
  completedAt: DateTime
}

type Pagination {
  type: PaginationType!
  pageSize: String
  cursorPath: String
  stopCondition: String
}

type RunList {
  items: [Run!]!
  total: Int!
}

type ApiList {
  items: [ApiConfig!]!
  total: Int!
}

type WorkflowList {
  items: [Workflow!]!
  total: Int!
}

type SystemList {
  items: [System!]!
  total: Int!
}

enum AuthType {
  NONE
  HEADER
  QUERY_PARAM
  OAUTH2
}

enum DecompressionMethod {
  GZIP
  DEFLATE
  NONE
  AUTO
  ZIP
}

enum HttpMethod {
  GET
  POST
  PUT
  DELETE
  PATCH
  HEAD
  OPTIONS
}

enum CacheMode {
  ENABLED
  READONLY
  WRITEONLY
  DISABLED
}

enum PaginationType {
  OFFSET_BASED
  PAGE_BASED
  CURSOR_BASED
  DISABLED
}

enum FileType {
  CSV
  JSON
  XML
  YAML
  RAW
  AUTO
}

enum FailureBehavior {
  FAIL
  CONTINUE
}

enum LogLevel {
  DEBUG
  INFO
  WARN
  ERROR
}

enum UpsertMode {
  CREATE
  UPDATE
  UPSERT
}

enum CredentialMode {
  MERGE
  REPLACE
}

input PaginationInput {
  type: PaginationType!
  pageSize: String
  cursorPath: String
  stopCondition: String
}

input ApiInput {
  id: ID!
  urlHost: String
  urlPath: String
  instruction: String
  queryParams: JSON
  method: HttpMethod
  headers: JSON
  body: String
  pagination: PaginationInput
  version: String
}

input ExtractInput {
  id: ID!
  urlHost: String
  urlPath: String
  queryParams: JSON
  instruction: String
  method: HttpMethod
  headers: JSON
  body: String
  documentationUrl: String
  decompressionMethod: DecompressionMethod
  fileType: FileType
  authentication: AuthType
  dataPath: String
  version: String
}

input RequestOptions {
  selfHealing: SelfHealingMode
  cacheMode: CacheMode
  timeout: Int
  retries: Int
  retryDelay: Int
  webhookUrl: String
  testMode: Boolean
}

enum SelfHealingMode {
  ENABLED
  TRANSFORM_ONLY
  REQUEST_ONLY
  DISABLED
}

enum RunStatus {
  RUNNING
  SUCCESS
  FAILED
  ABORTED
}

enum FilterTarget {
  KEYS
  VALUES
  BOTH
}

enum FilterAction {
  REMOVE
  MASK
  FAIL
}

enum RemoveScope {
  FIELD
  ITEM
  ENTRY
}

type ResponseFilter {
  id: ID!
  name: String
  enabled: Boolean!
  target: FilterTarget!
  pattern: String!
  action: FilterAction!
  maskValue: String
  scope: RemoveScope
}

input ResponseFilterInput {
  id: ID!
  name: String
  enabled: Boolean!
  target: FilterTarget!
  pattern: String!
  action: FilterAction!
  maskValue: String
  scope: RemoveScope
}

input ApiInputRequest @oneOf {
  endpoint: ApiInput
  id: ID
}

input ExtractInputRequest @oneOf {
  endpoint: ExtractInput
  file: Upload
  id: ID
}

input WorkflowInputRequest @oneOf {
  workflow: WorkflowInput
  id: ID
}

input SystemInput {
  id: ID!
  name: String
  urlHost: String
  urlPath: String
  credentials: JSON
  documentationUrl: String
  documentation: String
  documentationPending: Boolean
  specificInstructions: String
  documentationKeywords: [String!]
  icon: String
  metadata: JSON
  templateName: String
}

type Log {
  id: ID!
  message: String!
  level: LogLevel!
  timestamp: DateTime!
  traceId: ID
}

type ToolStep {
  systemId: String
  instruction: String
}

type SuggestedTool {
  id: ID!
  instruction: String
  inputSchema: JSON
  steps: [ToolStep!]
  responseSchema: JSON
  reason: String!
}

type Query {
  listWorkflows(limit: Int = 10, offset: Int = 0): WorkflowList!
  listSystems(limit: Int = 10, offset: Int = 0): SystemList!
  findRelevantTools(searchTerms: String): [SuggestedTool!]

  getWorkflow(id: ID!): Workflow
  getSystem(id: ID!): System
  searchSystemDocumentation(systemId: ID!, keywords: String!): String!
  generateInstructions(systems: [SystemInput!]!): [String!]!
  getTenantInfo: TenantInfo
}

type TenantInfo {
  email: String
  emailEntrySkipped: Boolean!
}

type ExecutionStep {
  id: String!
  modify: Boolean
  apiConfig: ApiConfig!
  systemId: ID
  executionMode: String # DIRECT | LOOP
  loopSelector: JSONata
  failureBehavior: FailureBehavior
}

input ExecutionStepInput {
  id: String!
  modify: Boolean
  apiConfig: ApiInput!
  systemId: ID
  executionMode: String # DIRECT | LOOP
  loopSelector: JSONata
  failureBehavior: FailureBehavior
}

type Workflow implements BaseConfig {
  # BaseConfig
  id: ID
  version: String
  createdAt: DateTime
  updatedAt: DateTime

  # Specific implementation
  steps: [ExecutionStep!]
  systemIds: [ID]
  instruction: String
  finalTransform: JSONata
  responseSchema: JSONSchema
  inputSchema: JSONSchema
  originalResponseSchema: JSONSchema
  folder: String
  archived: Boolean
  responseFilters: [ResponseFilter!]
}

type WorkflowStepResult {
  stepId: String!
  success: Boolean!
  rawData: JSON
  transformedData: JSON
  error: String
}

type WorkflowResult {
  id: ID!
  success: Boolean!
  data: JSON
  error: String
  startedAt: DateTime!
  completedAt: DateTime!
  config: Workflow
  stepResults: [WorkflowStepResult!]
}

type AbortToolExecutionResult {
  success: Boolean!
  runId: ID!
}

input WorkflowInput {
  id: String!
  steps: [ExecutionStepInput!]
  systemIds: [ID!]
  finalTransform: JSONata
  inputSchema: JSONSchema
  responseSchema: JSONSchema
  version: String
  instruction: String
  folder: String
  archived: Boolean
  responseFilters: [ResponseFilterInput!]
}

type Mutation {
  setTenantInfo(email: String, emailEntrySkipped: Boolean): TenantInfo!

  extract(
    input: ExtractInputRequest!
    payload: JSON
    credentials: JSON
    options: RequestOptions
  ): RunResult!

  executeWorkflow(
    input: WorkflowInputRequest!
    payload: JSON
    credentials: JSON
    options: RequestOptions
    runId: ID
    traceId: ID
  ): WorkflowResult!

  abortToolExecution(runId: ID!): AbortToolExecutionResult!

  buildWorkflow(
    instruction: String!
    payload: JSON
    systemIds: [ID!]
    responseSchema: JSONSchema
    traceId: ID
  ): Workflow!

  upsertWorkflow(id: ID!, input: JSON!): Workflow!
  deleteWorkflow(id: ID!): Boolean!
  renameWorkflow(oldId: ID!, newId: ID!): Workflow!

  upsertApi(id: ID!, input: JSON!): ApiConfig!
  deleteApi(id: ID!): Boolean!

  upsertSystem(
    input: SystemInput!
    mode: UpsertMode = UPSERT
    credentialMode: CredentialMode = MERGE
  ): System!
  deleteSystem(id: ID!): Boolean!

  cacheOauthClientCredentials(
    clientCredentialsUid: String!
    clientId: String!
    clientSecret: String!
  ): Boolean!
  getOAuthClientCredentials(templateId: ID, clientCredentialsUid: String): OAuthClientCredentials!

  callEndpoint(
    systemId: ID
    method: HttpMethod!
    url: String!
    headers: JSON
    body: String
    timeout: Int
  ): CallEndpointResult!

  fixWorkflow(
    workflow: WorkflowInput!
    fixInstructions: String!
    lastError: String
    systemIds: [ID!]
  ): FixWorkflowResult!
}

type Subscription {
  logs: Log!
}

type System {
  id: ID!
  name: String
  type: String
  urlHost: String
  urlPath: String
  credentials: JSON
  documentationUrl: String
  documentation: String
  documentationPending: Boolean
  openApiUrl: String
  openApiSchema: String
  specificInstructions: String
  documentationKeywords: [String!]
  icon: String
  metadata: JSON
  templateName: String
  version: String
  createdAt: DateTime
  updatedAt: DateTime
}

type OAuthClientCredentials {
  client_id: String!
  client_secret: String!
}

type CallEndpointResult {
  success: Boolean!
  status: Int
  statusText: String
  headers: JSON
  body: JSON
  error: String
  duration: Int!
}

type ToolDiff {
  op: String!
  path: String!
  value: JSON
  from: String
}

type FixWorkflowResult {
  workflow: Workflow!
  diffs: [ToolDiff!]!
}
